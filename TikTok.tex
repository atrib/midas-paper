\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts

% to be able to draw some self-contained figs
\usepackage{tikz}
\usepackage{amsmath}

\usepackage{listings}
\usepackage{parcolumns}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}
\usepackage[inline]{enumitem}


\usepackage{hyperref}

\renewcommand\sectionautorefname{Section}  
\renewcommand\subsectionautorefname{Subsection}
\renewcommand\itemautorefname{Attack}
\renewcommand\figureautorefname{Figure}
\renewcommand\tableautorefname{Table}

% Comment macros
\newcommand{\uros}[1]{\textcolor{pink}{\textbf{UT:} #1}}
\newcommand{\pra}[1]{\textcolor{blue}{\textbf{PS:} #1}}
\newcommand{\nb}[1]{\textcolor{green}{\textbf{NB}: #1}}
\newcommand{\mat}[1]{\textcolor{red}{\textbf{Mat:} #1}}
\newcommand{\evalfull}[1]{20}
\newcommand{\evalnocalls}[1]{3}
\newcommand{\sysname}{TikTok}
\newcommand{\roughevaloverheadbad}{18\%}
\newcommand{\roughevaloverheadbetter}{2-4\%}



%-------------------------------------------------------------------------------
\begin{document}
%-------------------------------------------------------------------------------

%do not want date printed
\date{}

% make title bold and 14 pt font (Latex default is non-bold, 16 pt)
\title{\Large \bf TikTok: Kernel TOCTTOU Protection}

%for single author (just remove % characters)
\author{
Anonymous submission \#TODO to Security & Privacy '21
%{\rm Eric Tusso}\\
%EPFL
%\and
%{\rm Yamaha Priest}\\
%EPFL
% copy the following lines to add more authors
% \and
% {\rm Name}\\
%Name Institution
} % end author

\maketitle

%-------------------------------------------------------------------------------
\begin{abstract}
%-------------------------------------------------------------------------------

Double-fetch bugs are a plague in all major operating system kernels.  They
occur when data is fetched twice across the trust-boundary without checking that
it has not changed. Such bugs may force the kernel into an inconsistent state,
allowing an attacker to illegally access memory, cause denial of service, or to
escalate their privileges.

So far, the only protection against double-fetch bugs is to detect and fix them.
However, they exhibit illegal behavior only under specific conditions, making
them incredibly hard to find. Even worse, the bug may be in unchangeable code
(e.g., a binary driver blob).
%
We propose \sysname{} to mitigate double-fetch bugs.  \sysname{} leverages
on-the-fly page-table hardening to prevent changes to the system call arguments,
while the system call executes.

\sysname{} shows no noticeable drop in performance when evaluated on CPU-bound
workloads. On extremely system call heavy workloads, \sysname{} shows
\roughevaloverheadbetter{} overhead when protecting select system calls, and
\roughevaloverheadbad{} when all system calls are guarded.


\end{abstract}

\begin{IEEEkeywords}
Double-fetch bugs, TOCTTOU, kernel security, page-tables, mitigation
\end{IEEEkeywords}

% Talk about the system call filters and how they can be used for good
% Introduce the main problem - TOCTTOU
% Brag how our system is the best thing since sliced bread
\section{Introduction}

% Syscalls are a lucrative attack surface for adversaries which needs to be protected
Modern systems are broken into \emph{untrusted} user-space and the
\emph{trusted} kernel.  All data that crosses this trust boundary must be
checked.  Double-fetch bus~\cite{serna08doublefetch, twizsgrakky07ring0,
wilhelm2016xenpwn, wang2018survey} occur when higher-privileged code (e.g., the
kernel) reads the same data twice from a lower-privileged address space (e.g.,
user-space). As an attacker could change the data between the two reads, this
allows a plethora of attack vectors.  Double-fetch bugs are a type of a
\emph{race condition} between two threads of different privileges. A
\emph{Time-of-check to time-of-use (TOCTTOU)} violation occurs when the first
read is used to check an operation while the second read is used to modify the
state.  Double-fetch bugs are a frequent problem in kernels and
hypervisors~\cite{cve201812633, cve202012652, cve20131332, cve201920610,
cve20158550, cve201610439, cve201610435, cve201610433, cve20195519,
cve20168438}. Considering that double-fetches also appear in drivers, legacy
systems with binary-only drivers cannot be patched, even if a bug is found.
Furthermore, Watson~\cite{watson2007exploiting} blames an unfixable TOCTTOU bug
as a reason for the insecurity of \emph{system call wrappers}.  

This state of affairs calls for a system that \emph{mitigates} double-fetches in
system calls to protect the kernel.
%
% Define system constraints
To mitigates double-fetch bugs a system needs to
%\begin{enumerate}
%  \item 
prevent any changes from concurrent threads to memory accessed by the system call
%  \item Enable correct system call execution
%  \item Enable correct execution of threads trying to change the arguments
%\end{enumerate}
%\mat{The other two points (enable correct...) are somewhat moot and noops.}



%\mat{You do not introduce \sysname but merely will it into existence. Introduce
%what the key aspects are and say we present \sysname.}


% Cover the second point. Mention the calls for which it makes no sense to protect
Preventing writes from user-space is not enough to guarantee immutability of
arguments. The adversary can invoke system calls which write to memory and force
the kernel to perform the write for them. The protection against kernel writes
is necessary as well. Guarding only the addresses where are the arguments are
stored would enable the adversary to map them with different privileges,
requiring the monitoring of the pages being mapped. Finally, the adversary can
invoke a system call to write to the file directly. The \texttt{write} call uses
kernel mappings of the pages that could be mapped in user-space, altering their
data. Pages that belong to devices can change their values independently of the 
user or the kernel. The possible attack vectors are:
\begin{enumerate*}[label=(\roman*)]
\item \label{attk:direct} direct writes from user-space
\item \label{attk:systemcall} kernel writes from system calls
\item \label{attk:remapping} remapping the pages with different permissions
\item \label{attk:writebuffers}\texttt{write} calls to a file that alter mapped file pages
\item \label{attk:devicefiles} storing arguments on device-backed pages
\end{enumerate*}
%\mat{Watch for structure: you mix and match design criteria, attack vectors, and
%implementation aspects. Break them up into individual paragraphs and enumerate
%them so that you can reference what attack vector is solved by which design
%point.}

\emph{Marking} the pages \emph{read-only} when system call arguments are read
the first time prevents \autoref{attk:direct} and \autoref{attk:systemcall}.
As the page is loaded, it is checked for a mark, and the permissions of the 
mapping are adjusted if necessary. This defends against \autoref{attk:remapping}.
Pausing system calls that write to a file while some of its mapped pages are
marked prevents \autoref{attk:writebuffers}. Finally, \autoref{attk:devicefiles}
can be prevented by stopping the adversary from mapping devices through
\emph{Discretionary Access Control (DAC)}.

The protection relies on the interface for reading from the user-space and the
page-tables to protect the marked pages. The threads that attempt a write to a
marked page are stopped in the \emph{page-fault handler}. They continue their
execution after the page is unmarked. The interface for writing to user-space
from kernel is extended to execute all writes to marked pages at the end of the
call. This prevents the system calls that write to the pages they have marked
from self-deadlocking and lets them execute correctly.

A small subset of system calls (e.g. \texttt{pollfd}, \texttt{futex})
depend on the writes from user-space or double-fetches for the correct behavior.
Similarly, system calls that read memory and potentially take a long time to
execute will keep those pages marked during their execution. For such calls
protection must be disabled and they should be manually inspected for
double-fetch bugs.


% Introduce TikTok
%\mat{You've been talking about \sysname for about 5-6 paragraphs, the
%introduction is late and very repetitive to what was said before. Improve the
%structure: attacks first, then design points, then one paragraph about the
%implementation key items (not details).}
We present \sysname{} --- a memory marking extension to the Linux kernel.
\sysname{} provides system calls with a view of the memory at the time it has
been read for the first time. \sysname{} also groups all the writes that could
modify protected memory and executes them at the end of the call. By mitigating
double-fetches, \sysname{} provides protection even against the double-fetch
bugs in the code that cannot be modified.. Furthermore, \sysname{} renders
previously unavoidable double-fetches (such as a TOCTTOU in system-call
wrappers) completely benign. \sysname{} works on modern Linux distributions
(Ubuntu Server 18.04 LTS) and doesn't require any modifications to the user
programs. It can be implemented in other kernels and architectures which use
page-tables and a well defined API to communicate with the user space
(\texttt{read\_in} and \texttt{write\_out} abstractions).

% Sneak-peek into the results

Benchmarking \sysname{} showed that multithreaded programs with lots of marking
system calls, such as Apache and NginX, suffer an \roughevaloverheadbad{} drop in
performance with \sysname{} protecting all possible system-calls. By reducing
the number of protected calls, the overhead drops to \roughevaloverheadbetter{}.
CPU-bound programs showed almost no performance drop when using \sysname{}, even
when they used multiple threads (OMP) or multi-process message-passing (MPI).



% Three new things in this paper
The main contributions of this paper are:

\begin{itemize}
\item A technique how to temporarily prevent the change of memory by safely
      postponing both user-space and kernel writes
\item A \emph{confused deputy attack} on memory-marking systems that mark the pages with a \emph{superuser} bit (\autoref{attk:systemcall})
\item A solution to the problem of system calls that write to the memory they have read
\item \sysname{} --- a mitigation for the double-fetch and TOCTTOU attacks on system
      call arguments in the Linux kernel
\end{itemize}

% Cover the theory needed to understand how and why TikTok works
% 1) IPC - We need this to argue why the deadlocks are almost impossible
% 2) VM and Page Tables - Why it exists and how it works
% 3) x86 Page Tables - Continue the discussion from the previous section
% 4) Page faults - Explain how and why they happen.
% 5) Copy to/from user - Explain why the API has been introduced
% 6) Double-fetches - Provide a high-level overview
\section{Background}
\label{sec:background}

\sysname{} orchestrates several Linux subsystems to provide its protection. It uses
\emph{page-tables} to mark \emph{shared memory} storing the system call
arguments as \emph{read-only}. Different system calls have different
relationships with shared memory, and interact with \sysname{} differently in
practice. This section provides the background information necessary to reason
why and how \sysname{} protects the arguments from change while enabling the threads to
execute correctly.

% I want to cover why this background is needed. IPC is the most problematic
% because it is used to justify the abscence of deadlocks
\autoref{subsec:ipc} introduces two different ways of communication between
processes - \emph{shared memory} and \emph{message-passing}. \sysname{} affects
both of these methods because the arguments of the message-passing system calls
are stored in (potentially shared) memory. If \sysname{} marks message-passing
system-call arguments, this introduces additional synchronization points (waits)
when writing to them. The new waits can interact with already present
synchronization primitives to cause deadlocks. In \autoref{sec:deadlocks} we
explain why they do not appear in practice.

\autoref{subsec:vm} covers the organization of \emph{virtual memory},
\emph{page-tables} and the interface the Linux kernel uses to access the
user-space memory. This section is essential to understanding the implementation
of \sysname.

\autoref{subsec:doublefetch} details the \emph{double-fetch} bug that \sysname{}
is mitigating. It explains its cause and the different types of double-fetch bugs.


\subsection{Interprocess Communication}
\label{subsec:ipc}

The two main types of communication between processes are \emph{shared memory} 
and \emph{message passing}~\cite{silberschatz2018operating}.

% Intro to shared-memory
Shared memory relies on two processes having a section of memory that both can 
access. Data transfer is fast, but the synchronization is problematic. 
Processes must monitor shared memory for changes, leading to unnecessary
polling.

% Intro to message-passing
Message passing consists of one process calling \texttt{send}, and another one
calling \texttt{receive} to fetch the message. Synchronous message passing
blocks execution until the calls have finished.
% The state of the modern OSs and concurrent programs
Modern operating systems support both of these approaches. \sysname{} interferes
with message-passing system calls by linking them to shared memory. Marking the
arguments adds additional synchronization points that can interact with the
blocking semantics of some system calls.

\subsection{Linux Memory Subsystem}
\label{subsec:vm}

% Paged VM and the introduction to permissions we will later use in TikTok
Linux implements \emph{paged virtual memory} and uses \emph{virtual addresses}
which map to \emph{physical addresses} in RAM. The mapping function is defined
for each process by a multi-level \emph{page-table}.

\begin{figure}[]
  \centering
  \includegraphics[width = .35 \textwidth]{img/pagetable.pdf}
  \caption{Page Table Structure on x86. Only relevant data has been included.}
  \label{fig:pagetable}
\end{figure}
x86-64 architecture officially supports paged virtual memory model with a 5 
level page table (\autoref{fig:pagetable}):
\begin{LaTeXdescription}
    \item[PGD] Page Global Directory
    \item[P4D] Page Fourth-level Directory
    \item[PUD] Page Upper Directory
    \item[PMD] Page Middle Directory
    \item[PTE] Page Table Entry
\end{LaTeXdescription}

% The flags are needed to discuss marking
Every level corresponds to eight bits in the virtual address, with the remaining twelve
bits identifying the offset in the actual page frame. A page table entry
includes the following information:
\begin{LaTeXdescription}
    \item[Present bit (\textbf{P})] is set if the page is present in memory
    \item[Read/Write bit (\textbf{R/W})] denotes if the page is writable or just
         readable
    \item[User/Superuser bit (\textbf{U/S})] represents if the page can be 
    accessed by the user, or only by the superuser
    \item[Not Executable bit (\textbf{NX})] is set if the code stored on the 
    page cannot be executed
    \item[Page Frame Number] denotes the page frame the entry points to
    \item[\textbf{SW1-SW4}] Four bits free for the OS to use
\end{LaTeXdescription}

Considering that the page-table traversal is frequent, it is implemented in
hardware by the \emph{memory management unit} (MMU). Reading the page-table from
memory is slow, so a small cache --- \emph{translation-lookaside buffer} (TLB)
--- is added to the MMU to store frequently accessed page entries. On modern
processors, a TLB consists of several levels, and can even be backed by another
MMU cache. Kernel developers can \emph{flush} (clear) certain TLB ranges in
software.

% Explain what a page fault is, as well as COW (mentioned later as an optimizaiton)
On an invalid access (e.g., wrong permissions, page not present) the MMU will
trigger a page-fault. The page-fault handler executes in the kernel context of
the faulting thread and performs the appropriate action (e.g. load a page, kill
the thread). With the advent of cloud computing, \emph{user-space page-fault
handling} has been added to the Linux kernel. \sysname{} relies on the page-fault
handler for protection, so the user-space page-fault handling must be disabled.

Memory in Linux can be either \emph{file-backed} or \emph{anonymous}.
File-backed pages have a map to the corresponding file. Anonymous pages do not
have a backing file (e.g., stack and heap).

Another classification is based on privacy: \emph{private} and \emph{shared}. 
Private memory is part of only one virtual memory space. This memory space can 
be accessed by multiple threads in a process, but no threads outside the process
have access. Shared memory can be accessed by different processes.

% This is the most important paragraph and a basis for one of the attacks. The
% previous two paragraphs are just the introduction
Unlike private memory and shared anonymous memory, shared file-backed memory can
be \emph{mapped and unmapped at will}. Its content is backed by a file, so the
data is \emph{preserved} between (un)mappings.

\subsection{Copy-from-User and Copy-to-User}
\label{subsec:copy}

Linux user a well-defined interface to communicate with the user-space:
\texttt{(\_\_)copy\_(from/to)\_user}, \texttt{(\_\_)(get/put)\_user},
\texttt{user\_str(cpy/len)}. When the actual implementation is not important,
this API is refered to \texttt{read\_in} and \texttt{write\_out}.

The abstraction is needed due to different handling of page-faults in user-space
and in the kernel. User-space memory can be \emph{paged-out} to the disk and
trigger a page-fault on access. However, kernel memory is never paged-out and
does not cause page-faults. All the user-space pointers in the kernel are
processed by this limited set of functions that know how to handle page-faults.

\sysname{} extends this interface to perform additional checks and the bookkeeping
of marked pages.

\subsection{Double Fetch Bugs}
\label{subsec:doublefetch}

\begin{figure}[]
  \centering
  \includegraphics[width=.85\linewidth]{img/doublefetch.pdf}
  \caption{Diagram of a double-fetch bug}
  \label{fig:doublefetch}
\end{figure}

\begin{lstlisting}[language=C, caption=Abridged CVE-2018-12633 Double Fetch in Linux,
                  label=code:cvedoublefetch,  breaklines=true
                  postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space},
                  numbers=left,basicstyle=\scriptsize, xleftmargin=5.0ex]
static long vbg_misc_device_ioctl(
        struct file *filp,
        unsigned int req,
        unsigned long arg)
{
  size_t size;
  struct vbg_ioctl_hdr hdr;
  void *buf;

  if (copy_from_user(&hdr, (void *)arg, sizeof(hdr))) 
    return -EFAULT;
  
  if (hdr.version != VBG_IOCTL_HDR_VERSION) 
    return -EINVAL;
   
  if (hdr.size_in < sizeof(hdr) || (hdr.size_out && hdr.size_out < sizeof(hdr)))
    return -EINVAL;
  
  ...
  
  if (copy_from_user(buf, (void *)arg, hdr.size_in)) {
		ret = -EFAULT;
		goto out;
  }

  ...

  ret = vbg_core_ioctl(session, req, buf);

  ...
}
\end{lstlisting}
% The idea behind double-fetch bugs
\emph{Double-fetch} bugs occur when a privileged environment (such as the
kernel) reads untrusted memory two or more times and the read values aren't
identical. (\autoref{fig:doublefetch}) In between those two reads, memory could
have been changed by an unprivileged adversary. Considering that the bug relies
on carefully timed accesses for two different threads, it is a variant of a race
condition. The situation where the first fetch validates the value of the
fetched variable, but the computation is only performed on the second fetch, is
called a \emph{time-of-check to time-of-use} (TOCTTOU) bug. TOCTTOU bugs have
been widely studied in file systems, where the API makes it possible to swap the
file after validating the access rights~\cite{payer2012protecting,
pu2006methodical, wei2010modeling, tsafrir2008portably}.

\autoref{code:cvedoublefetch} displays the double-fetch bug in the Virtual Box
drivers for the Linux kernel~\cite{cve201812633}. The first fetch occurs on line
10. The program performs gets a header, checks the arguments (lines 13 -- 17)
and fetches the whole argument into the variable \texttt{buf} (line 21). The new
value is then used (line 27).

Note that the header is fetched twice --- on lines 10 and 21. This gives the
opportunity for the attacker to change the values in it. Considering
that the header isn't verified the second time, the attacker can
leave the kernel in an inconsistent state. The fix for this bug
(\autoref{cvedoublefetchfix}) doesn't fetch the header the second time. It
copies the header into \texttt{buf}, while the second fetch skips reading the header
again.

\begin{lstlisting}[language=C, caption=CVE-2018-12633 Double Fetch Fix,
  label=code:cvedoublefetchfix,  breaklines=true
  postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space},
  numbers=left,basicstyle=\scriptsize, firstnumber=18, xleftmargin=5.0ex]
...

  *((struct vbg_ioctl_hdr *)buf) = hdr;
  if (copy_from_user(buf + sizeof(hdr), (void *)arg + sizeof(hdr), hdr.size_in - sizeof(hdr))) {
    ret = -EFAULT;
    goto out;
  }

...

\end{lstlisting}

% Double-fetches are actually so big that people have actualy spent time
% to study them
Wang et al. explain in \cite{wang2018survey} that double-fetches appear not only
in kernels, but wherever there is a trust boundary to cross (e.g., kernel ---
hypervisor~\cite{wilhelm2016xenpwn} and hardware --- kernel
boundaries~\cite{lu2018untrusted}). Double-fetches have been responsible for many
vulnerabilities in different kernels~\cite{jurczyk2013bochspwn, wang2018survey}.


\section{Threat Model}
\label{sec:threatmodel}
% Explain generally how TikTok works. We mention all the problems that
% TikTok needs to mitigate: writes from user-space, writes from the kernel, safely
% stopping the writes, preventing bypass using file-backed pages, system calls
% that are ignored. The most important part is showing the conditions for 
% introducing deadlocks
The adversary has access to a user account on the target machine. They can
execute arbitrary code, including system calls. Some of the system calls
have double-fetch vulnerabilities, and the adversary wants to exploit them,
e.g., for privilege escalation.

The attacker may execute an arbitrary sequence of system calls. \sysname{}
mitigates any unintended corruption that arises through double-fetch bugs.
Hardware attacks such as Rowhammer~\cite{TODO} or side channels~\cite{TODO} are
out of scope.

\section{TOCTTOU Attacks}

\sysname{} needs to protect the arguments from different types of attacks and ways of
bypassing the protections. The following attacks are possible:

\begin{enumerate}
  \item \label{first} \emph{Writes from user-space} consist of the malicious user trying to directly
  write to the argument stored in memory, while the system-call is being executed
  in another thread. 
  \item \label{second} \emph{Writes from the kernel} are indirectly triggered. The user performs a
  \texttt{read} system-call with the target address as the destination. The data
  is then written to this location by the \texttt{read} system-call from the
  kernel.
  \item \label{third} \emph{Remapping file-backed pages} is accomplished by mapping marked pages in
  another process. The malicious user stores the arguments on a file-backed page
  and maps the file again as writable, while the system call is executing. The
  user is then free to write to the new mapping, even though \emph{other mappings}
  are read-only.
  \item \label{fourth} \emph{Writing to file-backed pages using system calls} bypasses
  the protections present in user-space mappings by directly changing the data present in
  the files.
  \item \label{fifth} \emph{The data on a device-backed page} can change
  independently of writes. Storing arguments on such pages can result in reading
  different values from them, even if no writes occur in-between the reads.
\end{enumerate}

Watson~\cite{watson2007exploiting} in his analysis of CerbNG mentioned attacks
\autoref{first}, \autoref{third} and \autoref{fourth}.

\section{\sysname{} Design}
\label{sec:design}

We break the design of \sysname{} into three parts.
\autoref{subsec:mainmechanism} introduces key ideas that are subsequently
illustrated in \autoref{subsec:simplistic}. The design presented in
\autoref{subsec:simplistic} fails to provide adequate protection, so we present
the main design principles in \autoref{subsec:designprinciples}: \emph{Temporary
Immutability} (\autoref{subsec:tempimmut}), \emph{Correctness}
(\autoref{subsec:correctness}) and \emph{Soundness} (\autoref{subsec:soundness}).

\subsection{The Main Protection Mechanism}
\label{subsec:mainmechanism}

\sysname{} leverages virtual memory protections to
prevent changes to arguments during the execution of system calls.
\sysname hardens the following three parts of the kernel:

\begin{itemize}
\item The page-table
\item The page-fault handler
\item The kernel interface for reading from user-space (\texttt{read\_in})
\end{itemize}

The \texttt{read\_in} function reads an argument from the user-space memory and
protects it during the execution of the call. \texttt{read\_in} must protect the
pages in \emph{all} memory spaces mapping the page. Otherwise, an adversary
could alter the argument from a different process. At the end of the call, the
guarded pages are set to the previous state if there are no other calls storing
arguments on them. The process of protecting a page by setting the appropriate
flags is called \emph{marking a page}. \emph{Unmarking} is the opposite process
when the permissions are reset to original values.

If the adversary tries to write to the marked page, they will trigger a
page-fault exception. The page-fault handler will detect that the page is marked
by \sysname{} and force the thread to \emph{wait} until it is unmarked. The
offending write is then repeated. 


\subsection{Simplistic Design}
\label{subsec:simplistic}
 The easiest way to implement the
protection from \autoref{subsec:mainmechanism} is to mark user-space pages as
accessible only from the kernel.  On modern architectures this is accomplished
by setting the \emph{superuser} flag in the page-table. User-space writes to
marked pages trigger a page-fault, where they wait for the system call to end.

Even though a system like this provides the protection from user-space
writes to anonymous pages, it can easily be bypassed by calling a \texttt{read}
system call. \texttt{read} executes in the kernel context and has access to 
the pages marked with the \emph{superuser} flag. The attacker can provide the
address of the marked argument as a destination of a \texttt{read} call and 
change the data. This attack vector on the superuser-flag memory-marking system
is one of the contributions of the paper.

The solution is to mark pages as \emph{read-only} instead of \emph{superuser}.
In that case no system call can change marked memory. Unfortunately, some system
calls (e.g., \texttt{rt\_sigaction}) write to the arguments they read. Such
\emph{self-writing} calls will deadlock. After trying to write to the marked
page, they will wait for themselves to unmark it.
Watson~\cite{watson2007exploiting} mentions self-writing calls as a big problem
for memory-marking systems. A more complex solution is required to address this
problem, and it is another major contribution.
%\mat{Introduce the idea of marking/unmarking first.}

\subsection{Design Principles}
\label{subsec:designprinciples}
\sysname needs to enforce several policies to protect against double-fetches:

\begin{itemize}
  \item \label{policy:immutability} \emph{Temporary Immutability:} Pages storing
  the arguments of a system call must be immutable after being read the first
  time
  \item \label{policy:correctness} \emph{Correctness:} Writes to protected pages
  do not affect the correct execution of threads performing them
  \item \label{policy:soundness} \emph{Soundness:} The only way to change the
  protected pages is by writing to them
\end{itemize}

If these three principles hold, the system will mitigate double-fetch bugs and
the protected programs will execute correctly.

\subsection{Temporary Immutability}
\label{subsec:tempimmut}
\emph{Temporary Immutability} of the pages storing the arguments guarantees that
fetch of the arguments will return the same data as the first one. This mitigates
double-fetch bugs because all reads will return the same value.

As described in \autoref{subsec:mainmechanism} \sysname{} relies on the
page-table and the page-fault handler to provide immutability. The interface for
reading from the user-space (\texttt{read\_in}) is extended to change the
permissions of the pages being read to \emph{read-only}. The pages need to be
marked in all VM spaces. Otherwise, the adversary would be able to write to the
page from a different process.

\sysname{} extends mapping of pages to make sure the guarded pages are marked in
all processes. This protection holds even if they are mapped as writable after
being marked by another process. If the OS supports \emph{on-demand paging} the
marking should happen when the page is accessed and loaded by the process.

Temporary immutability prevents \autoref{attk:direct}, \autoref{attk:systemcall}
and \autoref{attk:remapping}.

\subsection{Correctness}
\label{subsec:corectness}
Self-writing system calls are problematic for memory-marking systems, as noticed
by Watson~\cite{watson2007exploiting} and illustrated in
\autoref{subsec:simplistic}. Some system calls rely on double-fetches and
user-space writes to the arguments to execute correctly. \sysname{} also
introduces additional synchronization points to user-space programs, introducing
a possibility of deadlocks. \sysname must guarantee the correct execution of
these system calls and user-space programs.

\subsubsection{Writes to User-Space}

\emph{Self-writing system calls} are addressed by preventing them from writing
to marked pages and triggering a page-fault. When a page is marked, it is also
added to a data structure containing marked memory memory ranges for each VM
space. We will refer to this data structure as the interval-tree, considering
that interval-trees store ranges efficiently. The interface for writing to
user-space (\texttt{write\_out}) is changed to check if it is writing to a
marked page. Writes to marked pages are saved, and executed at the end of the
call, after unmarking the arguments. This guarantees that system calls will not
wait for themselves to unmark the pages. Considering that
Watson~\cite{watson2007exploiting} stressed that no system call wrappers had
successfully addressed this problem, we consider it \emph{a key contribution of
this paper}.

\subsubsection{Ignored Calls}

\emph{System calls that depend on double-fetches} cannot be protected by
\sysname{}, so they are \emph{ignored} --- they do not mark pages. They should
be manually inspected for bugs. Ignoring them does not diminish the protection
of other calls. Ignored calls still stop before writing to marked pages.

The best representatives are \texttt{pollfd} and \texttt{futex}. \texttt{pollfd}
checks if any of the file-descriptors in the array passed as an argument are
ready to perform I/O. The user can write \texttt{-1} to memory to indicate that
the loop in the call needs to skip the descriptor. \texttt{futex} is a mostly
user-space lock. Most of \texttt{futex} synchronization depends on atomic
user-space writes, with the system-call being performed only to awake or make
threads wait. If \texttt{futex} marks a user-space address as read-only, other
user-space threads will be incapable of unlocking the \texttt{futex} by writing
to that address. Even though they execute correctly under \sysname{}, long
lasting calls (such as \texttt{sys\_nanosleep}) should be included in this
group. Otherwise they could keep the pages marked for long periods of time.

Finally --- if a system call can be verified not to have double-fetches, it can
be ignored to improve performance. This is especially important in case of
system-calls with large arguments such as \texttt{write}.

\subsubsection{Preventing Deadlocks}
\label{subsubsec:deadlocks}

\sysname{} provides its guarantees by introducing additional synchronization
points to executing programs. It does not introduce deadlocks
\begin{enumerate*}\item by interacting with itself \item by interacting with
blocking system calls\end{enumerate*}.

\sysname{} cannot cause a circular locking dependency as a consequence of its
\emph{system call reads, writes and markings}. Every dependency involves one
marked page and a write to it. A self-deadlocking execution trace would involve
a write from a system call to a page marked by another system call. The other
system call would also need to write to the page marked by the first call to
complete the cycle. This situation is impossible in \sysname{} because system
calls postpone writes to marked pages until the end of the call, when the pages
are unmarked.

If a system call interacts with \sysname{} to cause a deadlock, such a call can
be \emph{added to the ignore-list}. However, such calls are extremely rare.
During our evaluation we haven't encountered them. The deadlocking pattern
\autoref{fig:deadlock} requires three ingredients:

\begin{itemize}
  \item A synchronized marking call \texttt{S}
  \item Storing the arguments of \texttt{S} in shared memory \texttt{A}
  \item A thread to write to \texttt{A} while \texttt{S} is executing
  \item An already existing waits-for dependency between the thread executing
  \texttt{S} and a write
\end{itemize}

\begin{figure}
  \centering
  \begin{subfigure}[b]{0.45\linewidth}
  \begin{minipage}{\linewidth}
  \begin{lstlisting}
  1: S(A,T1);  
  \end{lstlisting}
  \end{minipage}
  \caption{Thread 1}
  \end{subfigure}
  \hfill
  \begin{subfigure}[b]{0.45\linewidth}
  \begin{minipage}{\linewidth}
  \begin{lstlisting}
  2: write(A);
  3: unblock_S(T2);
  \end{lstlisting}  
  \end{minipage}
  \caption{Thread 2}
  \end{subfigure}
  \caption{Executing instructions in the specified order causes a deadlock with \sysname}
  \label{fig:deadlock}
\end{figure}

\autoref{fig:deadlock} shows an example of a deadlocking communication pattern.
Thread 1 enters the system call \texttt{S} and marks a shared page \texttt{A}
(\textbf{1}). The system call \texttt{S} blocks until the corresponding call
\texttt{unblock\_S} is called in Thread 2 (\textbf{3}). While the page
\texttt{A} is still marked, Thread 2 attempts to write to it, causing it to wait
for \texttt{S} to finish (\textbf{2}). All of the deadlocking patterns need to
exhibit a similar combination of paired blocking calls (\texttt{S},
\texttt{unblock\_S}) with arguments in the shared memory (page \texttt{A}).

The only candidates for \texttt{S} that the authors have encountered are
blocking message-passing calls. They are synchronous and thus provide the
necessary waits-for dependency, and they read buffers from user-space memory,
marking pages. However, the deadlock would imply that data on the page
\texttt{A} is shared both by message-passing and shared-memory. We haven't
encountered such a pattern and there are a few reasons why it doesn't occur in
practice:

\begin{itemize}
  \item Most programs use only one IPC method (either message-passing or
  shared-memory)
  \item System call arguments are usually stored on the stack, and accessed only
  by the executing thread
  \item The programs would need to use both IPC methods at the same time, on the
  same data
  \item Both system calls and shared-memory are relatively rare in programs, and
  used in the well-defined patterns
\end{itemize}

\sysname{} adds another synchronization point to the kernel
(\autoref{subsec:soundness}) --- it prevents write calls to files having marked
mapped pages. While it is possible to deadlock a thread by mapping a file, and
then pass the mapped pages as the arguments to the write call to the same file,
we have not encountered such a program.

\subsection{Soundness}
\label{subsec:soundness}

\sysname{} stops all writes to marked pages to prevent changes to the arguments.
It is necessary to close off all other ways of changing data on marked pages to
show \sysname{} is \emph{sound}. We identify and disable two other ways of
changing pages --- write system calls and device-backed pages.

Watson~\cite{watson2007exploiting} mentions that file-systems with shared
\emph{mapped memory} and \emph{write buffers} could bypass the memory-marking
protection in a \texttt{write} call. To prevent such an attack \sysname pauses
all writes (\texttt{vfs\_write}) to files having marked mapped pages. If the
file-system code can be verified to be immune to the attack, this protection can
be disabled.

\emph{Discretionary Access Control} (DAC) can be used to prevent mounting of
devices to user-controlled processes. Device-backed pages may have a state
independent of user actions, and even the kernel, making any form of preventing
data changes impossible. We do not consider this a flaw in \sysname{} because
users usually are not allowed to access devices directly.

With these two changes \autoref{attk:writebuffers} and \autoref{attk:devicefiles}
are prevented.


\section{Implementation}
\label{sec:implementation}

\sysname{} prototype has been implemented on Linux x86-64. However, \sysname{} can be
ported to any operating system that use a defined interface for reads and
writes to the user-space (\texttt{read\_in} and \texttt{write\_out}), and any
architecture that has page-tables encoding access control information. Depending
on the available resources (e.g. the number of free bits in the PTE) information
can be stored in different places (e.g., PTE or global structures).

\subsection{Basic Book-keeping}
\autoref{fig:bookkeeping} illustrates some of the most important data structures
used in the prototype --- the PTE with the permissions, the marked page metadata
(number of threads marking the page frame, number of threads waiting for the
unmarking, the reverse mapping information). 

\autoref{subsec:frameinfo} describes the data about the physical page frame with
some of the limitations due to the need to keep \texttt{struct page} as small as
possible. Considering that one \texttt{struct page} exists for every page frame
on the system, increasing its size would drastically increase the memory
overhead.  The data stored in the page table (permissions, free bits and page
frame number) is explained in more detail in \autoref{subsec:pageinfo}.

\subsection{Storing the Page Frame Information}
\label{subsec:frameinfo}
Linux divides physical memory into page frames. Each page frame is represented
by a \texttt{struct page}. This structure is replicated millions of times and
every additional field has a tremendous impact on the memory consumption.

To keep the memory consumption low, \sysname{} uses a single bit in \texttt{struct
page} to mark page frames. x86-64 has enough bits in the flag
field, so we have decided to use one of the flag bits for this purpose.
Architectures that have fewer flag bits (such as x86) can instead use some of
the bits used by other features (e.g., Kernel Shared Memory or NUMA domains). On
\autoref{fig:bookkeeping} this field is denoted by \emph{Page Marked Flag}.
\texttt{struct page} also stores a pointer to the \emph{reverse mapping}
information. The reverse mapping is used to find all PTEs \sysname{} needs to
(un)mark.

The marking metadata is stored in a hashmap based on the \emph{page frame
number}. This enables us to store only the information on the pages which are
currently marked and keep the memory consumption low. The access to these entries
is protected by separate mutexes to improve the scalability of the system. The
metadata consists of the page frame number, the count of threads marking the page
(\emph{owners}), the number of threads waiting for the page to get unmarked
(\emph{guests}), and a \emph{completion} they are waiting on. 

\subsection{PTE Information}
\label{subsec:pageinfo}

When a page is marked, \sysname{} changes some of the flags in the PTEs mapping it
(\autoref{fig:bookkeeping}):

\begin{LaTeXdescription}
  \item[R/W] gets set to \emph{read-only} to prevent writes to the page
  \item[SW2] gets the old value of \textbf{R/W}
  \item[SW3] gets set to 1 
\end{LaTeXdescription}

\textbf{SW2} is used by the Software Dirty Pages
feature of Linux. This feature cannot run alongside \sysname{} in our prototype.
Other architectures may have less, or more bits, available for the OS to use. In
the case of lack of space in the page table, \texttt{SW2} and \texttt{SW3} could
be stored in a separate data structure.

\emph{Copy-on-write} pages have a peculiar optimization. They are marked only in
the process requesting the marking. Writes from other processes will trigger a
copy-on-write mechanism, preventing them from changing the data.

\sysname{} does a partial flush of the TLB and updates the MMU cache to make these
changes visible immediately. The performance impact of this is analyzed further
in \autoref{sec:evaluation}.

\begin{figure}[]
  \centering
  \includegraphics[width=\linewidth]{img/book-keeping.pdf}
  \caption{The most important marking information on x86}
  \label{fig:bookkeeping}
\end{figure}

\subsection{Marking and Unmarking}

\begin{figure}[]
  \centering
  \includegraphics[width = 0.8\linewidth]{img/copy_from_user.png}
  \caption{\texttt{copy\_from\_user} page marking}
  \label{fig:copyfromuser}
\end{figure}

\sysname{} extends Linux's interface for reading and writing to user-space. The
abstractions \texttt{read\_in} and \texttt{write\_out} introduced in
\autoref{sec:design} are implemented in Linux as \texttt{copy\_from\_user} and
\texttt{copy\_to\_user}. \sysname{} extends \texttt{copy\_to\_user} to mark the pages
before reading the data (\autoref{fig:copyfromuser}).

Marking the page involves taking the appropriate locks, denoting the physical
page frame as marked, and incrementing the number of page owners. \sysname{} then
uses the reverse mapping information to mark the page in all the VM spaces
mapping it.

Unmarking follows a similar procedure. The appropriate locks are taken, and the
number of owners is decremented. Only if there are no owners marking the page
anymore, it is unmarked in all VM spaces. If there are threads waiting on the
page, they are signaled. The last guest to wake-up will deallocate the marking
data for the page.

\subsection{Deadlock Prevention Mechanism}

The implementation of \sysname{} requires many data structures to be shared
among multiple threads (pages, completions, page-tables, interval-trees \ldots).
To prevent deadlocks all locks are taken in the same order in all places they
are used. The only two locks taken in the opposite order are the
\emph{page-table lock} and the \emph{interval-tree lock}.

In \texttt{copy\_to\_user}~\autoref{fig:copytouser} the interval-tree lock must
be taken first to check which memory ranges are marked. However, when marking a
page the page-table lock needs to be acquired first to locate the page-table
entry mapping the page~\autoref{fig:copyfromuser}. \sysname{} implements the
deadlock resolution mechanism where if the page-fault handler notices that the
interval-tree lock is already taken, it gets released.

The prevention mechanism leads to the a way for system calls to write and block
on marked pages. Ultimately, it cannot cause a deadlock. The thread executing
\texttt{copy\_to\_user}~\autoref{fig:copytouser} writes to a page that is not
present, and releases the interval-tree lock. Right after loading the page,
another thread executes \texttt{copy\_from\_user}~\autoref{fig:copyfromuser} and
marks it. The first thread is forced to re-execute the write by the the
page-fault handler. Here, the first thread is executing \texttt{copy\_to\_user}.
For the deadlock to occur it needs to execute \texttt{copy\_from\_user} in the
same manner as the second thread. Fortunately, the \texttt{copy\_to\_user}
thread is waiting for the unmarking, preventing it from executing
\texttt{copy\_from\_user} and creating a second wait dependency.

\subsection{Loading File-Backed Pages}

As described in \autoref{sec:design}, file-backed pages need to be marked as
they are loaded to memory. On-demand paging takes place in the page-fault
handler, but invokes the functions of the file-system storing the file. \sysname{}
extends the functionality of \texttt{set\_alloc\_pte} to mark the page. The
needed structures are preallocated, and passed into the \emph{atomic context} where 
\texttt{set\_alloc\_pte} is called.

When a marked page is loaded, its data is also added to the interval-tree.
\sysname{} takes the lock before entering the atomic context, even though the
loaded page may not be marked. The version number of the interval-tree is
incremented after adding the page, informing all other threads that it has
changed.

\subsection{Tracking Marked Ranges}

\begin{figure}[]
  \centering
  \includegraphics[width = 0.8\linewidth]{img/pagefault.png}
  \caption{\sysname's handling of the writes in the page-fault handler}
  \label{fig:pagefault}
\end{figure}

\subsection{Protecting System Call Arguments from Writes by the Kernel}
\label{subsec:kernelland}
\begin{figure}[]
  \centering
  \includegraphics[width = 0.8\linewidth]{img/copy_to_user.png}
  \caption{\texttt{copy\_to\_user} write handling}
  \label{fig:copytouser}
\end{figure}

\sysname{} stores the marked memory ranges for every VM space
(\texttt{mm\_struct}) in an interval tree. Before writing to the user-space,
\texttt{copy\_to\_user} (\autoref{fig:copytouser}) the lock for the marked
memory ranges tree and checks for the intersections with the destination buffer.
Writes to marked pages are stored to freshly allocated memory, along with the
destination address, and written at the end of the call.

Writes to unmarked pages proceed as normal, unless the page is not present, when
a page-fault exception happens (\autoref{fig:copytouser}). The page-fault
handler takes the page-table lock, loads the page and restarts the write. If the
page-fault handler detects a potential deadlock, it will release the
interval-tree lock. Page-table read-lock is not exclusive, so it does not need
to be released (\autoref{fig:pagefault}).

\texttt{copy\_to\_user} will attempt to write to the page after exiting the
page-fault handler. In the case it is indeed marked, it will block and wait for
its unmarking. This is the only case where \sysname{} forces threads to wait in
the middle of a system call. After the write, the thread reacquires the lock,
checks if the interval tree has changed and restarts the write if so.

The restart of the write is necessary because any change to the interval-tree
invalidates the iterator. \sysname{} is optimized for the case of rare markings,
making \texttt{copy\_to\_user} calls which do not encounter marked pages fast
--- only one, large write occurs. The alternative is to check and write to every
page individually. Such implementation does not need to restart the write, but
incurs the overhead of writing to pages individually.

\section{Evaluation}
\label{sec:evaluation}

\sysname{} has been evaluated on different benchmarks to measure the drop in performance.
The three main profiles have been compared:
\begin{LaTeXdescription}
  \item[\sysname{} On] protects as many system calls as possible
  \item[\sysname{} Partial] does not protect the arguments of \texttt{write} and its variants
  \item[\sysname{} Off] is the Linux kernel compiled without \sysname{}  
\end{LaTeXdescription}

\mat{Specify which parts you want to evaluate. Specify on what machines you
evaluate. Specify why you want to evaluate these parts and what they show.}

\subsection{NAS Parallel Benchmark}
\label{subsec:npb}

\emph{NAS Parallel Benchmarks (NPB)} is a benchmark introduced by NASA. It
consists of several parallel programs using different communication patterns.
\sysname{} introduces additional synchronization points between threads, so it
should affect multi-threaded programs more than single-threaded ones. NPB is
available for multiple technology stacks for parallel programming. \sysname{}
was evaluated on \emph{OpenMP} and \emph{MPI} versions of the benchmark
with workloads of class A.

\begin{figure}[]
  \centering
  \includegraphics[width=\linewidth]{graphs/omp.png}
  \caption{\sysname{} evaluated on NPB with OMP}
  \label{fig:npbomp}
\end{figure}

\begin{figure}[]
  \centering
  \includegraphics[width=\linewidth]{graphs/mpi.png}
  \caption{\sysname{} evaluated on NPB with MPI}
  \label{fig:npbmpi}
\end{figure}

OpenMP is a compiler extension that with minimal effort parallelizes the software
by using multiple threads. All the threads still use the same VM space, keeping
the overhead minimal. \sysname{} was evaluated with 8 threads.

MPI implements parallel execution by launching multiple processes which communicate
by message-passing. It is more heavyweight than OpenMP as every process has a
separate VM space. Due to the limitations of some benchmarks, \sysname{} was 
evaluated with 16 processes.

The benchmarks have been run with \sysname{} protecting almost all calls, with
\texttt{write} disabled and without \sysname{} at all (\autoref{fig:npbomp} and
\autoref{fig:npbmpi}). Both benchmarks show no significant difference between
different setups. MPI however has wider standard-error margins, probably
introduced by the heavier startup and communication. Shorter benchmarks magnify
relative differences (explaining the artifacts for \texttt{is} and \texttt{ep}).
\sysname{} doesn't incur a noticeable performance
penalty for CPU-bound workloads, even when they involve multiple
threads/processes.

\subsection{Phoronix Test Suite}
\label{subsec:phoronix}

\begin{figure*}[]
  \centering
  \includegraphics[width=\linewidth]{graphs/phoronix.png}
  \caption{\sysname{} evaluation on Phoronix Test Suite}
  \label{fig:phoronix}
\end{figure*}

\emph{Phoronix Test Suites (PTS)} evaluates systems on real-world software. We
ran \sysname{} on it to judge the actual performance impact during the
everyday use.

\autoref{fig:phoronix} shows the results of the Phoronix benchmark. All
results have been normalized to with \sysname{} off as a baseline. Benchmarks
marked with an asterisk (*) measure execution time (lower is better), while others
measure performance (higher is better).

Linux compilation, OpenSSL, Redis, Git and PyBench do not show a noticable
degradation of performance. These programs don't feature a lot of inter-process
communication. Even the parallelized benchmarks such as Linux kernel compilation
generate independent processes.

However, the two web servers (Apache and NginX) show a significant drop in
performance (Apache -- 16.87\% and NGINX -- 16.38\%) with \sysname{} protecting
all calls. \sysname by design affects parallel applications the most (by
introducing forced synchronization on accesses and featuring more PTEs to mark)
and software with numerous system calls (by marking all the arguments stored
in-memory). Ignoring write calls improves the situation slightly (Apache --
15.64\% and NGINX -- 13.41\%).

The IPC TCP benchmark consists only of executing 2 system calls to transfer
the data between two threads. Compared to other benchmarks IPC benchmark has fewer
threads than web-servers, but also executes a significant number of system calls.
This places it in-between two groups with respect to the drop in performance.

\begin{figure}[]
  \centering
  \includegraphics[width=\linewidth]{graphs/apache-nginx-5.png}
  \caption{Detailed comparison of Apache and NginX performance}
  \label{fig:phoronix-apache-nginx}
\end{figure}

Apache and NginX benchmarks have been executed under two more \sysname{}
profiles to see how reducing the number of protected system calls affects
performance (\autoref{fig:phoronix-apache-nginx}):

\begin{LaTeXdescription}
  \item[Frequent system calls ignored] ignores the most frequent calls executed in the benchmarks, as well as \texttt{write}.
  \item[All system calls ignored] does not protect any system calls.
\end{LaTeXdescription}

Ignoring frequent system calls leads to a smaller overhead (Apache -- 5.34\% and
NginX -- 2.77\%). The performance is almost equal to not protecting any system
calls at all (Apache -- 2.46\% and NginX -- 2.25\%). Even when \sysname
is not providing any protection, the overhead of \texttt{copy\_to\_user} checks
is present.

\uros{I will need to obtain new numbers from perf. The last run did not have the
permissions to decode the kernel symbols. I expect the same results.}

\begin{table*}[]
  \label{table:perf}
  \centering
  \begin{tabular}{|l|l|l|l|l|}
  \hline
                                 & Apache & Apache (\sysname{} - No writes) & IPC & IPC (\sysname{} - No writes)\\ \hline
  Marking pages read-only        & 0\%    & 4.33\%          & 0\% & 0\%         \\ \hline
  Unmarking pages                & 0\%    & 3.83\%          & 0\% & 0.98\%      \\ \hline
  Flushing Individual TLB Ranges & 1.50\% & 5.72\%          & 0\% & 0\%         \\ \hline
  Write Bypass Protection        & 0\%    & 0\%             & 0\% & 1.47\%      \\ \hline
  Read Bypass Protection         & 0\%    & 0\%             & 0\% & 1.15\%      \\ \hline
  Total Overhead                 & 0\%    & 13.59\%         & 0\% & 4.29\%      \\ \hline
  \end{tabular}
  \caption{Perf Analysis of the Benchmarks}
\end{table*}

Analyzing Apache and IPC benchmark executions with \texttt{perf} it was possible
to determine which functions were executing slower with \sysname{}.
\autoref{table:perf} shows how much time the programs spend in the functions
added by \sysname. Percentages of individual segments have been measured by
\texttt{perf}, while the total overhead is calculated from the results of the
benchmark. Furthermore, TLB is flushed both during the marking and unmarking of
pages.

The comparison of the Apache and IPC runs shows two very different marking
profiles. Apache spends a considerable amount of time marking and unmarking
pages, while IPC does not mark pages at all. This is a consequence of the
different system-calls used by these applications. IPC uses only \texttt{read}
and \texttt{write} calls which do not mark arguments, while Apache also invokes
system-calls which mark arguments (\texttt{accept}, \texttt{getsockname}).
Consequentially, Apache spends a lot of time marking and unmarking pages.

In these two segments Apache actually waits most of the time for the TLB
signaling functions to execute. \texttt{flush\_tlb\_mm\_range} amounts for
2.51\% (marking) and 2.10\% (unmarking) of the total time spent executing the
benchmark. Frequent TLB flushes are expensive because the CPU needs to make sure
that all the cores have processed the signal before continuing. Unfortunately,
this is only a part of the overhead incurred by flushing the TLB. Flushed pages
will be accessed right afterward leading to a TLB miss, further inflating the
overhead.

IPC benchmark executes only \texttt{write} and \texttt{read} calls. It doesn't
incur any overhead on TLB flushes because none of these calls mark pages.
However, \texttt{copy\_to\_user} checks are still active, leading to a
significant locking overhead. Without TLB flushes it is interesting to notice
that the overhead of individual components roughly adds up to the total overhead
in the IPC benchmark.


% In this section we need to convince the reader in two things:
% 1) Alternative filtering approaches to system call filters are incomplete and
% cumbersome
% 2) The best way to solve the TOCTTOU bug in filters is TikTok. All other
% methods can only fix other double-fetches, or they force you to use TSX
\section{Related Work}
\label{sec:relatedwork}

The literature related to double-fetches can be broadly divided into two groups.
In the first group are the static solutions (\autoref{subsec:dfstatic}) that use
techniques such as source or binary analysis to detect double-fetch bugs. The
second group (\autoref{subsec:dfdynamic}) uses run-time information to detect
and (rarely) prevent double-fetches.

The most important work related to \sysname{} is the paper by
Watson~\cite{watson2007exploiting} criticizing the security of system call
wrappers (\autoref{subsec:watson}). The implications of \sysname{} for system
call wrappers are discussed in \autoref{sec:furtherwork}.

\subsection{Watson's Critique of System Call Wrappers}
\label{subsec:watson}
Watson's paper~\cite{watson2007exploiting} scrutinized the security of many
system call wrappers. Not only did he find that all of them were insecure,
Watson also described the different types of TOCTTOU bugs that compromised them
and discussed potential fixes. In a short paragraph, he mentions that Pawel
Dawidek, the creator of CerbNG~\cite{zak_frasunek_dawidek}, has experimented
with marking arguments read-only. CerbNG was an early system call filtering
system for BSD that used copy-on-read-and-write to a new memory page.

Afterward, Watson briefly discusses problems such memory marking systems
need to solve: 
\begin{itemize}
    \item unnecessary page-faults
    \item bypassing memory marking using IO system calls
    \item mapping shared memory with different permissions
    \item handling system calls that both read and write to the same memory
\end{itemize}

According to Watson, no memory-marking system (including CerbNG) addressed all
of these problems. \sysname{} does exactly that. Unnecessary page-faults are
rare and they are used to make the offending threads wait for unmarking. After
the page has been unmarked, the write proceeds without any consequences. Write
system-call does not proceed until there are no marked pages of the file.Pages
are marked when they are mapped if needed. \sysname{} postpones all writes to
marked pages coming from the kernel while allowing the system calls to execute
correctly.

\subsection{Static Analysis Work}
\label{subsec:dfstatic}
Static analysis techniques analyze the source code to find double-fetch bugs.
Wang et al.~\cite{wang2017double} used pattern matching to find potential
double-fetches. They implemented a tool that patches certain double-fetches
automatically. However, their method in the general case produces false
positives that need to be inspected manually. Xu et al.~\cite{xu2018precise}
improved on this work by proposing Deadline. Deadline does not use the pattern 
analysis on the source files to detect double-fetches, but a compiler's
intermediate representation and constraint solving to eliminate false positives.

Static analysis techniques such as these have the benefit of being able to find
bugs in the code that cannot be run (e.g., missing hardware to test the
drivers). However, they are meant for bug detection, not mitigation. Even though
the tools can fix some bugs automatically, this is not always possible. The
TOCTTOU bug is in the system call wrappers by design. Double-fetches not visible
in the source, nor in the intermediate representation are another problem.
Compilers can introduce such invisible double-fetches when allocating registers
to variables. \sysname{} works even in such cases.


\subsection{Dynamic Analysis Work}
\label{subsec:dfdynamic}
Google Project Zero's Bochspwn~\cite{jurczyk2013bochspwn} uses an emulator to
detect double-fetches. It found a large number of bugs in the Windows kernel.
Bochspwn works on binaries. It does not require access to the source code and it
detects bugs introduced by compilers. DFTracker~\cite{wang2019dftracker} is
another dynamic analysis technique work with a lower overhead, that relies on
taint tracking. However, these dynamic techniques are limited to the detection
of double-fetches. Similar to work presented in \autoref{subsec:dfstatic},
developers need to manually fix the bugs. However, with dynamic analysis a
double-fetch must also be executed, limiting this technique to the core kernel
and to the drivers with the available hardware.

A big leap in dynamic analysis techniques has been presented by Schwartz et
al.~\cite{schwarz2018automated}. The first part of the paper introduces DECAF
--- a framework that uses side-channel attacks to create a fuzzing oracle for
double-fetch bugs. While Bochspwn relies on emulation, slowing the execution
significantly, DECAF runs natively. It also eliminates false positives by
automatically exploiting found bugs.

Schwartz et al. then discuss a real-time mitigation technique for double fetches
--- DropIt. DropIt uses Intel's \emph{Transactional Synchronization Extensions}
(TSX)~\cite{intel64and} in a creative way to prevent double-fetch bugs. By
encapsulating the code in a TSX transaction, writes from other threads will
result in the transaction being aborted. However, the code executing inside a
TSX transaction is severely limited. All reads must fit in the L3 cache, and all
writes in L1. Some instructions are also forbidden. \sysname{} has none of those
limitations. It works on non-Intel processors and relies on page tables for
protection --- a technique that has been present for several decades.

\section{Future Work}
\label{sec:furtherwork}
\mat{This can be part of the discussion section.}
Integration with an existing system-call wrapper would lead to the improved
flexibility and performance of \sysname. SecComp~\cite{seccomp} and
eBPF~\cite{ebpf} are the obvious candidates that would benefit from such an
extension. A possible optimization would be to mark only the pages accessed by
the filter, and not the system-call body. It would also be beneficial to
investigate possible batching of TLB flushes, considering how much they
contribute to the execution overhead.

\section{Conclusion}

\sysname{} mitigates double-fetch bugs in system-calls by using page-tables. It
works both on the core kernel, and drivers, even when their source code is not
available. It can be ported to any architecture that uses page-tables, and any
kernel that has a well-defined interface to access user-space memory. \sysname
is tested in practice on a modern system (Linux Server 18.04 LTS) with complex
programs running (\texttt{systemd}, \texttt{gcc}, \texttt{Apache} \ldots). When
protecting rare system calls it shows an overhead of 2-4\%, which raises to
~20\% when protecting almost all calls in multithreaded, system-call intensive
programs. CPU-bound programs do not have a significant overhead, even if they
use multiple threads.
%-------------------------------------------------------------------------------
%\section*{Acknowledgments}
%-------------------------------------------------------------------------------

%-------------------------------------------------------------------------------
\section*{Availability}
%-------------------------------------------------------------------------------

The source code of TikTok is available at LINK. It has been released under the
GNU Public Licence.

%-------------------------------------------------------------------------------
\bibliographystyle{plain}
\bibliography{\jobname}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%  LocalWords:  endnotes includegraphics fread ptr nobj noindent
%%  LocalWords:  pdflatex acks
