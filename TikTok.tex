\documentclass[letterpaper,twocolumn,10pt, anonymous]{article}
\usepackage{usenix2019_v3}

\usepackage{amsmath}
\usepackage{filecontents}
\usepackage{tikz}
\usepackage{xspace}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{textcomp}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{todonotes}
\usepackage{multirow}
\usepackage{booktabs}
\usepackage{paralist}
\usepackage{enumitem}
\usepackage{tabulary}
\usepackage{prettyref}
\usepackage{verbatim}
\usepackage{balance}
\usepackage{tabularx}

%-------------------------------------------------------------------------------
\begin{document}
%-------------------------------------------------------------------------------


\lstdefinestyle{cstyle}{
  basicstyle=\footnotesize\ttfamily,
  keywordstyle=\color{black!85}\bfseries,
  keywordstyle=[2]\color{black!85}\bfseries\emph,
  showstringspaces=false,
  language={C},
  breaklines=false,
  mathescape=true,
  escapechar={@}
}
\lstdefinestyle{inline}{
  style=cstyle,
  mathescape=false,
  breaklines=true,
  keywordstyle=,           
  keywordstyle=[2],
  extendedchars=true,
  basicstyle=\ttfamily\small
}
\newcommand{\Code}[1]{\lstinline[style=inline,breaklines=false]@#1@}
\let\realparagraph\paragraph
\let\paragraph\relax
\newcommand{\paragraph}[1]{\textbf{#1.}}
\newcolumntype{Q}{>{\centering\arraybackslash}X}

\newcommand\tocttou[0]{ToCtToU\xspace}
\newcommand\tiktok[0]{TikTok\xspace}

\newrefformat{cha}{\hyperref[#1]{Chapter~\ref*{#1}}}
\newrefformat{sec}{\hyperref[#1]{Section~\ref*{#1}}}
\newrefformat{sub}{\hyperref[#1]{Section~\ref*{#1}}}
\newrefformat{tab}{\hyperref[#1]{Table~\ref*{#1}}}
\newrefformat{fig}{\hyperref[#1]{Figure~\ref*{#1}}}
\newrefformat{line}{\hyperref[#1]{line~\ref*{#1}}}
\newrefformat{lst}{\hyperref[#1]{Listing~\ref*{#1}}}
\newrefformat{pat}{\hyperref[#1]{Patch~\ref*{#1}}}
\newrefformat{alg}{\hyperref[#1]{Algorithm~\ref*{#1}}}

\newcommand\TODO[1]{\noindent{\color{green} {\bf \fbox{TODO}} {\it#1}}}

%don't want date printed
\date{}

% make title bold and 14 pt font (Latex default is non-bold, 16 pt)
\title{\Large \bf Kernel TOCTTOU Protection}

%for single author (just remove % characters)
\author{
{\rm Anonymous}\\
Your Institution
% copy the following lines to add more authors
% \and
% {\rm Name}\\
%Name Institution
} % end author

\maketitle

%-------------------------------------------------------------------------------
\begin{abstract}
%-------------------------------------------------------------------------------
Your abstract text goes here. Just a few facts. Whet our appetites.
Not more than 200 words, if possible, and preferably closer to 150.
\end{abstract}

\section{Design}

\tiktok maintains \emph{a single core invariant}:
\textbf{\emph{Through a syscall's lifetime, every read to a userspace object 
will return the same value}}.
By construction, the invariant guarantees that double-fetches in syscall
code will read the same data, \emph{eliminating \tocttou bugs}.
\tiktok maintains the invariant by tracking \emph{snaphots} of the data
when first accessed, lazily making \emph{copies} when the data is concurrently 
written and accessing the correct copy on subsequent reads.
Copies are only maintained during the syscall's lifetime, and are released as 
soon as no syscall needs it.
%Consequently, each page has a single copy while no syscalls are running.
\mat{Ambiguous: one single version? 'One copy' could mean there are two pages.
Also, you're introducing page granularity here.}
Consequently, each userspace object exists only once when no syscalls are
running.

\tiktok's implementation builds on the protection mechanisms provided by 
existing virtual memory implementations.
On modern platforms, virtual memory protection is set up by the OS at
page-granularity by setting bits in pagetable entries.
\mat{I'd call it pagetable, not page-table.}
These permission bits are checked by the hardware on memory access, 
efficiently enforcing that the permissions are respected, or raising 
a fault when they are not.
Therefore, \tiktok implements its invariant at a page-granularity, not object 
granularity: when a syscall reads from userspace, every page touched by that 
read are covered by the invariant, not merely the bytes read.
As a side-effect of this implementation, \tiktok cannot differentiate between
accesses to different parts of a page, and incurs overhead on false sharing
within a page.
\mat{Argue that this results only in performance overhead but not in loss of
correctness or completeness.}

For an object spanning multiple pages, \tiktok's design sequentially 
protects each page before reading from it, and does not introduce 
new vulnerabilities.
The leading pages containing the object are protected before the
later pages, allowing an attacker to potentially modify the later 
pages before the syscall first reads them.
However, the attacker is prevented from modifying any of these earlier pages
after the syscall's first read, ensuring that double-fetches respect
the invariant.
\mat{Argue that this is a 'wavefront' style of mitigation.}
If the syscall code contains a \tocttou bug, the modification will
be visible to the first fetch itself (which is used for checking for 
validity of the data) and will lead to the data being rejected 
straightaway.

\mat{Argue that this is performance only, otherwise you could simply stop all
other threads whenever a syscall is handled.}
A major performance goal for \tiktok is to allow concurrent access to pages
by user/kernel code running concurrently to a syscall which reads from 
the same pages.
To ensure that writes to pages do not violate the invariant, \tiktok
must maintain multiple copies of a page.
Particularly, for each syscall which has accessed a page, \tiktok
must maintain a snapshot of its contents from when the page was first 
read by the syscall.
A separate copy of the page will be used for concurrent reads and writes,
updating the page as seen from userspace.
When multiple syscalls read from the same page, and there are no writes
to the page between the times when each first accessed the page, 
the snapshots of the page for these syscalls may correspond to a 
single copy.

\subsection{Page state machine}

\begin{figure*}[]
  \includegraphics[width=\linewidth]{img/tiktok_states.pdf}
  \caption{State diagram for a page in \tiktok}
  \label{fig:tiktok_states}
\end{figure*}

To track multiple versions of the contents of a page when being concurrently 
accessed by numerous threads, from userspace or during a syscall,
\tiktok implicitly maintains a per-page state machine.
For each page, its corresponding state machine tracks snapshots for currently 
executing syscalls which have read it, copies of the page, and the mapping 
between the two necessary for providing the correct contents to subsequent reads 
by these syscalls.

\autoref{fig:tiktok_states} shows the state machine for a single page.
At every state, the page has two associated sets:
\begin{inparaenum}[\itshape i\upshape)]
  \item the copies set $C = \{C_L, C_0, \dots\}$ holds multiple copies of the page over time, and
  \item the snapshots set $S = \{L, S_0, S_1, \dots\}$ tracks logical versions of the page, each corresponding to one executing syscall and mapping to a copy. 
\end{inparaenum}
\mat{Why do we need snapshots and copies? One should suffice.}
Reads from kernel code in a syscall use the copy corresponding to its snapshot.
Writes from user/kernel code and reads from userspace access the latest 
copy, which is mapped in process' address spaces.
\TODO{Should I formally define this mapping?}
All other copies are read-only (no matter what the original page protection is), and are used for providing snapshots to syscalls.
In the following paragraphs, we describe how the state machine for a single page 
transitions between its states, what triggers each transition, and what 
changes are made to the copies and snapshot sets on a transition.

\paragraph{State 0}
\mat{Todo: come up with better name for states.}
A page starts as \texttt{(writable, unduplicated)}.
At this stage, there is a single writable \mat{not necessarily writable but a
page with original permissions?} copy $C_L$ and a single snapshot $L$. 
All processes where this page is mapped have unrestricted userspace read and write 
access, and unrestricted kernel write access.
The remaining operation, a read from kernel code, triggers a transition to 
the next state.

\paragraph{State 1}
The page in State 0 transitions to the \texttt{(read-only, unduplicated)} state as soon as a syscall 
reads from it.
\tiktok first marks the page's latest copy $C_L$ read-only in all processes, 
restricting \mat{trapping?} writes to it but allowing concurrent reads to continue.
A new snapshot, $S_0$ linked to this syscall is allocated for this page.
For the rest of its lifetime, this syscall will only read from this snapshot.
Both snaphots $S_0$ and $L$ refer to the same copy $C_L$ (shown by the 
blue cross-thatch in \autoref{fig:tiktok_states}).
Prior to any writes to this page, any other syscalls which also read the page  
get their own snapshots (e.g., $S_1$) all pointing to the single copy $C_L$.
The page's read-only status causes the hardware to fault on any write,
notifying \tiktok to transition the page to the next state.

\paragraph{State 2}
A page in State 1 transitions to \texttt{(unmarked, duplicated)} on any write.
\tiktok duplicates the latest copy $C_L$, creating a new copy $C_0$ holding
the pre-write contents of the page.
\tiktok moves all snapshots ($S_0$ and $S_1$) previously pointing to 
$C_L$ to now point to the new copy $C_0$ (shown by green shading in 
\autoref{fig:tiktok_states}). 
Thereafter, the latest copy $C_L$ is made writable, and the triggering write
executes. 
Note how, at this state, any reads using the snapshots $S_0$ or $S_1$ reads 
from the unmodified copy $C_0$ while writes directly affect $C_L$.
Certain syscalls such as \Code{rt_sigaction} both read and write from 
the same user page. 
A write by \Code{rt_sigaction} to the page it has previously read will update
the page's latest copy $C_L$, but not the duplicate copy $C_0$.
\mat{What happens if a later syscall writes to $S_1$ that has already been split
off? I.e., how are conflicts resolved? Also, is there a total order of pages?}

\paragraph{State 3}
A separate syscall subsequently reading the page in State 2 transitions 
it to \texttt{(read-only, duplicated)} state. 
The new snapshot, $S_2$, points to the latest copy $C_L$.
On a write, the page will be duplicated and this snapshot 
will point to the new copy (similar to that in state 2).

\paragraph{Releasing snapshots}
\tiktok uses snapshots to enable a syscall to read the same data from a page 
during its lifetime and releases snapshots when syscalls complete. 
When a snapshot is released, \tiktok may also release its mapped copy.
For a snapshot mapped to the latest copy $C_L$, \tiktok cannot free the copy
since userspace is using it.
In this case, the page is in states 1 or 3, and $C_L$ is read-only.
If no remaining snapshot is mapped to $C_L$, \tiktok makes the 
page writable, moving to states 0 or 2 from states 1 or 3 respectively. 
Any other duplicate $C_i$, \tiktok frees the copy along with the 
last snapshot which mapped to $C_i$.
If the page was in state 2, $C_L$ was writable and unmapped by any snapshot,
so \tiktok changes the page to state 0.
If the page was in state 3, $C_L$ was read-only and mapped by some other
snapshot, so \tiktok moves the page to state 1.

\mat{What about concurrent writes from different syscalls to pages in different
states? What about conflict resolution?}

\subsection{Discussion}

\begin{table}
\begin{center}
\begin{tabularx}{\columnwidth} { | l | X |}
\hline
System Call & Exemption reason \\
\hline
\hline
\Code{futex} & Relies on concurrent write \\ \cline{1-2}
\Code{poll} & Relies on concurrent write \\ \cline{1-2}
\Code{ppoll} & Relies on concurrent write \\ \cline{1-2}
\Code{select} & Relies on concurrent write \\ \cline{1-2}
\Code{pselect6} & Relies on concurrent write \\ \cline{1-2}
\Code{rt\_sigtimedwait} & Relies on concurrent write \\ \cline{1-2}
\Code{execve} & Remaps address space \\ \cline{1-2}
\end{tabularx}
\end{center}
\caption{System calls uninstrumented by \tiktok}
\label{tab:except_syscall}
\end{table}
\paragraph{Exceptions}
Certain syscalls such as \Code{futex} rely on user data changing between 
double fetches to implement their functionality and cannot be protected by
\tiktok.
Such syscalls are listed in \autoref{tab:except_syscall}.
The \Code{futex} syscall implements a fast synchronization mechanism
for userspace and relies on atomic writes from concurrent userspace
thread to update a condition the syscall is waiting for. 
Subjecting a \Code{futex} syscall to \tiktok's invariant will prevent
it from ever waking up the waiting thread.
Such syscalls cannot be protected by \tiktok, and we implement an 
exception list to prevent transitions in the state machines of pages read 
by these syscalls.
The code for these syscalls must be manually inspected for double-fetch 
vulnerabilities.
Crucially, exempting these syscalls from \tiktok's protection does not 
affect the security of other syscalls. 
Any writes from these syscalls are subject to the same rules described
in the state machine, and cannot break \tiktok's invariant.

\paragraph{Preventing deadlocks by design}
\tiktok's design is free of deadlocks, and exempts syscalls which 
require violation of its invariant from triggering particular 
state-machine transitions.
Userspace reads always succeed, using the latest copy $C_L$ of the
accessed page.
Writes from userspace and kernel code succeed directly if the 
page is in states 0 or 2, and trigger a fault otherwise.
Handling these faults involves creating a new copy of the page and
setting the page writable. 
Reading from kernel code involves creating a new snapshot and 
setting the page read-only.
None of the aforementioned operations relies on other operations 
on the same page to complete and all are finite-time.
None of the operations on a page rely on operations on other pages.
A single, per-page lock can serialize operations on that page
and assure forward progress.


\TODO{Discuss how Midgard would help}
\tiktok assumes that syscalls do not both read and write to the same user data. 
There are particular syscalls, however, which rely on such behaviour, and 
are not instrumented.

\TODO{In implementation, discuss how IOMMU's can be used to prevent devide writes,
but is currently unsupported.}

Fake citation for compilation~\cite{silberschatz2018operating}.

\bibliographystyle{plain}
\bibliography{TikTok}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%  LocalWords:  endnotes includegraphics fread ptr nobj noindent
%%  LocalWords:  pdflatex acks
