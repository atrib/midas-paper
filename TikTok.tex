\documentclass[letterpaper,twocolumn,10pt, anonymous]{article}
\usepackage{usenix2019_v3}

% to be able to draw some self-contained figs
\usepackage{tikz}
\usepackage{amsmath}

% inlined bib file
\usepackage{filecontents}

%-------------------------------------------------------------------------------
\begin{document}
%-------------------------------------------------------------------------------


\newcommand\tocttou[0]{ToCtToU}
\newcommand\tiktok[0]{TikTok}

%don't want date printed
\date{}

% make title bold and 14 pt font (Latex default is non-bold, 16 pt)
\title{\Large \bf Kernel TOCTTOU Protection}

%for single author (just remove % characters)
\author{
{\rm Anonymous}\\
Your Institution
% copy the following lines to add more authors
% \and
% {\rm Name}\\
%Name Institution
} % end author

\maketitle

%-------------------------------------------------------------------------------
\begin{abstract}
%-------------------------------------------------------------------------------
Your abstract text goes here. Just a few facts. Whet our appetites.
Not more than 200 words, if possible, and preferably closer to 150.
\end{abstract}

\section{Design}

\tiktok is designed to maintain a single invariant: 
\emph{User data read by a system call will not change throughout the syscall's lifetime}.
By construction, the invariant guarantees that double-fetches in syscall
code will return the same data, eliminating \tocttou bugs. 
\tiktok maintains the invariant by tracking versions when the data is first accessed,
making copies when the data is concurrently written and 
accessing the correct copy in subsequent reads.
Initially, user data has a single copy, and versions access this copy. 
Copies are made for versions lazily, only when the user data recieves a concurrent write.

\tiktok's implementation leverages the protection mechanisms provided by existing 
virtual memory abstractions. 
On modern platforms, operating systems set up page-tables which provide protection
efficiently at a page-granularity. 
Therefore, \tiktok implements its invariant at a page-granularity, not object 
granularity: when a syscall reads from userspace, every page touched by that 
read are covered by the invariant, not merely the bytes read.
As a side-effect of this implementation, \tiktok cannot differentiate between
accesses to different parts of a page, and incurs overhead on false sharing.

\tiktok allows syscalls and userspace to concurrently access pages.
To ensure that writes to pages do violate the invariant, \tiktok
must maintain multiple copies of a page.
Particularly, for each syscall which has accessed a page, \tiktok
must maintain a snapshot of its contents from when the page was first 
touched by the syscall.
If a page is not written to between being touched by separate syscalls,
the corresponding snapshots of this page for both syscalls will be identical. 

\subsection{Page state machine}

\tiktok implicitly maintains a state machine for every single page mapped in
userspace. 
The state machine tracks running syscalls, the pages read by the syscalls,
and copies of the page necessary for providing the correct snapshot of the
page for subsequent reads by these syscalls.

\autoref{fig:tiktok_states} shows the state machine for a single page.
At every state, the page has two associated sets:
The copies set $C = {C_U, C_0, ..}$ holds multiple copies of the page over time. 
The snapshots set $S = {U, S_0, S_1, ...}$ tracks logical versions of the page, 
and each version points to a particular copy. 
The userspace copy ($C_U$) is that mapped in process' address spaces, and 
will be modified on writes from user/kernel code.
All other copies are read-only, and are used for providing snapshots to syscalls.
Each snapshot maps to a copy.

\paragraph{State 0}
A page starts as (unmarked, unduplicated). 
At this stage, there is a single writable copy $C_U$ and a single snapshot $U$. 
All processes where this page is mapped have unrestricted read and write access
to it.

\paragraph{State 1}
The page transistions to (marked, unduplicated) state as soon as a syscall 
reads from it. 
A new snapshot, $S_0$ is allocated for this page for this syscall.
Both snaphots $S_0$ and $U$ refer to the same copy $C_U$.
When in a marked state, the page's mapped copy $C_U$ becomes read-only,
allowing both user/kernel code to read freely from it, but not modify it.
Other syscalls which read the page now also get their own snapshots 
(e.g. $S_1$) all pointing to the single copy $C_U$.
The page's read-only status causes the hardware to fault on a write,
notifying \tiktok to transistion the page to the next state.

\paragraph{State 2}
A marked page transistions to (unmarked, duplicated) on any write.
Here, a new copy is created (say $C_0$) from the userspace
copy ($C_U$), duplicating its contents.
\tiktok moves all snapshots ($S_0$ and $S_1$) previously 
pointing to $C_U$ to now point to the new copy $C_0$. 
Thereafter, the userspace copy $C_U$ is made writable, and the 
triggering write is retried. 
Note how, at this state, any access the snapshot $S_0$ reads from
the unmodified copy $C_0$.

\paragraph{State 3}
A separate syscall subsequently reading the page transistions 
it to (marked, duplicated) state. 
The new snapshot, $S_2$, points to the userspace copy $C_U$ 
until a write to the copy.
On a write, the page will be duplicated and this snapshot 
will point to the new copy (similar to that in state 2).





\tiktok assumes that syscalls do not both read and write to the same user data. 
There are particular syscalls, however, which rely on such behaviour, and 
are not instrumented.

\bibliographystyle{plain}
\bibliography{TikTok}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%  LocalWords:  endnotes includegraphics fread ptr nobj noindent
%%  LocalWords:  pdflatex acks
