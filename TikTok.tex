\documentclass[letterpaper,twocolumn,10pt, anonymous]{article}
\usepackage{usenix2019_v3}

\usepackage{amsmath}
\usepackage{filecontents}
\usepackage{tikz}
\usepackage{xspace}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{textcomp}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{todonotes}
\usepackage{multirow}
\usepackage{booktabs}
\usepackage{paralist}
\usepackage{enumitem}
\usepackage{tabulary}
\usepackage{prettyref}
\usepackage{verbatim}
\usepackage{balance}
\usepackage{tabularx}

%-------------------------------------------------------------------------------
\begin{document}
%-------------------------------------------------------------------------------


\lstdefinestyle{cstyle}{
  basicstyle=\footnotesize\ttfamily,
  keywordstyle=\color{black!85}\bfseries,
  keywordstyle=[2]\color{black!85}\bfseries\emph,
  showstringspaces=false,
  language={C},
  breaklines=false,
  mathescape=true,
  escapechar={@}
}
\lstdefinestyle{inline}{
  style=cstyle,
  mathescape=false,
  breaklines=true,
  keywordstyle=,           
  keywordstyle=[2],
  extendedchars=true,
  basicstyle=\ttfamily\small
}
\newcommand{\Code}[1]{\lstinline[style=inline,breaklines=false]@#1@}
\let\realparagraph\paragraph
\let\paragraph\relax
\newcommand{\paragraph}[1]{\textbf{#1.}}
\newcolumntype{Q}{>{\centering\arraybackslash}X}

\newcommand\tocttou[0]{TOCTTOU\xspace}
\newcommand\tiktok[0]{TikTok\xspace}

\newrefformat{cha}{\hyperref[#1]{Chapter~\ref*{#1}}}
\newrefformat{sec}{\hyperref[#1]{Section~\ref*{#1}}}
\newrefformat{sub}{\hyperref[#1]{Section~\ref*{#1}}}
\newrefformat{tab}{\hyperref[#1]{Table~\ref*{#1}}}
\newrefformat{fig}{\hyperref[#1]{Figure~\ref*{#1}}}
\newrefformat{line}{\hyperref[#1]{line~\ref*{#1}}}
\newrefformat{lst}{\hyperref[#1]{Listing~\ref*{#1}}}
\newrefformat{pat}{\hyperref[#1]{Patch~\ref*{#1}}}
\newrefformat{alg}{\hyperref[#1]{Algorithm~\ref*{#1}}}

\renewcommand\itemautorefname{Attack}

\newcommand\mat[1]{\noindent{\color{blue} {\bf \fbox{Mat}} {\it#1}}}
\newcommand\atri[1]{\noindent{\color{red} {\bf \fbox{AB}} {\it#1}}}

%don't want date printed
\date{}

% make title bold and 14 pt font (Latex default is non-bold, 16 pt)
\title{\Large \bf Kernel TOCTTOU Protection}

%for single author (just remove % characters)
\author{
{\rm Anonymous}\\
Your Institution
% copy the following lines to add more authors
% \and
% {\rm Name}\\
%Name Institution
} % end author

\maketitle

%-------------------------------------------------------------------------------
\begin{abstract}
%-------------------------------------------------------------------------------
Your abstract text goes here. Just a few facts. Whet our appetites.
Not more than 200 words, if possible, and preferably closer to 150.
\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}
%%%%%%%%%%%%%%%%%%%%%%

The kernel enables isolation between processes and is a key trusted computing
base in every system. Each \emph{untrusted} user-space process runs under a
dedicated user in its own address space and must request resources such as
communication channels or changes to its address space from the \emph{trusted}
kernel. The user-space/kernel-space interface forms an explicit trust barrier
and all data that crosses this boundary must be carefully checked by the kernel.
%
User-space processes attack the kernel by issuing system calls that then trigger
kernel bugs, elevating the privileges of the process.
%
A common class of kernel bugs are so-called \emph{double-fetch}
bugs~\cite{serna08doublefetch, twizsgrakky07ring0, wilhelm2016xenpwn,
wang2018survey}. They occur when higher-privileged code, such as
the kernel, reads the same data from the lower-privileged address space twice.
%
Double-fetch bugs are a type of
\emph{race condition} between threads of different privileges. A
\emph{Time-of-check to time-of-use (\tocttou)} violation occurs when the first
read is used to check a condition while the second read is used to modify
state.
%
An example of a double fetch bug is when the kernel reads the length of a buffer
from user-space, allocates a kernel buffer, then reads the length a second time
to finally copy the data from user-space to kernel. An attacker may concurrently
overwrite the length of the buffer to a larger number after the kernel allocated
its buffer, causing the memory copy to overflow it.
%
Double-fetch bugs are a frequent problem in kernels and
hypervisors~\cite{cve201812633, cve202012652, cve20131332, cve201920610,
cve20158550, cve201610439, cve201610435, cve201610433, cve20195519,
cve20168438}. Considering that double-fetches also appear in drivers, legacy
systems with binary-only drivers cannot be patched, even if a bug is found.
Furthermore, Watson~\cite{watson2007exploiting} blames an unfixable \tocttou
constellation as a reason for the generic insecurity of \emph{system call
wrappers}.


To mitigate double-fetch bugs in the kernel, a system must prohibit
\emph{concurrent changes} to memory accessed by the system call. Attackers may
find thrifty ways to trigger such concurrent writes:
\begin{enumerate*}[label=\textbf{(\roman*)}]
\item  direct writes from user-space (e.g., from concurrent threads),
\item  kernel writes from system calls (e.g., from concurrent system calls),
\item  modifying address space mappings,
\item  concurrent \texttt{write}s to a file that alters mapped
file pages, or
\item  storing arguments on device-backed pages, leveraging devices to trigger
concurrent writes
\end{enumerate*}.
To prevent attacks, all kinds of concurrent writes must be prohibited.

% TODO key idea
We base our defense on a single key invariant: 
\textbf{\emph{through a syscall's lifetime, every read to a userspace object 
will return the same value}}. Based on this invariant we derive a \emph{security
property} that ensures that every read during the execution of a system call is
cached. Subsequent reads of the same address will always return the same value.
For performance, multiple versions of an object may exist at the same time
depending on when the system call was started and depending on how many
concurrent system calls are in flight. Orthogonal, we derive a \emph{correctness
property} that ensures the sharing of the correct version among the different
system calls that are in flight. All writes end up on the most recent version of
the objects and therefore allow forward progress.
% Mat: should we split it into security, correctness, and performance
% properties, all driven by the core invariant?
We implement our invariant in \tiktok for the Linux kernel but the defense
applies to any modern operating system kernel.

% TODO performance
Our evaluation shows overall low performance overhead for our mitigation.
\mat{TODO talk about benchmarks.}
The security evaluation demonstrates how \tiktok successfully stops all attacks
against vulnerable system calls, along with providing the developer with
sufficient information about the location of the bug.


The main contributions of this paper are:

\begin{itemize}
\item Distillation of \tocttou attack vectors into a core variant that protects
the kernel against malicious concurrent modifications;
\item \tiktok, a design that prohibits and detects
\tocttou attacks against modern kernels, prohibiting their exploitation and
enabling developers to detect \tocttou bugs;
\item an efficient implementation of \tiktok for the Linux kernel.
\end{itemize}


\section{Background}

\subsection{Linux Memory Subsystem}

\subsection{Page Tables and Memory Protection}

\subsection{SMAP}

\begin{figure}[]
  \centering
  \includegraphics[width=.85\linewidth]{img/doublefetch.pdf}
  \caption{Example of a double-fetch bug}
  \label{fig:doublefetch}
\end{figure}


%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Attack vectors}
\label{sec:threats}
%%%%%%%%%%%%%%%%%%%%%%%%%%%

In this section, we describe the threat model for exploiting double-fetch
bugs in the kernel and classify the possible attacks based on how the 
data is modified between vulnerable double-fetches.

\subsection{Threat Model}
\label{sec:threatmodel}

% Nothing fancy -- the adversary is just trying to hack the system
% No black magic allowed
The adversary has access to a user account on the target machine. They can
execute arbitrary userspace code, including system calls. Some of the system 
calls have double-fetch vulnerabilities, and the adversary wants to exploit them,
e.g., for privilege escalation.
The attacker may execute on multiple CPU cores and may execute an arbitrary 
sequence of system calls. 

\tiktok mitigates any unintended corruption or information leakage \emph{in the kernel}
or \emph{in other user processes} that arises through double-fetch bugs. 
Hardware attacks such as Rowhammer~\cite{mutlu2019rowhammer}
or side-channels~\cite{kocher2019spectre}, and file-system TOCTTOU
attacks~\cite{payer2012protecting, pu2006methodical, wei2010modeling,
tsafrir2008portably} are out of scope.

\subsection{Attacks Classification}
\label{sec:attacks}

% List five attacks and explain them quickly
\tiktok guards data passed into the kernel against concurrent modification.
In the following classification, we denote the data fetched twice
by code containing a \tocttou bug as vulnerable data.
\begin{enumerate}
  \item \label{attk:direct} \emph{Direct double fetch}: The adversary runs
  concurrently with a system call in a separate thread in the same address space
  and uses userspace store instructions to modify the vulnerable data.
  % user write -> kernel read

  \item \label{attk:systemcall} \emph{Privileged double fetch}: The adversary
  executes a \Code{read} syscall to run concurrently as the target syscall in 
  the same address space. 
  The adversary provides the address of the vulnerable data as the buffer 
  into which the \Code{read} syscall will write.
  In an example of a confused-deputy attack, the kernel thread executing the
  \Code{read} on the adversary's behalf modifies the vulnerable data.
  % read(): kernel (privileged) write -> kernel read

  \item \label{attk:remapping} \emph{Reflected double fetch}: The target
  syscall should be reading the vulnerable data from a file-backed page.
  The adversary running in another address space maps the same file-backed page
  as writable and modifies the vulnerable data using the new mappings.
  This approach attempts to bypass any protections set up by the kernel
  when first reading the vulnerable data by adding a new mapping to it later.
  % mmap(): user write -> kernel read

  \item \label{attk:writebuffers} \emph{Inception double fetch}: The 
  target syscall should be reading the vulnerable data from a file-backed 
  page. The adversary opens the file and issues a \Code{write} syscall.
  The kernel modifies the vulnerable data while executing the filesystem's
  write code for the file.
  % mmap(): write(): kernel (privileged) write -> kernel read

  \item \label{attk:devicefiles} \emph{Device double fetch}: The target 
  syscall is reading a page available for direct-memory access (DMA) by 
  an I/O device. The device can initiate a DMA write, modifying the 
  vulnerable data. This avenue does not use store instructions in any 
  CPU core.
  % device write -> kernel read

\end{enumerate}
\mat{Can we add a short sequence or figure for each of these attacks? This would
IMO help. I've added a note in comments to describe the attack/victim
scenarios.}

Watson~\cite{watson2007exploiting} in his analysis of CerbNG introduces
\autoref{attk:direct}, \autoref{attk:remapping} and \autoref{attk:writebuffers}.
We extend the discussion of known attacks and introduce
\autoref{attk:systemcall} and \autoref{attk:devicefiles}.

A comprehensive protection against \tocttou bugs must protect against 
all concurrent writes of these representative attack vectors.
\mat{Are we sure these are complete? Can we make a stronger statement that a
defense must enforce a generic property?}
The protection mechanism necessarily manages access control for pages
mapped across multiple address spaces and also via file-system drivers.
As shown above, an adversary can use its own mappings to try to modify the
vulnerable data, or coerce the kernel to do so using particular syscalls.
The next sections describe \tiktok, our protection mechanism which 
protects against the first four vectors, and can be extended to protect 
against the final vector too.


%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{\tiktok Design} 
\label{sec:design}
%%%%%%%%%%%%%%%%%%%%%%%%%%%

\tiktok maintains a single core \emph{invariant}:
\textbf{\emph{Through a syscall's lifetime, every read to a userspace object 
will return the same value}}.
By construction, the invariant guarantees that double-fetches in syscall
code will read the same data, \emph{eliminating \tocttou bugs}.
\tiktok maintains the invariant by tracking \emph{snapshots} of objects
when first accessed, lazily making \emph{copies} when the object is concurrently 
written and accessing the correct copy on subsequent reads.
Copies are only maintained during syscalls' lifetimes, and are released as 
soon as no syscall needs it.
Consequently, each userspace object has a single copy when no syscalls are
running.
The invariant also means that only accesses to userspace objects by the kernel
need to be protected. 
Accesses to userspace objects from userspace and kernel objects by kernel 
code remains unaffected.

\tiktok's implementation builds on the protection mechanisms provided by 
existing virtual memory implementations.
On modern platforms, virtual memory protection is set up by the OS at
page-granularity by setting bits in pagetable entries (PTEs).
These permission bits are checked by the hardware on memory access, 
efficiently enforcing that the permissions are respected, or raising 
a fault when they are not.
Therefore, \tiktok implements its invariants at page-granularity, not object 
granularity: when a syscall reads from userspace, every page touched by that 
read is covered, not merely the bytes read.
As a side-effect of this implementation, \tiktok does not distinguish
accesses to different parts of a page, and may incur performance overhead due
to false sharing within a page. 
Page-granularity protections are more conservative compared to byte-granularity
protection and, therefore, \tiktok maintains its invariants nonetheless but may
incur performance overhead for false sharing on highly contended pages.

For an object spanning multiple pages, \tiktok's design sequentially 
protects each page before reading from it.
The leading pages containing the object are protected before the
later pages, allowing an attacker to potentially modify the later 
pages before the syscall first reads them.
However, the attacker is prevented from modifying any of these earlier pages
after the syscall's first read, ensuring that double-fetches respect
the invariant.
If the syscall code contains a \tocttou bug, the modification will
be visible to the first fetch itself (which is used for checking for 
validity of the data) and will lead to the data being rejected 
straightaway.
\tiktok's invariants therefore prevent exploitation of double-fetch
vulnerabilities even when the fetched objects span multiple pages.

A major requirement for \tiktok is to allow concurrent access to pages
by user/kernel code running in parallel with a syscall which reads from 
the same pages.
This requirement prevents deadlocks and improves performance vis-a-vis
a na\"ive design which blocks all other tasks writing to pages already 
read by a syscall until the syscall completes.
The na\"ive design can deadlock because it introduces dependencies between
tasks for forward progress, and we illustrate this in the following example
of a system with two tasks, A and B.
Task A issues a blocking system call which reads a user page and blocks. 
Task B writes to the same user page before issuing a syscall which 
resumes task A. 
In this case, if Task A's read to the page preceds Task B's write, 
Task B will be blocked waiting for A to complete its syscall.
Task A will also remain blocked waiting for Task B's syscall, 
introducing a circular dependency, leading to deadlock.
The na\"ive design also introduces unnecessary delays in other cases, 
such as the one described below, again with two tasks C and D.
Task C reads from a page and sleeps for a long, determinate while.
Task C does not read from the page a second time.
Task D writes to the same page after task C has read from it, and 
blocks until Task C completes and is unnecessarily delayed.
A more performant approach is to duplicate the concurrently accessed page: the copy is 
kept should task C fetch data from the page again, and task D
can write to the original and proceed without delays.

\tiktok must maintain multiple versions of a page read by a syscall 
to maintain its invariants in the face of concurrent writes.
\tiktok introduces \emph{snapshots} and \emph{copies} to keep track 
of page versions. 
Snapshots are logical views of the page's contents at a particular time,
while the actual contents are stored in one of many copies. 
Each snapshot maps to a copy, allowing the contents of the page at the 
time of creating the snapshot to be read. 
If multiple snapshots are taken without intervening writes to the page, 
these snapshots will map to a single copy, reducing \tiktok's space overheads 
and performance overheads for creating copies.
\tiktok maintains a snapshot of every page when first read by a syscall.
On a double fetch by the same syscall, the copy mapped to by the snapshot 
is accessed, ensuring that the data read is the same as the first time.
The latest copy of the page is used for all writes, by the syscall as 
well as from concurrently running tasks, updating the page as seen 
from userspace.
\emph{Essentially, \tiktok is a multi-versioning system for pages where 
syscalls read from immutable versions to prevent \tocttou bugs and
syscalls and userspace both write to a single mutable version 
holding the latest state of the page.}
\tiktok's design draws parallels to multi-version concurrency control 
methods for databases based on snapshot isolation~\cite{0001MK15}.
Transactions read from a snapshot of the database state from when 
they started, and writes update the up-to-date state of the database.

\subsection{Page state machine}

\begin{figure*}[]
  \includegraphics[width=\linewidth]{img/tiktok_states.pdf}
  \caption{State diagram for a page in \tiktok. Reads/writes from userspace/syscall 
          code are marked (u)/(s) respectively. Shading is used to represent the 
          mapping from snapshots to copies.}
  \label{fig:tiktok_states}
\end{figure*}

\begin{figure}[]
  \includegraphics[width=\linewidth]{img/doublefetch_tiktok.pdf}
  \caption{Diagram illustrating \tiktok preventing exploitation of a double fetch.}
  \label{fig:doublefetch_tiktok}
\end{figure}

To track multiple versions of the contents of a page when being concurrently 
accessed by numerous tasks, from userspace or during a syscall,
\tiktok implicitly maintains a per-user-page state machine.
For each page, its corresponding state machine 
\begin{inparaenum}
  \item tracks snapshots for currently executing syscalls which have read it, 
  \item tracks copies of the page, and 
  \item maintains the mapping between snapshots and copies necessary for providing 
  the correct contents to subsequent reads by these syscalls.
\end{inparaenum}

\autoref{fig:tiktok_states} shows the state machine for a single page.
At every state, the page has two associated sets:
\begin{inparaenum}[\itshape i\upshape)]
  \item the copies set $C = \{C_L, C_0, \dots\}$ holds multiple copies of the page over time, and
  \item the snapshots set $S = \{L, S_0, S_1, \dots\}$ tracks logical versions of the page, each corresponding to one executing syscall and mapping to a copy. 
\end{inparaenum}
Reads from kernel code in a syscall use the \emph{snapshot's corresponding copy}.
Writes from user/kernel code and reads from userspace access the \emph{latest 
copy}, which is mapped in process' address spaces.
All other copies are read-only (no matter what the original page protection is), and are used for providing snapshots to syscalls.
Read-only pages only use states 0 and 1, and writes lead to segmentation faults
as they do on non-\tiktok systems.
Knowing which state the page is allows \tiktok to differentiate faults due
to protecting pages from faults due to programs actually writing to an 
originally read-only page.
The latest copy $C_L$ of read-only pages remains read-only in both states.
In the following paragraphs, we describe how the state machine for a single, 
writable user page transitions between its states, what triggers each transition, 
and what changes are made to the copies and snapshot sets on a transition.
In \autoref{fig:doublefetch_tiktok}, we illustrate how the state machine protects the 
syscall from \autoref{fig:doublefetch}.

\paragraph{State 0}
A page starts as \texttt{(unprotected, unduplicated)}.
In this state, there is a single copy $C_L$ and a single ``snapshot'' $L$. 
The snapshot $L$ refers to the latest version of the page which changes 
with time, and is the only mutable snapshot.
All processes where this page is mapped have unrestricted userspace read and write 
access, and unrestricted kernel write access.
The remaining operation, a read from kernel code, triggers a transition to 
the next state.
In \autoref{fig:doublefetch_tiktok}, we see the snapshot $L$ initially containing 
the value $42$.

\paragraph{State 1}
The page in State 0 transitions to the \texttt{(protected, unduplicated)} state as soon as a syscall 
reads from it.
\tiktok first marks the page's latest copy $C_L$ read-only in all processes, 
trapping writes to the page but allowing concurrent userspace reads to continue.
A new snapshot, $S_0$ linked to this syscall is allocated for this page.
For the rest of its lifetime, this syscall will only read from this snapshot.
Both snaphots $S_0$ and $L$ refer to the same copy $C_L$ (shown by the 
blue cross-thatch in \autoref{fig:tiktok_states}).
Prior to any writes to this page, any other syscalls which also read the page  
get their own snapshots (e.g., $S_1$) all pointing to the single copy $C_L$.
The page's read-only status causes the hardware to fault on any write,
notifying \tiktok to transition the page to the next state.
In \autoref{fig:doublefetch_tiktok}, the page transitions to state 1 when 
the syscall first reads it, and adds a snapshot $S_0$.

\paragraph{State 2}
A page in State 1 transitions to the \texttt{(unprotected, duplicated)} state 
on any write from user or kernel code.
\tiktok duplicates the old contents of the page from copy $C_L$, creating a 
read-only copy $C_0$ (shown by green shading in \autoref{fig:tiktok_states}).
Snapshots except $L$ (i.e. $S_0$ and $S_1$) previously mapping to $C_L$ are 
mapped to the copy $C_0$.
The write then modifies the latest copy $C_L$, which is now made writable.
Note how, at this state, any read using the snapshots $S_0$ or $S_1$ reads 
from the unmodified copy $C_0$ while writes directly affect $C_L$.
Certain syscalls such as \Code{rt_sigaction} both read and write from 
the same user page. 
A write by \Code{rt_sigaction} to the page it has previously read will update
the page's latest copy $C_L$, but not the duplicate copy $C_0$.
This ensures that the copy $C_L$ always holds the latest contents of the page, 
up-to-date with all the writes to the page, from both user and kernel code. 
Further, \tiktok does not need to merge writes from userspace and syscall code
on a syscall's completion, since both directly modify the same copy $C_L$.
All other copies $C_i$ are immutable.
When the attacker writes to the page in \autoref{fig:doublefetch_tiktok}, the
page moves to state 2, linking the snapshot $S_0$ to a copy holding the 
original value $42$.
The writes from both the adversary and the syscall itself both affect 
the copy $C_L$, but the read from the syscall accesses the snapshot $S_0$
and reads the same value as the first time.


\paragraph{State 3}
A separate syscall subsequently reading the page in State 2 transitions 
it to \texttt{(protected, duplicated)} state. 
The new snapshot, $S_2$, points to the latest copy $C_L$.
State 3 is similar to state 1, except that there are different copies of 
the page used for reading by different syscalls. 
The syscall for which $S_0$ was allocated will read from the copy $C_0$,
while the syscall for which $S_2$ was allocated will read from copy $C_L$.
On a write, the page will transition to state 2 and will be duplicated again,
creating another copy $C_1$: snapshot $S_2$ will map to $C_1$ while 
snapshots $S_1$ and $S_0$ will continue to map to $C_0$. 

\paragraph{Releasing snapshots}
\tiktok uses snapshots to enable a syscall to read the same data from a page 
during its lifetime and releases snapshots when syscalls complete. 
Releasing a snapshot is possibly accompanied by a state transition
and the release of the mapped copy.
If $S_i$ mapped to the latest copy $C_L$, \tiktok cannot free the copy
since userspace is using it.
In this case, the page must be in state 1 or 3, and $C_L$ is read-only.
After removing $S_i$, if $L$ is the sole remaining snapshot mapped to $C_L$, 
\tiktok makes the page writable, moving to states 0 or 2 from states 
1 or 3 respectively. 
If $S_i$ is mapped to any other duplicate $C_i$, \tiktok frees the copy along
with the snapshot if $S_i$ is the last remaining snapshot mapped to $C_i$.
If the page was in state 2, $C_L$ was writable and unmapped by any snapshot,
so \tiktok changes the page to state 0.
This transitions is shown in \autoref{fig:doublefetch_tiktok}, where the 
snapshot $S_0$ and the copy $C_0$ are both discarded.
If the page was in state 3, $C_L$ was read-only and mapped by some other
snapshot, so \tiktok moves the page to state 1.
Recall that all snapshots $S_i$ (i.e. excepting snapshot $L$) are immutable
any data written by the syscalls directly affect the snapshot $L$. 
Therefore, dropping a snapshot $S_i$ is trivial and does not require 
writes from the syscall to be merged into the latest copy.

\subsection{Discussion}

\begin{table}
\begin{center}
\begin{tabularx}{\columnwidth} { | l | X |}
\hline
System Call & Exemption reason \\
\hline
\hline
\Code{futex} & Relies on concurrent write \\ \cline{1-2}
\Code{poll} & Relies on concurrent write \\ \cline{1-2}
\Code{ppoll} & Relies on concurrent write \\ \cline{1-2}
\Code{select} & Relies on concurrent write \\ \cline{1-2}
\Code{pselect6} & Relies on concurrent write \\ \cline{1-2}
\Code{rt\_sigtimedwait} & Relies on concurrent write \\ \cline{1-2}
\Code{execve} & Remaps address space \\ \cline{1-2}
\end{tabularx}
\end{center}
\caption{System calls uninstrumented by \tiktok}
\label{tab:except_syscall}
\end{table}

\paragraph{Correctness concerning syscalls directly updating snapshot $L$}
\tiktok's design lets all writes, including those from syscalls, to directly 
update the latest copy of the page $C_L$ and this design maintains correctness 
of system execution.
In this paragraph, we shall show that there is a valid, safe\footnotemark 
execution trace of a system not protected by \tiktok which generates the same 
sequence of writes to the page, and therefore generates the same contents
of the page when the syscall ends. 
By showing that the final contents of memory after a \tiktok syscall has a 
corresponding execution without \tiktok (which we assume to be correct), 
we can conclude that the execution of the \tiktok syscall is also correct.
For this proof, we assume that no syscall reads the same object after writing 
to it (r-w-r pattern). 
Such syscalls do not exist in the Linux kernel, and are discussed below.
Therefore, our syscalls write to an object after completing all of its reads.

\footnotetext{A safe trace has no writes to vulnerable data between double fetches 
by the kernel, and therefore does not trigger any existing \tocttou bugs.}

Let us consider a page holding a single-byte object $O_0$, and the 
sequence of operations to this byte during a \tiktok syscall be 
$Ops = \{Op_0, Op_1, \dots \}$. 
Each operation is a tuple $(r/w, k/u)$ specifying whether the 
operation was a read or a write, and whether the operation was due to 
a user or kernel instruction.
Suppose there was no attempt to exploit a \tocttou bug, i.e. between
any two read operations by the same syscall, there was no write to 
this object.
In this case, \tiktok reads the same value from its snapshot of the 
object as is present on the latest version. 
The same sequence of operations on a non-\tiktok system would be valid and
safe, since the object value does not change between the kernel's double 
fetch and the syscall reads the same value on this system.

Let us now assume that there was an attempt to exploit a \tocttou bug:
a write $Op_1$ exists between two syscall reads $Op_0$ and $Op_2$.
\tiktok protects the syscall ensuring that $Op_2$ does not see the 
effect of $Op_1$ by reading from a snapshot instead of the latest 
copy $C_L$. 
Since our syscalls are assumed to not contain any r-w-r pattern, 
any writes by the syscall happen after $Op_2$.
Let us assume that the syscall's write is $Op_3$.
We can generate a valid, safe execution on a non-\tiktok system 
by moving the adversary's write to after the last read by the 
syscall, i.e. $Ops = \{Op_0, Op_2, Op_1, Op_3\}$.
The syscall in this system reads the same value both times, and 
hence has the same execution as that in the \tiktok case.
The value of the object when the syscall completes is that 
written by $Op_3$ in both cases (or that written by $Op_1$ in 
case the syscall does not have a final write).
Since the syscall has the same execution and the final value of 
the object is the same, the execution of the \tiktok system 
is the same as that of the non-\tiktok system.
In general, any trace of operations on a \tiktok system can 
be translated  to a valid, safe trace on a non-\tiktok system 
by moving adversarial writes to just after the last after 
double fetches by executing syscalls.
Multiple syscalls in \tiktok can therefore write without affecting 
correctness, because the an equivalent, valid, safe non-\tiktok trace 
exists where all of the writes have been postponed, in the same order 
to after the double fetch reads. 

\paragraph{Exceptions}
Certain syscalls such as \Code{futex} rely on user data changing between 
double fetches to implement their functionality and cannot be protected by
\tiktok.
Such syscalls are listed in \autoref{tab:except_syscall}.
The \Code{futex} syscall implements a fast synchronization mechanism
for userspace and relies on atomic writes from concurrent userspace
threads to update a condition the syscall is waiting for. 
Subjecting a \Code{futex} syscall to \tiktok's invariants will prevent
it from ever waking up the waiting task.
Such syscalls cannot be protected by \tiktok, and we implement an 
exception list to prevent transitions in the state machines of pages read 
by these syscalls.
The code for these syscalls must be manually inspected for double-fetch 
vulnerabilities.
Crucially, exempting these syscalls from \tiktok's protection does not 
affect the security of other syscalls. 
Any writes from these syscalls are subject to the same rules described
in the state machine, and cannot break \tiktok's invariants.


\paragraph{Syscalls with read-write-read patterns}
A hypothetical syscall which reads from an object, writes to it, and
then reads back the updated object cannot be protected using \tiktok.
\tiktok's invariant will ensure that the second read is identical to the first,
and does not reflect the intermediate write. 
Such syscalls will also need to be exempted from \tiktok's instrumentation.
The authors did not find any syscall which exhibits this behavior in the Linux
kernel. 

\paragraph{Syscalls with false sharing}
Another hypothetical syscall could face problems with \tiktok's 
instrumentation due to false sharing. 
Suppose a page contains two objects, $O_0$ and $O_1$, and a syscall  
sequentially reads $O_0$ then $O_1$.
Due to \tiktok's invariant being enforced at page-granularity and 
false-sharing of the page between these objects, \tiktok guarantees that
the value of object $O_1$ read is the same as what was contained when it 
first read object $O_0$. 
A syscall which requires the value of $O_1$ to change between these two 
points in time would, therefore, not work with \tiktok protections. 
We believe that such a syscall, requiring concurrent modifications to its 
arguments, will likely exist to support some synchronization mechanism 
similar to a \Code{futex} and can be safely exempt from \tiktok's invariant.
The authors did not find any syscall which exhibits this behavior in the 
Linux kernel. 


\paragraph{Preventing deadlocks by design}
\tiktok's design is free of deadlocks, and exempts syscalls which 
require violation of its invariant from triggering particular 
state-machine transitions.
Userspace reads always succeed, using the latest copy $C_L$ of the
accessed page.
Writes from userspace and kernel code succeed directly if the 
page is in states 0 or 2, and trigger a fault otherwise.
Handling these faults involves creating a new copy of the page and
setting the page writable. 
Reading from kernel code involves creating a new snapshot and 
setting the page read-only.
None of the aforementioned operations relies on other operations 
on the same page to complete and all are finite-time.
None of the operations on a page rely on operations on other pages.
A single, per-page lock can serialize operations on that page
and assure forward progress.

\paragraph{Detecting double fetches}
\tiktok's state machine for pages also allows it to be used as a 
sanitizer since it can detect, and therefore report when a syscall 
double fetches from the same page.
When a syscall first reads from a user page, it creates a snapshot 
of that page.
On future reads, the snapshot is used in order to maintain the 
invariant.
This means that for reading from a page, implementations must check 
if a snapshot exists for the syscall: if yes, the snapshot is used
for the read, otherwise a new snapshot is created and then used 
for the read. 
The prior existence of a snapshot means that the syscall had previously
read from this page and had then created this snapshot, implying a double 
fetch.
This approach, however, is prone to false positives due to false sharing.
The two reads might read from the same page, but might access entirely 
disjoint bytes. 
\tiktok's design does not currently allow us to prevent such false positives.

%%%%%%%%%%%%%%%%%%%
\section{\tiktok implementation}
\label{sec:impl}
%%%%%%%%%%%%%%%%%%%

The \tiktok prototype implements the state machine described in 
\autoref{sec:design} on Linux version 5.11, targeting the x86-64 
architecture. 
A page protected by \tiktok transitions between states on 
either a kernel read to user memory, or when user or kernel code
writes to read-only memory (see \autoref{fig:tiktok_states}).
\tiktok can be implemented on any operating system kernel that uses 
a defined interface for reading from userspace (\Code{read_in}) and
on any architecture which implements hardware-controlled access 
control to memory through page tables. 
The first requirement enables \tiktok to implement transitions on 
kernel reads from user memory.
The Linux kernel uses the \Code{raw_copy_from_user} interface which 
we instrument for our prototype.
The second requirement causes the hardware to raise a faults, 
directing execution on the processor to a pre-defined exception 
handler in the OS.
Our prototype instruments the Linux' fault handler in the function 
\Code{handle_pte_fault} to implement the write-triggered transmissions 
from states 2 and 4.


\subsection{Tracking page state}

\begin{figure}[]
  \includegraphics[width=\linewidth]{img/book-keeping.pdf}
  \caption{Bookkeeping information for a page}
  \label{fig:tiktok_bookeeping}
\end{figure}

\tiktok needs to track the state for every userspace page, including
its snapshot and copy sets.
\autoref{fig:tiktok_bookeeping} shows the data structures used to
track this state in our prototype.
Linux maintains a \Code{struct page} object for every frame of 
physical memory. 
We augment this structure with a list holding the snapshots
for this page, excluding the latest snapshot $L$.
Each snapshot has a pointer to its copy. 
In the figure, the snapshots $S_1$ and $S_0$ share the copy $C_0$.
The authors are aware of the strong aversion of the 
Linux kernel developer community towards increasing the size of 
\Code{struct page}. 
An alternate implementation can use a hashmap to
map from a page's frame number to its snaphots list or
reuse existing data members (e.g., \Code{struct list_head lru} which 
can be used as a generic list by page owners).

Each pagetable entry for this page in different address spaces 
map the copy $C_L$, enabling userspace to directly access this
copy with reads (and writes for writable pages).
We use one software-controlled bit (SW3) in the pagetable entries 
to track the protection status of the page, and another (SW2)\footnotemark
to track the original protections for the page. 
SW3 is set whenever the page is in one of the two protected
states (1 and 3).
On a write-triggered protection fault, SW3 can be read to 
efficiently determine if the fault was due to \tiktok's protection 
mechanisms, triggering a state change, or due to buggy software
accessing a page with illegal permissions, triggering a signal to 
the task.
Other architectures might have a fewer number of software-usable 
bits in the page-table, and implementations of \tiktok would 
require storing the protection status of pages in a separate data structure.
The duplication status of the page is implicitly encoded in the 
snapshots: the page is duplicated when any of its snapshots
holds a pointer to a copy other than $C_L$.

\footnotetext{The SW2 bit is also used by the Software Dirty Pages feature of 
Linux, and cannot be run alongside \tiktok in our prototype.}

Changing the protection state of pages requires updates to 
PTEs for the page in all address spaces where the page is mapped.
The page's \Code{struct page} structure includes a reverse-map
listing all of these address pages, and the corresponding virtual
address in each.
Our prototype uses this mapping to change PTE permissions across
multiple address spaces for a page.

\subsection{Stuff like modified functions}
\paragraph{Kernel reads from user memory}
Syscalls reading from user memory the first time triggers the 
allocation of a new snapshot. 
If the page is not protected (states 1 and 3), this also 
triggers a state change where the kernel protects the page
in all address space that it is mapped in. 
\autoref{fig:copy_from_user} shows the flowchart implemented
by the kernel function \Code{raw_copy_from_user} for reading
from user memory.
This function also uses the kernel's \Code{mark_page_accessed} 
interface to move the page to the ``Active'' state for the 
kernel's swapping mechanism, making the page ineligible for being 
swapped out.

\begin{figure}[]
  \centering
  \includegraphics[width=0.8\linewidth]{img/copy_from_user.pdf}
  \caption{Flowchart for syscall reading from userspace memory}
  \label{fig:copy_from_user}
\end{figure}

\begin{figure}[]
  \includegraphics[width=\linewidth]{img/pagefault.pdf}
  \caption{Flowchart for handling a page fault. operations
           marked with an asterisk are unmodified.}
  \label{fig:fault_handling}
\end{figure}

\begin{figure}[]
  \includegraphics[width=\linewidth]{img/pagefault_cow.pdf}
  \caption{Flowchart for handling a page fault to a COW page}
  \label{fig:fault_handling_cow}
\end{figure}

\paragraph{Handling Faults}
The processor generates a fault when kernel or user code accesses
a page without having the correct permission in the corresponding PTE.
\tiktok marks writable pages read-only to protect them in 
states 1 and 3, allowing the kernel to detect writes to these pages.
A common OS mechanism, copy-on-write (COW) pages, also uses 
permissions in the PTE to detect when COW pages need to be copied.
The PTE's present bit are used to store pointers to file-backed pages
when they are swapped to disk.
\autoref{fig:fault_handling} shows the flowchart implemented by
\Code{handle_pte_fault} to handle faults for userspace addresses.

The page-fault handler first checks if the PTE is NULL, and if so 
knows that it has to allocate a page. 
If the required page is anonymous, the page can be allocated as usual.
Otherwise, for file-backed pages, the handler has to check if the 
page is already in a protected state (states 1 and 3) by reading 
the SW3 bit of the PTE and if so, transitions to the required state
and allocates a new copy. 
Pages in states 0 and 2 can be directly mapped, and subsequently
accessed.
By correctly handling new mappings to file-backed pages, \tiktok
prevents \autoref{attk:remapping}. 

For non-NULL PTEs, the handler checks if the PTE indicates that the 
page is present, and non-present pages are swapped-in as usual.
Faults for a present page indicate a permission fault (write to 
a read-only page).
If the page is not a COW-page, the handler then checks if the page
is in a protected state by checking the SW3 bit.
If the page was protected, a new copy is allocated and the page 
transitions to the following state.
For non-protected pages, however, this fault implies a real access
violation, sending a signal to the process.

COW pages represent separate virtual pages from different 
address spaces mapped to the same physical page.
This is illustrated in \autoref{fig:fault_handling_cow} where 
logically separate pages A and B are actually mapped to the COW
page.
A COW page cannot be in states 2 or 3, since they cannot have multiple
\tiktok copies.
COW pages in state 0 can be dealt with by the kernel's standard 
duplication method (not \tiktok's duplication).
For a COW page in state 1, its list of snapshots can correspond to 
reads from syscalls for threads in different address spaces.
In \autoref{fig:fault_handling_cow}, we show snapshots $S_A$ and 
$S_B$ corresponding to syscalls for threads in different address 
spaces (containing A and B respectively).
These snapshots correspond to different logical pages, but are 
all squashed into the snapshots list of the single COW page. 
Therefore, after the kernel duplicates the COW page (new page
B created, in \autoref{fig:fault_handling_cow}), \tiktok moves 
the snapshots for the faulting process ($S_B$) to new page.
Finally, this new page is transitioned to its next state to allow 
for the write to occur, creating a new copy ($C_0$) for the 
snapshot $S_B$ to read from.




\section{Evaluation}

In this section, we quantify \tiktok's overhead on workloads 
with different characteristics, both compute-bound applications
which rarely use syscalls and I/O-bound applications which 
heavily rely on the kernel's I/O interface.
\tiktok's overhead depends on the number of address spaces 
where protected pages are mapped. 
Relevant benchmarks therefore include multiprocessing, parallel 
benchmarks.

We evaluate \tiktok on two benchmark suites: the NAS Parallel 
Benchmark (NPB)~\cite{npb} and select workloads from the 
Phoronix Test Suite (PTS)~\cite{pts}. 
NPB includes CPU-bound multiprocessing workloads with a 
low, but non-negligible syscall rate. 
NPB therefore demonstrates the ability of \tiktok to 
scale to systems where pages are protected across numerous 
address spaces.
PTS includes a variety of benchmarks, both CPU-bound and 
I/O bound representative of both desktop and server workloads.
PTS includes syscall-heavy applications with varying degrees 
of parallelism.
We do not include CPU benchmarks from the SPEC benchmark suite
as they are heavily CPU bound and designed to isolate userspace 
performance without syscalls, and therefore do not test kernel 
performance.

The testbench for the evaulation consists of a desktop machine 
with an 8-core Intel i7-9700 processor and 16GB DRAM running 
Ubuntu 20.04 LTS.
To eliminate the effect of dynamic frequency and voltage 
scaling (DVFS), we set the processor to run at constant 
frequency of 3.0GHz which is this model's base frequency.
In the \emph{baseline} configuration, we run the testbench 
with the mainline kernel v5.11 available from Ubuntu's package 
repository.
The \emph{\tiktok} configuration runs our prototype \tiktok kernel 
based on kernel v5.11.
For particular benchmarks, we also run the \emph{\tiktok-extra}
configuration which also runs our prototype \tiktok kernel
but instruments all syscalls including \Code{write}.

\subsection{NAS Parallel Benchmarks}

\begin{figure}[]
  \includegraphics[width=\linewidth]{img/npb_performance.pdf}
  \caption{\tiktok performance on NPB benchmarks relative to baseline with 
          the same parallelization technique}
  \label{fig:npb_performance}
\end{figure}

NAS Parallel Benchmarks (NPB)~\cite{npb} is a benchmark introduced by
NASA. 
NPB consists of several parallel programs using different communication
patterns and is available for two technology stacks for parallel programming:
OpenMP and MPI.
% Two variants that test either threads or processes
OpenMP~\cite{dagum1998openmp} is a compiler extension that splits a 
program's execution to multiple threads. 
All threads still use the same address space, keeping the overhead minimal. 
MPI~\cite{snir1998mpi} implements parallel execution by launching multiple
processes which communicate by message-passing. 
The two technology stacks have different frequency of syscalls due to 
different communication methods.
Communication through kernel syscalls for either stack will incur overhead
due to \tiktok's protection.
Additional global TLB shootdowns added by \tiktok will also affect the 
performance of such parallel benchmarks.

We evaluated NPB benchmarks of class A on our testbench, running 
4 threads/processes in parallel.
These benchmarks' runtime varies between 10 seconds and 8 minutes, 
and are all long enough for the kernel to reach equilibrium.
Certain benchmarks require a parallelism number which is a perfect square.
On our 8-core CPU, having 4 CPU-bound threads/processes instead of 16 allows 
all of them to run without time-sharing.
\autoref{fig:npb_performance} shows \tiktok's performance for both MPI and OpenMP 
normalized to the performance of the baseline system with the same parallelization
technique for the NPB benchmarks.
On average, \tiktok achieved $96.3\%$ of the baseline system's performance with 
both 
On both systems, \tiktok's performance for the \Code{ep} (Embarassingly Parallel)
benchmark is closest to that of the baseline, since it has low 
communication overheads.
\tiktok shows low overhead ($3.7\%$) for CPU-bound workloads, even when they 
involve parallelism.

\subsection{Phoronix Test Suite}

\begin{figure}[]
  \includegraphics[width=\linewidth]{img/pts_performance.pdf}
  \caption{\tiktok performance on PTS benchmarks relative to baseline system}
  \label{fig:pts_performance}
\end{figure}

The Phoronix Test Suite (PTS)~\cite{pts} includes a large set of 
open-source benchmarks, of which we have chosen a range of benchmarks 
suitable for evaluating both desktop and server performance.
These benchmarks complement those from NPB and range from single-threaded, 
CPU-bound applications (OpenSSL) to multi-threaded, multi-process 
programs, syscall-heavy server programs (Apache).

We plot \tiktok's performance relative to the baseline kernel on
these benchmarks in \autoref{fig:pts_performance}, roughly ordered 
workloads in increasing order of syscall dependence from left to right.
For benchmarks for which PTS reports runtime, we compute the inverse 
of the runtime as performance.
Benchmarks with low syscall frequency such as OpenSSL, 
Pybench and Git have correspondingly low dependence on kernel performance.
Accordingly, these benchmarks see a negligible overhead when running 
on our prototype kernel.
The benchmark titled ``Linux'' represents compilation of the Linux kernel.
While compilation is mostly CPU bound, compiling the Linux kernel requires 
compilation of a large number of source files, resulting in the creation 
of a large number of compiler processes each of which read different files. 
\tiktok experiences a small, but non-negligible overhead on this workload.
Redis requires syscalls for receiving and replying to requests, but 
processes its transaction entirely in-memory. 
Our evaluation prototype version achieves almost identical performance
as the baseline kernel.
However, Redis' performance on earlier, less optimized prototypes showed
significant degradation in performance (upto $69\%$).
The webservers, Apache and Nginx require network and file-system I/O, 
and rely heavily on syscall performance. 
We see that Nginx, which is a higher-performance webserver, sees a larger
overhead.
Fs-mark, which accesses a filesystem with 5000 files of 1MB concurrently
from 4 threads, and IPC, which implements 128 byte transfers between 
two processes over a TCP connection, are almost entirely bound by kernel 
performance. 
These benchmarks see a performance overhead of upto $10\%$ on \tiktok.

Our prototype \tiktok kernel benefits significantly from 
exempting particular, proven-safe syscalls from instrumentation.
While we exclude \Code{write}-like syscalls from \tiktok because they 
are not vulnerable to double-fetch bugs, we also evaluated the
performance cost of a na\"ive implementation (\tiktok-extra)
which also instruments these syscalls.
To highlight the worst-case performance of the na\"ive approach, we 
evaluate the performance of the IPC benchmark on \tiktok-extra due 
to its high frequency of \Code{write} syscalls.
From \autoref{fig:pts_performance}, we see that the benchmark's 
performance is further degraded by $81\%$ compared to \tiktok, 
showing that developer effort towards properly exempting 
frequently called syscalls from \tiktok protections is crucial
towards for implementations to maintain competitive performance
compared to the baseline.

\section{Trash}
\todo{Limitations: raw\_copy\_from\_user\_inatomic}

\todo{Discuss how Midgard would help}

\todo{In implementation, discuss how IOMMU's can be used to prevent devide writes,
but is currently unsupported.}

\bibliographystyle{plain}
\bibliography{TikTok}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%  LocalWords:  endnotes includegraphics fread ptr nobj noindent
%%  LocalWords:  pdflatex acks
