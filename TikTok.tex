\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts

% to be able to draw some self-contained figs
\usepackage{tikz}
\usepackage{amsmath}

\usepackage{listings}
\usepackage{parcolumns}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}
\usepackage[inline]{enumitem}


\usepackage{hyperref}

\renewcommand\sectionautorefname{Section}  
\renewcommand\subsectionautorefname{Section}
\renewcommand\subsubsectionautorefname{Section}
\renewcommand\itemautorefname{Attack}
\renewcommand\figureautorefname{Figure}
\renewcommand\tableautorefname{Table}

% Comment macros
\newcommand{\uros}[1]{\textcolor{pink}{\textbf{UT:} #1}}
\newcommand{\pra}[1]{\textcolor{blue}{\textbf{PS:} #1}}
\newcommand{\nb}[1]{\textcolor{green}{\textbf{NB}: #1}}
\newcommand{\mat}[1]{\textcolor{red}{\textbf{Mat:} #1}}
\newcommand{\evalfull}[1]{20}
\newcommand{\evalnocalls}[1]{3}
\newcommand{\sysname}{TikTok}
\newcommand{\roughevaloverheadbad}{18\%}
\newcommand{\roughevaloverheadbetter}{2-6\%}



%-------------------------------------------------------------------------------
\begin{document}
%-------------------------------------------------------------------------------

%do not want date printed
\date{}

% make title bold and 14 pt font (Latex default is non-bold, 16 pt)
\title{\Large \bf TikTok: Kernel TOCTTOU Protection}

%for single author (just remove % characters)
\author{
Anonymous submission \#TODO to Security \& Privacy '21
%{\rm Eric Tusso}\\
%EPFL
%\and
%{\rm Yamaha Priest}\\
%EPFL
% copy the following lines to add more authors
% \and
% {\rm Name}\\
%Name Institution
} % end author

\maketitle

%-------------------------------------------------------------------------------
\begin{abstract}
%-------------------------------------------------------------------------------

Double-fetch bugs are a plague in all major operating system kernels.  They
occur when data is fetched twice across the trust-boundary without checking that
it has not changed. Such bugs may force the kernel into an inconsistent state,
allowing an attacker to illegally access memory, cause denial of service, or to
escalate their privileges.

So far, the only protection against double-fetch bugs is to detect and fix them.
However, they exhibit illegal behavior only under specific conditions, making
them incredibly hard to find. Even worse, the bug may be in unchangeable code
(e.g., a binary driver blob).
%
We propose \sysname{} to mitigate double-fetch bugs.  \sysname{} leverages
on-the-fly page-table hardening to prevent changes to the system-call arguments,
while the system-call executes.

\sysname{} shows no noticeable drop in performance when evaluated on CPU-bound
workloads. On extremely system-call heavy workloads, \sysname{} shows
\roughevaloverheadbetter{} overhead when protecting select system-calls, and
\roughevaloverheadbad{} when all system-calls are guarded.


\end{abstract}

\begin{IEEEkeywords}
Double-fetch bugs, TOCTTOU, kernel security, page-tables, mitigation
\end{IEEEkeywords}

% Talk about the system-call filters and how they can be used for good
% Introduce the main problem - TOCTTOU
% Brag how our system is the best thing since sliced bread
\section{Introduction}

% Syscalls are a lucrative attack surface for adversaries which needs to be protected
Modern systems are broken into \emph{untrusted} user-space and the
\emph{trusted} kernel.  All data that crosses this trust boundary must be
checked.  Double-fetch bugs~\cite{serna08doublefetch, twizsgrakky07ring0,
wilhelm2016xenpwn, wang2018survey} occur when higher-privileged code (e.g., the
kernel) reads the same data twice from a lower-privileged address space (e.g.,
user-space). As an attacker could change the data between the two reads, this
allows a plethora of attack vectors.  Double-fetch bugs are a type of a
\emph{race condition} between two threads of different privileges. A
\emph{Time-of-check to time-of-use (TOCTTOU)} violation occurs when the first
read is used to check the operand while the second read is used to modify the
state.  Double-fetch bugs are a frequent problem in kernels and
hypervisors~\cite{cve201812633, cve202012652, cve20131332, cve201920610,
cve20158550, cve201610439, cve201610435, cve201610433, cve20195519,
cve20168438}. Considering that double-fetches also appear in drivers, legacy
systems with binary-only drivers cannot be patched, even if a bug is found.
Furthermore, Watson~\cite{watson2007exploiting} blames an unfixable TOCTTOU bug
as a reason for the insecurity of \emph{system-call wrappers}.  

% Enumerate the attack vectors
This state of affairs calls for a system that \emph{mitigates} double-fetches in
system-calls to protect the kernel.
To mitigate double-fetch bugs, a system needs to prevent any changes from
concurrent threads to memory accessed by the system-call.
The comprehensive system that protects against the modification of arguments
must take into consideration all the way the user can change the arguments.
The possible attack vectors are:
\begin{enumerate*}[label=(\roman*)]
\item \label{attk:direct} direct writes from user-space
\item \label{attk:systemcall} kernel writes from system-calls
\item \label{attk:remapping} remapping the pages with different permissions
\item \label{attk:writebuffers}\texttt{write} calls to a file that alter mapped file pages
\item \label{attk:devicefiles} storing arguments on device-backed pages
\end{enumerate*}.
Simple prevention of direct writes is not enough to stop all attacks. The
all-encompassing system that monitors redundant mappings, system-calls, and write
calls to files is necessary.

% Explain how we protect against the attacks briefly
\emph{Marking} the pages \emph{read-only} when system-call arguments are read
the first time prevents \autoref{attk:direct} and \autoref{attk:systemcall}. As
the page is loaded into the memory space, it is checked if it is already marked.
The permissions of the mapping are adjusted if necessary. This defends against
\autoref{attk:remapping}. Pausing system-calls that write to a file while some
of its mapped pages are marked prevents \autoref{attk:writebuffers}. Finally,
\autoref{attk:devicefiles} can be prevented by stopping the adversary from
mapping devices through \emph{Discretionary Access Control (DAC)}.

% A really high level overview of how the system works
The protection relies on a well-defined interface for \emph{reading} (\texttt{read\_in})
from user-space and on the page-tables to protect the marked pages. The
threads that attempt a write to a marked page are stopped in the
\emph{page-fault handler}. They continue their execution after the page is
unmarked. The kernel interface for \emph{writing} (\texttt{write\_out}) to
user-space is extended to execute all writes to marked pages at the end of the
call. This prevents the system-calls from writing to the pages they have marked.

% Overview of the limitations
A small subset of system-calls (e.g. \texttt{pollfd}, \texttt{futex}) depends on
the writes from user-space or double-fetches for the correct behavior.
Similarly, certain system-calls take a long time to execute
(\texttt{sys\_nanosleep}). They keep their arguments marked for the duration of
the call, hurting performance. These groups of system-calls should have the
protection disabled and be manually inspected for double-fetch bugs.


% Introduce TikTok
We present \sysname{} --- a memory marking extension to the Linux kernel.
\sysname{} provides system-calls with a view of the memory at the time it has
been read for the first time. \sysname{} also groups all the writes that could
modify protected memory and executes them at the end of the call. By mitigating
double-fetches, \sysname{} provides protection even against the double-fetch
bugs in the code that cannot be modified. Furthermore, \sysname{} renders
previously unavoidable double-fetches (such as a TOCTTOU in system-call
wrappers) completely benign. \sysname{} works on modern Linux distributions
(Ubuntu Server 18.04 LTS) and does not require any modifications to the user
programs. It can be implemented in other kernels and architectures which use
page-tables and a well-defined API to communicate with the user space
(\texttt{read\_in} and \texttt{write\_out} abstractions).

% Sneak-peek into the results

Benchmarking \sysname{} shows that system-call heavy multithreaded programs,
such as Apache and NginX, suffer an \roughevaloverheadbad{} drop in performance
with \sysname{} protecting all possible system-calls. By removing the
most frequent calls, the overhead drops to \roughevaloverheadbetter{}. CPU-bound
programs showed almost no performance drop when using \sysname{}, even when they
used multiple threads (OMP~\cite{dagum1998openmp}) or multi-process
message-passing (MPI~\cite{snir1998mpi}).



% Four contributions
The main contributions of this paper are:

\begin{itemize}

% Atri's comment: Why is the attack a separate contribution? Ans: It is an interesting attack vector
\item A \emph{confused deputy attack} on memory-marking protection mechanisms
that mark the pages with a \emph{superuser} bit (\autoref{attk:systemcall})
\item A solution to the problem of protecting the arguments of system-calls that
write to their arguments
\item A comprehensive technique for temporarily preventing memory from being
      changed, by safely postponing updates from both user-space and kernel
\item \sysname{} --- mitigation for the double-fetch and TOCTTOU attacks on
      system-call arguments in the Linux kernel
\end{itemize}

% Cover the theory needed to understand how and why TikTok works
% 1) IPC - We need this to argue why the deadlocks are almost impossible
% 2) VM and Page Tables - Why it exists and how it works
% 3) x86 Page Tables - Continue the discussion from the previous section
% 4) Page faults - Explain how and why they happen.
% 5) Copy to/from user - Explain why the API has been introduced
% 6) Double-fetches - Provide a high-level overview
\section{Background}
\label{sec:background}

\sysname{} orchestrates several Linux subsystems to provide its protection. It
uses \emph{page-tables} to mark \emph{shared memory} storing the system-call
arguments as \emph{read-only}. Different system-calls have different
relationships with shared memory, and interact with \sysname{} differently in
practice. This section provides the background information necessary to reason
why and how \sysname{} protects the arguments from change while enabling the
threads to execute correctly.

% I want to cover why this background is needed. IPC is the most problematic
% because it is used to justify the absence of deadlocks
\autoref{subsec:ipc} introduces two different ways of communication between
processes - \emph{shared memory} and \emph{message-passing}. \sysname{} affects
both of these methods because the arguments of the message-passing system-calls
are stored in (potentially shared) memory. The waits caused by writing to marked
pages can interact with already present synchronization primitives and cause
deadlocks. In~\autoref{subsubsec:deadlocks} we explain why they do not appear in
practice.

\autoref{subsec:vm} covers the organization of \emph{virtual memory},
\emph{page-tables} and the interface the Linux kernel uses to access the
user-space memory. This section is essential to understanding the implementation
of \sysname.

\autoref{subsec:doublefetch} details the \emph{double-fetch} bug that \sysname{}
is mitigating. It explains its cause and the different types of double-fetch bugs.


\subsection{Interprocess Communication}
\label{subsec:ipc}

The two methods of inter-process communication are  \emph{shared memory} 
and \emph{message passing}~\cite{silberschatz2018operating}.

% Intro to shared-memory
% Intro to message-passing
Shared memory relies on two processes having a section of memory that both can 
access. Processes communicate by reading and writing to the shared memory.
Message passing consists of one process calling \texttt{send}, and another one
calling \texttt{receive} to fetch the message. Synchronous message passing
blocks execution until the calls have finished.

% The state of the modern OSs and concurrent programs
Modern operating systems support both of these approaches. \sysname{} interferes
with message-passing system-calls by linking them to shared memory. Storing
arguments for blocking message-passing system-calls in shared memory can cause
deadlocks if those arguments are written to. This is discussed
in~\autoref{subsubsec:deadlocks}.

\subsection{Linux Memory Subsystem}
\label{subsec:vm}

% Paged VM and the introduction to permissions we will later use in TikTok
Linux implements \emph{paged virtual memory} and uses \emph{virtual addresses}
which map to \emph{physical addresses} in RAM. The mapping function is defined
for each process by a multi-level \emph{page-table}.

% The flags are needed to discuss marking
The leaves of the page-table store the access information about the
corresponding page:
\begin{LaTeXdescription}
    \item[Present bit (\textbf{P})] is set if the page is present in memory
    \item[Read/Write bit (\textbf{R/W})] denotes if the page is writable or just
         readable
    \item[User/Superuser bit (\textbf{U/S})] represents if the page can be 
    accessed by the user, or only by the superuser
    \item[Not Executable bit (\textbf{NX})] is set if the code stored on the 
    page cannot be executed
    \item[Page Frame Number] denotes the page frame the entry points to
    \item[\textbf{SW1-SW4}] Four bits free for the OS to use
\end{LaTeXdescription}

% Mention TLBs
Considering that the page-table traversal is frequent, it is implemented in
hardware by the \emph{memory management unit} (MMU). Reading the page-table from
memory is slow, so a small cache --- \emph{translation-lookaside buffer} (TLB)
--- is added to the MMU to store frequently accessed page entries. Kernel
developers can \emph{flush} (clear) certain TLB ranges in software.

% Explain what a page fault is, as well as COW (mentioned later as an optimization)
On invalid access (e.g., wrong permissions, page not present) the MMU will
trigger a page-fault. The page-fault handler executes in the kernel context of
the faulting thread and performs the appropriate action (e.g. load a page, kill
the thread). With the advent of cloud computing, \emph{user-space page-fault
handling} has been added to the Linux kernel. \sysname{} relies on the page-fault
handler for protection, so the user-space page-fault handling must be disabled.

% Different memory types used later to explain certain attacks
Memory in Linux can be either \emph{file-backed} or \emph{anonymous}.
File-backed pages have a backing file where their data is stored. Anonymous
pages do not have a backing file (e.g., stack and heap) and the data on them
disappear when they are unmapped.

Another classification is based on privacy: \emph{private} and \emph{shared}.
Private memory is part of only one virtual memory space. This memory space can
be accessed by multiple threads in a process, but not by other processes. Shared
memory can be accessed by different processes.

% This is the most important paragraph and a basis for one of the attacks. The
% previous two paragraphs are just the introduction
Shared file-backed pages are of interest because their content does not
disappear when they are unmapped, and they can be mapped by multiple
processes at different times. This makes them suitable for mounting elaborate
attacks on memory-marking systems.

\subsection{Copy-from-User and Copy-to-User}
\label{subsec:copy}
% The interface for communicating with the user-space and why it exists
Linux differentiates between accesses to user-space and kernel memory and
therefore uses a well-defined interface when accessing user-space memory.
User-space memory can be written to the disk and evicted from the main memory.
Accessing absent pages triggers a page-fault handler, where they are read back
to memory. Kernel memory pages are always present and triggering a page-fault
handler in the kernel is considered a serious error. The kernel uses a well-defined
interface that handles possible page-faults when accessing user-space:
\texttt{(\_\_)copy\_(from/to)\_user}, \texttt{(\_\_)(get/put)\_user},
\texttt{user\_str(cpy/len)}. When the actual implementation is not important,
this API is refered to \texttt{read\_in} and \texttt{write\_out}. \sysname{}
extends this interface to perform additional checks and the bookkeeping of
marked pages.

\subsection{Double Fetch Bugs}
\label{subsec:doublefetch}

\begin{figure}[]
  \centering
  \includegraphics[width=.85\linewidth]{img/doublefetch.pdf}
  \caption{Diagram of a double-fetch bug}
  \label{fig:doublefetch}
\end{figure}

\begin{minipage}{\linewidth}
  

\begin{lstlisting}[language=C, caption=Abridged CVE-2018-12633 Double Fetch in Linux,
                  label=code:cvedoublefetch,  breaklines=true
                  postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space},
                  numbers=left,basicstyle=\scriptsize, xleftmargin=5.0ex]
static long vbg_misc_device_ioctl(
        struct file *filp,
        unsigned int req,
        unsigned long arg)
{
  size_t size;
  struct vbg_ioctl_hdr hdr;
  void *buf;

  if (copy_from_user(&hdr, (void *)arg, sizeof(hdr))) 
    return -EFAULT;
  
  if (hdr.version != VBG_IOCTL_HDR_VERSION) 
    return -EINVAL;
   
  if (hdr.size_in < sizeof(hdr) || (hdr.size_out && hdr.size_out < sizeof(hdr)))
    return -EINVAL;
  
  ...
  
  if (copy_from_user(buf, (void *)arg, hdr.size_in)) {
		ret = -EFAULT;
		goto out;
  }

  ...

  ret = vbg_core_ioctl(session, req, buf);

  ...
}
\end{lstlisting}
\end{minipage}
% The idea behind double-fetch bugs
\emph{Double-fetch} bugs occur when a privileged environment (such as the
kernel) reads untrusted memory two or more times and the read values are not
identical (\autoref{fig:doublefetch}). In between those two reads, memory could
have been changed by an unprivileged adversary. Considering that the bug relies
on carefully timed accesses for two different threads, it is a race
condition. The situation where the first fetch validates the value of the
fetched variable, but the computation is only performed on the second fetch, is
called a \emph{time-of-check to time-of-use} (TOCTTOU) bug. TOCTTOU bugs have
been widely studied in file systems, where the API makes it possible to swap the
file after validating the access rights~\cite{payer2012protecting,
pu2006methodical, wei2010modeling, tsafrir2008portably}.

% Explain using the example
\autoref{code:cvedoublefetch} displays the double-fetch bug in the Virtual Box
drivers for the Linux kernel~\cite{cve201812633}. The first fetch occurs on line
10. The code gets the header, checks the arguments (lines 13 -- 17)
and fetches the whole argument into the variable \texttt{buf} (line 21). The new
value is then used (line 27).

% The bug and the fix
Note that the header is fetched twice --- on lines 10 and 21. This gives the
opportunity for the attacker to change the values in it. Considering
that the header is not verified the second time, the attacker can
leave the kernel in an inconsistent state. The fix for this bug
(\autoref{code:cvedoublefetchfix}) does not fetch the header the second time. It
copies the header into \texttt{buf} and the second fetch skips it.

\begin{lstlisting}[language=C, caption=CVE-2018-12633 Double Fetch Fix~\cite{cve201812633fix},
  label=code:cvedoublefetchfix,  breaklines=true
  postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space},
  numbers=left,basicstyle=\scriptsize, firstnumber=18, xleftmargin=5.0ex]
...

  *((struct vbg_ioctl_hdr *)buf) = hdr;
  if (copy_from_user(buf + sizeof(hdr), (void *)arg + sizeof(hdr), hdr.size_in - sizeof(hdr))) {
    ret = -EFAULT;
    goto out;
  }

...

\end{lstlisting}

% Double-fetches are actually so big that people have actualy spent time
% to study them
Wang et al. explain in~\cite{wang2018survey} that double-fetches appear not only
in kernels, but wherever there is a trust boundary to cross (e.g., kernel ---
hypervisor~\cite{wilhelm2016xenpwn} and hardware --- kernel
boundaries~\cite{lu2018untrusted}). Double-fetches have been responsible for many
vulnerabilities in different kernels~\cite{jurczyk2013bochspwn, wang2018survey}.


\section{Design}
\subsection{Threat Model}
\label{sec:threatmodel}

% Nothing fancy -- the adversary is just trying to hack the system
% No black magic allowed
The adversary has access to a user account on the target machine. They can
execute arbitrary code, including system-calls. Some of the system-calls
have double-fetch vulnerabilities, and the adversary wants to exploit them,
e.g., for privilege escalation.

The attacker may execute an arbitrary sequence of system-calls. \sysname{}
mitigates any unintended corruption that arises through double-fetch bugs.
Hardware attacks such as Rowhammer~\cite{mutlu2019rowhammer} or
side-channels~\cite{kocher2019spectre} are out of scope.

\subsection{TOCTTOU Attacks}

%\pra{This is too short to merit a section for itself. Section 3, 4, 5 can be merged
%together and presented under a unified heading}

% List five attacks and explain them quickly
\sysname{} needs to protect the arguments from different ways of altering the
guarded memory. Writes from user-space and the kernel are an obvious way to
alter the content of protected pages. There are also subtle ways to evade the
protection of a memory-marking system. They include different ways of altering
memory via multiple mappings or writing to a file via a system-call to alter
its mapped pages. While many of the attacks would be prevented if the
file-mapping was forbidden, such a measure would render the software unusable.
Linux relies on multiple and file mappings to provide shared-libraries and load
programs into memory.
%\pra{Aren't 'attacks' and 'ways of bypassing protections' equivalent? I suggest
%just using one term}.
The following attacks are possible:
%\pra{Before presenting attack vectors, you should reintroduce the attack itself again as you do in the intro. Something
%along the lines of:`double-fetch bugs provide opportunities for performing TOCTTOU attacks. These attacks can be mounted 
%in the following ways....`}
\begin{enumerate}
  \item \label{first} \emph{Writes from user-space} consist of a malicious
  user trying to directly write to the argument stored in memory, while the
  system-call is being executed in another thread. 

  \item \label{second} \emph{Writes from the kernel} are indirectly triggered.
  The user performs a \texttt{read} system-call with the target address as the
  destination. The data is then written to this location by the \texttt{read}
  system-call from the kernel.

  \item \label{third} \emph{Remapping file-backed pages} is accomplished by
  mapping marked pages in another process. The malicious user stores the
  arguments on a file-backed page and maps the file again as writable, while the
  system-call is executing. The user is then free to write to the new mapping,
  even though \emph{other mappings} are read-only. 

  \item \label{fourth} \emph{Writing to file-backed pages using system-calls}
  bypasses the protections present in user-space mappings by directly changing
  the data present in the files.

  \item \label{fifth} \emph{The data on a device-backed page} can change
  independently of writes. Storing arguments on such pages can result in reading
  different values from them, even if no writes occur in-between the reads.
\end{enumerate}
%\pra{As a general comment for this sec: I feel like you jump into explaining how the attacks are mounted without a lead that
%explains \emph{why} these attacks can be mounted in the first place. This problem is not as
%evident in the first two attacks because they are straightforward but there are a host of questions
%that pop up as my reading the remaining attack vectors. For eg., when explaining the file-backed pages
%vector as I am reading the questions which pop up: Why was the malicious user allowed to remap the page
%as writable? What are these \emph{other mappings} that he is talking about? Why do multiple mappings exist?
%These why's would go away IMO if you present me the system design flaw first before you explain how its
%leveraged for malicious attack.}

% Thank you Dr Watson
Watson~\cite{watson2007exploiting} in his analysis of CerbNG mentions attacks
\autoref{first}, \autoref{third} and \autoref{fourth}.

\section{\sysname{} Design}
\label{sec:design}

%\pra{Use non-breaking spaces with refs and cites like so (unless they are free standing text) e.g.,
%'main design principles in~\autoref{subsec:designprinciples}. https://github.com/HexHive/HexDump/wiki/WritingTips\#iii-latex-dos-and-donts}
We break the design of \sysname{} into three parts. \autoref{subsec:simplistic}
introduces a simple design that fails to provide the necessary protection.
In~\autoref{subsec:designprinciples} we analyze the problems
in~\autoref{subsec:simplistic} and formulate the principles behind
memory-marking systems. These principles are further discussed
in~\autoref{subsec:tempimmut} (\emph{Temporary Immutability}),
\autoref{subsec:correctness} (\emph{Correctness}) and \autoref{subsec:soundness}
(\emph{Soundness}).



%\pra{IMO the current flow between these subsections is very disjointed and all over the place.
%You introduce the strawman approach first, show problems with it, then directly jump into design principles.
%The optimal flow IMO for the design section would be as follows: (i) Motivate each of the design principles
%using the root causes behind the attack vectors and existing primitives, (ii) formally present each of the design principles
%and (iii) explain each of the design principles in detail. You already do (iii), the simplistic design section can be incorporated
%into (i)}
% Two memory marking systems that backfire.
\subsection{Simplistic Design}
\label{subsec:simplistic}

\sysname{} leverages virtual memory protections to
prevent changes to arguments during the execution of system-calls.
\sysname{} hardens the following three parts of the kernel:

\begin{itemize}
\item The page-table
\item The page-fault handler
\item The kernel interface for reading from user-space (\texttt{read\_in})
\end{itemize}

The \texttt{read\_in} function reads an argument from the user-space memory and
protects it during the execution of the call. \texttt{read\_in} must protect the
pages in \emph{all} memory spaces mapping the page. Otherwise, an adversary
could alter the argument from a different process. At the end of the call, the
guarded pages are set to the previous state if there are no other calls storing
arguments on them. The process of protecting a page by setting the appropriate
flags is called \emph{marking a page}. \emph{Unmarking} is the opposite process
when the permissions are reset to the original values.

If the adversary tries to write to a marked page, they will trigger a
page-fault exception. The page-fault handler will detect that the page is marked
by \sysname{} and force the thread to \emph{wait} until it is unmarked. The
offending write is then repeated. 

One possible way to implement marking is to make user-space pages accessible
only from the kernel.  On modern architectures this is accomplished by setting
the \emph{superuser} flag in the page-table. User-space writes to marked pages
trigger a page-fault, where they wait for the system-call to end.

Even though this system provides protection against user-space
writes to anonymous pages, it can easily be bypassed by calling a \texttt{read}
system-call. \texttt{read} executes in the kernel context and has access to 
the pages marked with the \emph{superuser} flag. The attacker can provide the
address of the marked argument as a destination of a \texttt{read} call and 
change the data. We discovered this vector after testing the early prototypes of
\sysname{}.
%\pra{This flow is awkward. Don't just explicitly call finding this vector
%a contribution. Instead, weave it in more smoothly by saying something along the lines of `We discovered....'}.

The solution is to mark pages as \emph{read-only} instead of \emph{superuser}.
In that case no system-call can change marked memory. Unfortunately, some
system-calls (e.g., \texttt{rt\_sigaction}) write to the arguments they read.
Such \emph{self-writing} system-calls will deadlock. After trying to write to the
marked page, they will wait for themselves to unmark it.
%\mat{Introduce the idea of marking/unmarking first.}

% Here we go. We need to guarantee that the pages cannot be changes, the system
% cannot be bypassed and the programs execute correctly. In reality all of these
% things "kinda" hold and the reviewers will give me hell for them.
\subsection{Design Principles}
\label{subsec:designprinciples}

The simplistic design~\autoref{subsec:simplistic} fails in several aspects. Data
can still be changed because the design does not provide any real-time
protection against arbitrary memory mapping. Users can bypass the protection by
mapping guarded pages as writable in another process (\autoref{attk:remapping}).
Self-writing calls do not execute correctly --- they deadlock when writing to
their arguments. Watson~\cite{watson2007exploiting} mentions self-writing calls
as a big problem for memory-marking systems. Finally, a malicious user can map a
device whose memory-mapped registers are independent of writes, making the
system useless (\autoref{attk:devicefiles}).

\sysname{} needs to enforce several policies to protect against double-fetches:

\begin{itemize}
  \item \label{policy:immutability} \emph{Temporary Immutability:} Pages storing
  the arguments of a system-call must be immutable after being read the first
  time
  \item \label{policy:correctness} \emph{Correctness:} Writes to protected pages
  do not affect the correct execution of threads performing them
  \item \label{policy:soundness} \emph{Soundness:} The only way to change the
  protected pages is by writing to them
\end{itemize}

If these three principles hold, the system will mitigate double-fetch bugs and
the protected programs will execute correctly.

% Nobody can change the marked pages. We mark them when the arguments are read
% and when the pages are mapped
\subsection{Temporary Immutability}
\label{subsec:tempimmut}
\emph{Temporary Immutability} of the pages storing the arguments guarantees that
fetch of the arguments will return the same data as the first one.

As described in \autoref{subsec:simplistic} \sysname{} relies on the
page-table and the page-fault handler to provide immutability. The interface for
reading from the user-space (\texttt{read\_in}) is extended to change the
permissions of the pages being read to \emph{read-only}. The pages need to be
marked in all VM spaces. Otherwise, the adversary would be able to write to the
page from a different process.

\sysname{} extends the mapping of pages to make sure the guarded pages are marked in
all processes. This protection holds even if they are mapped as writable after
being marked by another process. If the OS supports \emph{on-demand paging} the
marking should happen when the page is accessed and loaded by the process.

Temporary immutability prevents \autoref{attk:direct}, \autoref{attk:systemcall}
and \autoref{attk:remapping}.

% This is the most problematic section. Programs need to execute correctly.
\subsection{Correctness}
\label{subsec:correctness}
Self-writing system-calls are problematic for memory-marking systems, as noticed
by Watson~\cite{watson2007exploiting} and illustrated in
\autoref{subsec:simplistic}. Some system-calls rely on double-fetches and
user-space writes to the arguments to execute correctly. \sysname{} also
introduces additional synchronization points to user-space programs, making
deadlocks possible. \sysname{} preserves the correct execution of these
system-calls and user-space programs.

% The solution to the problem of a system-call marking A and writing to it.
% Nobody has done this before.
\subsubsection{Writes to User-Space}

\emph{Self-writing system-calls} are addressed by preventing them from writing
to marked pages and triggering a page-fault. When a page is marked, it is also
added to a data structure containing marked memory memory ranges for each VM
space. The interface for writing to user-space (\texttt{write\_out}) is changed
to check if it is writing to a marked page. Writes to marked pages are saved,
and executed at the end of the call, after unmarking the arguments. This
guarantees that system-calls will not wait for themselves to unmark the pages.
Watson~\cite{watson2007exploiting} stressed that no system-call
wrappers had successfully addressed this problem.

% Some calls do not like TikTok. They want to read data multiple times. They are
% ignored
\subsubsection{Ignored Calls}

\emph{System-calls that depend on double-fetches} cannot be protected by
\sysname{}, so they are \emph{ignored} --- they do not mark pages. They should
be manually inspected for bugs. Ignoring them does not diminish the protection
of other calls. Ignored calls still stop before writing to marked pages.

The best representatives are \texttt{pollfd} and \texttt{futex}. \texttt{pollfd}
checks if any of the file-descriptors in the array passed as an argument are
ready to perform I/O. The user can write \texttt{-1} to memory to indicate that
the loop in the call needs to skip the descriptor. \texttt{futex} is a mostly
user-space lock. Most of \texttt{futex} synchronization depends on atomic
user-space writes, with the system-call being performed only to awake or make
threads wait. If \texttt{futex} marks a user-space address as read-only, other
user-space threads will be incapable of unlocking the \texttt{futex} by writing
to that address. Even though they execute correctly under \sysname{},
long-lasting calls (such as \texttt{sys\_nanosleep}) should be included in this
group. Otherwise, they could keep the pages marked for long periods.

Finally --- if a system-call can be verified not to have double-fetches, it can
be ignored to improve performance. This is especially important in case of
system-calls with large arguments such as \texttt{write}.

% The big problem. Deadlocks can occur if you are insane.
\subsubsection{Preventing Deadlocks}
\label{subsubsec:deadlocks}

% Introduce the problem
\sysname{} provides its guarantees by introducing additional synchronization
points to executing programs. It does not introduce deadlocks
\begin{enumerate*}\item by interacting with itself \item by interacting with
blocking system-calls\end{enumerate*}.

% Explain why TikTok cannot cause a deadlock on its own
\sysname{} cannot cause a circular locking dependency as a consequence of its
\emph{system-call reads, system-call writes and markings}. Every dependency
involves one marked page and a write to it. A self-deadlocking execution trace
would involve a write from a system-call to a page marked by another
system-call. The other system-call would also need to write to the page marked
by the first call to complete the cycle. This situation is impossible in
\sysname{} because system-calls postpone writes to marked pages until the end of
the call, when the pages are unmarked.

% Explain what it takes to deadlock when interacting with the rest of the system
If a system-call interacts with \sysname{} to cause a deadlock, such a call can
be \emph{added to the ignore-list}. However, such calls are extremely rare.
During our evaluation we haven't encountered them. The deadlocking pattern
\autoref{fig:deadlock} requires three ingredients:

\begin{itemize}
  \item A synchronized marking call \texttt{S}
  \item Storing the arguments of \texttt{S} in shared memory \texttt{A}
  \item A thread to write to \texttt{A} while \texttt{S} is executing
  \item An already existing waits-for dependency between the thread executing
  \texttt{S} and a write
\end{itemize}

\begin{figure}
  \centering
  \begin{subfigure}[b]{0.45\linewidth}
  \begin{minipage}{\linewidth}
  \begin{lstlisting}
  1: S(A,T1);  
  \end{lstlisting}
  \end{minipage}
  \caption{Thread 1}
  \end{subfigure}
  \hfill
  \begin{subfigure}[b]{0.45\linewidth}
  \begin{minipage}{\linewidth}
  \begin{lstlisting}
  2: write(A);
  3: unblock_S(T2);
  \end{lstlisting}  
  \end{minipage}
  \caption{Thread 2}
  \end{subfigure}
  \caption{Executing instructions in the specified order causes a deadlock with \sysname}
  \label{fig:deadlock}
\end{figure}

% Explain why it is not happening
\autoref{fig:deadlock} shows an example of a deadlocking communication pattern.
Thread 1 enters the system-call \texttt{S} and marks a shared page \texttt{A}
(\textbf{1}). The system-call \texttt{S} blocks until the corresponding call
\texttt{unblock\_S} is called in Thread 2 (\textbf{3}). While the page
\texttt{A} is still marked, Thread 2 attempts to write to it, causing it to wait
for \texttt{S} to finish (\textbf{2}). All the deadlocking patterns need to
exhibit a similar combination of paired blocking calls (\texttt{S},
\texttt{unblock\_S}) with arguments in the shared memory (page \texttt{A}).

The only candidates for \texttt{S} that we have
encountered are blocking message-passing calls. They are synchronous and thus
provide the necessary waits-for dependency, and they read buffers from
user-space memory, marking pages. However, the deadlock would imply that data on
the page \texttt{A} is shared both by message-passing and shared-memory. We
haven't encountered such a pattern and there are a few reasons why it does not
occur in practice:

\begin{itemize}
  \item Most programs use only one IPC method (either message-passing or
  shared-memory)
  \item System-call arguments are usually stored on the stack, and accessed only
  by the executing thread
  \item The programs would need to use both IPC methods at the same time, on the
  same data
  \item Both system-calls and shared-memory are relatively rare in programs, and
  used in the well-defined patterns
\end{itemize}

% Another problem: If you map a file F to the page P, and then call write(F, data(P)),
% you will deadlock. Why would someone do that, I do not know.
\sysname{} adds another synchronization point to the kernel
(\autoref{subsec:soundness}) --- it prevents write calls to files having marked
mapped pages. While it is possible to deadlock a thread by mapping a file, and
then passing the mapped pages as the arguments of \texttt{write} to the same
file, we have not encountered such a case in practice. As with IPC, it is
extremely unusual to write the mapped data back to the file using a system-call.

\subsection{Soundness}
\label{subsec:soundness}

% We cannot change the marked pages in any other way than writes
\sysname{} stops all writes to marked pages to prevent changes to the arguments.
It is necessary to close off all other ways of changing data on marked pages to
show \sysname{} is \emph{sound}. We identify and disable two other ways of
changing pages --- write system-calls and device-backed pages.

% Close-off the write calls briefly mentioned in the previous subsection
Watson~\cite{watson2007exploiting} mentions that file-systems with shared
\emph{mapped memory} and \emph{write buffers} can bypass the memory-marking
protection in a \texttt{write} call. To prevent such an attack \sysname{} pauses
all writes (\texttt{vfs\_write}) to files having marked mapped pages.

% Do not mount devices
\emph{Discretionary Access Control} (DAC) can be used to prevent the mounting of
devices to user-controlled processes. Device-backed pages may have a state
independent of user actions, and even the kernel, making any form of preventing
data changes impossible. We do not consider this a flaw in \sysname{} because
users usually are not allowed to access devices directly.

With these two changes \autoref{attk:writebuffers} and \autoref{attk:devicefiles}
are prevented.


\section{Implementation}
\label{sec:implementation}

% TikTok can work almost anywhere
\sysname{} prototype has been implemented on Linux x86-64. However, \sysname{}
can be ported to any operating system that use a defined interface for reads and
writes to the user-space (\texttt{read\_in} and \texttt{write\_out}), and any
architecture that has page-tables encoding access control information. Depending
on the available resources (e.g. the number of free bits in the PTE) information
can be stored in different places (e.g., PTE or global structures).

% Describe the data structures we need for basic operation
\subsection{Basic Book-keeping}
\autoref{fig:bookkeeping} illustrates some of the most important data structures
used in the prototype --- the PTE with the permissions, the marked page metadata
(number of threads marking the page frame, number of threads waiting for the
unmarking, the reverse mapping information). 

\autoref{subsec:frameinfo} describes the data about the physical page frame with
some of the limitations due to the need to keep \texttt{struct page} as small as
possible. Considering that one \texttt{struct page} exists for every page frame
on the system, increasing its size would drastically increase the memory
overhead.  The data stored in the page table (permissions, free bits and page
frame number) is explained in more detail in \autoref{subsec:pageinfo}.

% Describe how we use the page frames and use RAM efficiently
\subsection{Storing the Page Frame Information}
\label{subsec:frameinfo}
Linux divides physical memory into page frames. Each page frame is represented
by a \texttt{struct page}. This structure is replicated millions of times and
every additional field has a tremendous impact on memory consumption.

To keep the memory consumption low, \sysname{} uses a single bit in \texttt{struct
page} to mark page frames. x86-64 has enough bits in the flag
field, so we have decided to use one of the flag bits for this purpose.
Architectures that have fewer flag bits (such as x86) can instead use some of
the bits used by other features (e.g., Kernel Shared Memory or NUMA domains). On
\autoref{fig:bookkeeping} this field is denoted by \emph{Page Marked Flag}.
\texttt{struct page} also stores a pointer to the \emph{reverse mapping}
information. The reverse mapping is used to find all PTEs \sysname{} needs to
(un)mark.

The marking metadata is stored in a hashmap based on the \emph{page frame
number}. This enables us to store only the information on the pages which are
currently marked and keep the memory consumption low. The access to these entries
is protected by separate mutexes to improve the scalability of the system. The
metadata consists of the page frame number, the count of threads marking the page
(\emph{owners}), the number of threads waiting for the page to get unmarked
(\emph{guests}), and a \emph{completion} they are waiting on. 

% The information stored in page-tables
\subsection{PTE Information}
\label{subsec:pageinfo}

When a page is marked, \sysname{} changes some of the flags in the PTEs mapping it
(\autoref{fig:bookkeeping}):

\begin{LaTeXdescription}
  \item[R/W] gets set to \emph{read-only} to prevent writes to the page
  \item[SW2] gets the old value of \textbf{R/W}
  \item[SW3] gets set to 1 
\end{LaTeXdescription}

\textbf{SW2} is used by the Software Dirty Pages
feature of Linux. This feature cannot run alongside \sysname{} in our prototype.
Other architectures may have less, or more bits, available for the OS to use. In
the case of lack of space in the page table, \texttt{SW2} and \texttt{SW3} could
be stored in a separate data structure.

\emph{Copy-on-write} pages have a peculiar optimization. They are marked only in
the process requesting the marking. Writes from other processes will trigger a
copy-on-write mechanism, preventing them from changing the data.

\sysname{} does a partial flush of the TLB and updates the MMU cache to make these
changes visible immediately. The performance impact of this is analyzed further
in \autoref{sec:evaluation}.

\begin{figure}[]
  \centering
  \includegraphics[width=\linewidth]{img/book-keeping.pdf}
  \caption{The most important marking information on x86}
  \label{fig:bookkeeping}
\end{figure}

\subsection{Marking and Unmarking}

\begin{figure}[]
  \centering
  \includegraphics[width = 0.8\linewidth]{img/copy_from_user.png}
  \caption{\texttt{copy\_from\_user} page marking}
  \label{fig:copyfromuser}
\end{figure}

\sysname{} extends Linux's interface for reading and writing to user-space. The
abstractions \texttt{read\_in} and \texttt{write\_out} introduced in
\autoref{sec:design} are implemented in Linux as \texttt{copy\_from\_user} and
\texttt{copy\_to\_user}. \sysname{} extends \texttt{copy\_to\_user} to mark the pages
before reading the data (\autoref{fig:copyfromuser}).

Marking the page involves taking the appropriate locks, denoting the physical
page frame as marked, and incrementing the number of page owners. \sysname{} then
uses the reverse mapping information to mark the page in all the VM spaces
mapping it.

Unmarking follows a similar procedure. The appropriate locks are taken, and the
number of owners is decremented. Only if no owners are marking the page
anymore, it is unmarked in all VM spaces. If threads are waiting on the
page, they are woken up. The last guest to wake up will deallocate the marking
data for the page.

% Deadlock prevention when accessing shared data structures
\subsection{Deadlock Prevention}
\label{subsec:deadlockprevention}
The implementation of \sysname{} requires many data structures to be shared
among multiple threads (pages, completions, page-tables, interval-trees \ldots).
To prevent deadlocks all locks are taken in the same order in all places they
are used. The only two locks taken in the opposite order are the
\emph{page-table lock} and the \emph{interval-tree lock}, which protects the marked
memory ranges.

% Locks are taken in opposite orders
In \texttt{copy\_to\_user}~\autoref{fig:copytouser} the interval-tree lock must
be taken first to check which memory ranges are marked. However, when marking a
page the page-table lock needs to be acquired first to locate the page-table
entry mapping the page~\autoref{fig:copyfromuser}. \sysname{} implements the
deadlock resolution mechanism where if the page-fault handler notices that the
interval-tree lock is already taken, it gets released.

% Explain the problematic case when the system-call actually waits on a marked
% page. However, if it is waiting it cannot do the exact same thing as the second
% thread and cause a deadlock. There are no waits-for cycle, only chains
The prevention mechanism leads to a way for system-calls to write and block
on marked pages. Ultimately, it cannot cause a deadlock. The thread executing
\texttt{copy\_to\_user}~\autoref{fig:copytouser} writes to a page that is not
present and releases the interval-tree lock. Right after loading the page,
another thread executes \texttt{copy\_from\_user}~\autoref{fig:copyfromuser} and
marks it. The first thread is forced to re-execute the write by the
page-fault handler. Here, the first thread is executing \texttt{copy\_to\_user}.
For the deadlock to occur it needs to execute \texttt{copy\_from\_user} in the
same manner as the second thread. Fortunately, the \texttt{copy\_to\_user}
thread is waiting for the unmarking, preventing it from executing
\texttt{copy\_from\_user} and creating a second wait dependency.

\subsection{Loading File-Backed Pages}

% When a marked page is mapped in a different VM space it is marked
% We also need to preallocate memory outside the atomic context
As described in~\autoref{sec:design}, file-backed pages need to be marked as
they are loaded to memory. On-demand paging takes place in the page-fault
handler, but invokes the functions of the file-system storing the file. \sysname{}
extends the functionality of \texttt{set\_alloc\_pte} to mark the page. The
needed structures are preallocated and passed into the \emph{atomic context} where 
\texttt{set\_alloc\_pte} is called.

When a marked page is loaded, its data is also added to the interval-tree
storing the marked memory ranges. \sysname{} takes the lock before entering the
atomic context, even though the loaded page may not be marked. The version
number of the interval-tree is incremented after adding the page, informing all
other threads that it has changed.

\subsection{Tracking Marked Ranges}

\begin{figure}[]
  \centering
  \includegraphics[width = 0.8\linewidth]{img/pagefault.png}
  \caption{\sysname's handling of the writes in the page-fault handler}
  \label{fig:pagefault}
\end{figure}

\subsection{Protecting System Call Arguments from Writes by the Kernel}
\label{subsec:kernelland}
\begin{figure}[]
  \centering
  \includegraphics[width = 0.8\linewidth]{img/copy_to_user.png}
  \caption{\texttt{copy\_to\_user} write handling}
  \label{fig:copytouser}
\end{figure}

% Before writing to user-space the kernel checks if the page is marked
\sysname{} stores the marked memory ranges for every VM space
(\texttt{mm\_struct}) in an interval tree. Before writing to the user-space,
\texttt{copy\_to\_user} (\autoref{fig:copytouser}) the lock for the marked
memory ranges tree and checks for the intersections with the destination buffer.
Writes to marked pages are stored to freshly allocated memory, along with the
destination address, and written at the end of the call.

% Explain what happens when the target page is not present
Writes to unmarked pages proceed as normal, unless the page is not present. Then
a page-fault exception happens (\autoref{fig:copytouser}). The page-fault
handler takes the page-table lock, loads the page, and restarts the write. If the
page-fault handler detects a potential deadlock, it will release the
interval-tree lock. Page-table read-lock is not exclusive, so it does not need
to be released (\autoref{fig:pagefault}).

% What happens after the fault?
\texttt{copy\_to\_user} will attempt to write to the page after exiting the
page-fault handler. In the case it is indeed marked, it will block and wait for
its unmarking. This is the only case where \sysname{} forces threads to wait in
the middle of a system-call and has been explained in
\autoref{subsec:deadlockprevention}. After the write, the thread reacquires the
lock, checks if the interval tree has changed, and restarts the write if so.

% Explain why we restart the write. Doesn't that slow the system down?
The restart of the write is necessary because any change to the interval-tree
invalidates the iterator. \sysname{} is optimized for the case of rare markings,
making \texttt{copy\_to\_user} calls that do not encounter marked pages fast
--- only one, large write occurs. The alternative is to check and write to every
page individually. Such implementation does not need to restart the write but
incurs the overhead of individually writing to pages.

\section{Evaluation}
\label{sec:evaluation}

% We want to test TikTok on programs with many threads and/or processes, and on
% programs that use many system-calls. That is where we expect to lose performance

The majority of \sysname{} executes when marking and unmarking pages in
system-calls. This overhead is also proportional to the number of VM spaces
(processes) that have the pages mapped. Benchmarks should measure the \sysname{}
overhead for the multithreaded and multiprocessed workloads, as well as the
workloads with many marking system-calls.

% Based on the previous section we have picked these benchmarks
We evaluate \sysname{} using two different benchmark suites --- NAS Parallel
Benchmark (NPB)~\cite{npb} and Phoronix Test Suite (PTS)~\cite{pts}. NPB tests
\sysname{} on multithreaded or multiprocessed CPU-bound workloads. NPB is a
suitable benchmark to measure a drop of performance due to multithreading and
multiprocessing. PTS evaluates \sysname{} on several real-world applications.
They complement NPB in that they consist of system-call heavy applications, with
varying degrees of parallelism.

% My office desktop machine and the kernel I cloned a year ago
All benchmarks have been performed on Ubuntu Server 18.04 LTS (Linux 5.4.0-rc3)
with Intel i7-9700 and 16 GB of RAM.

Three main \sysname{} profiles have been compared:
\begin{LaTeXdescription}
  \item[\sysname{} On] protects as many system-calls as possible
  \item[\sysname{} Partial] does not protect the arguments of \texttt{write} and
  its variants
  \item[\sysname{} Off] is the Linux kernel compiled without \sysname{}  
\end{LaTeXdescription}

\subsection{NAS Parallel Benchmark}
\label{subsec:npb}

% A bit more about the benchmark
\emph{NAS Parallel Benchmarks (NPB)}~\cite{npb} is a benchmark introduced by
NASA. It consists of several parallel programs using different communication
patterns. \sysname{} introduces additional synchronization points between
threads, so it should affect multi-threaded programs more than single-threaded
ones. NPB is available for multiple technology stacks for parallel programming.
\sysname{} was evaluated on \emph{OpenMP}~\cite{dagum1998openmp} and
\emph{MPI}~\cite{snir1998mpi} versions of the benchmark with workloads of class
A.

\begin{figure}[]
  \centering
  \includegraphics[width=\linewidth]{graphs/omp.png}
  \caption{\sysname{} evaluated on NPB with OMP}
  \label{fig:npbomp}
\end{figure}

\begin{figure}[]
  \centering
  \includegraphics[width=\linewidth]{graphs/mpi.png}
  \caption{\sysname{} evaluated on NPB with MPI}
  \label{fig:npbmpi}
\end{figure}

% Two variants that test either threads or processes

OpenMP~\cite{dagum1998openmp} is a compiler extension that splits the execution
to multiple threads. All threads still use the same VM space, keeping the
overhead minimal. \sysname{} was evaluated with 8 threads.

MPI~\cite{snir1998mpi} implements parallel execution by launching multiple
processes which communicate by message-passing. Due to the limitations of some
benchmarks, \sysname{} was evaluated with 16 processes.

% We interpret the results
The benchmarks have been run with \sysname{} protecting almost all calls, with
\texttt{write} disabled and without \sysname{} at all (\autoref{fig:npbomp} and
\autoref{fig:npbmpi}). Both benchmarks show no significant difference between
different setups. MPI has wider standard-error margins, probably introduced by
the heavier startup and communication. Shorter benchmarks magnify relative
differences (explaining the artifacts for \texttt{is} and \texttt{ep}).
\sysname{} does not incur a noticeable performance penalty for CPU-bound
workloads, even when they involve multiple threads/processes.

\subsection{Phoronix Test Suite}
\label{subsec:phoronix}

\begin{figure*}[]
  \centering
  \includegraphics[width=\linewidth]{graphs/phoronix.png}
  \caption{\sysname{} evaluation on Phoronix Test Suite}
  \label{fig:phoronix}
\end{figure*}

% Explain why we used it in a bit more detail
\emph{Phoronix Test Suites (PTS)}~\cite{pts} evaluates systems on real-world
software. PTS tested \sysname{} on a range of programs complementing NPB ---
from single-threaded, CPU-bound applications (OpenSSL) to multi-threaded,
multi-processed, programs with frequent system-calls (Apache).

% Explain how to read the graphs
\autoref{fig:phoronix} shows the results of the Phoronix benchmark. All results
have been normalized with respect to '\sysname{} Off'. Benchmarks marked
with an asterisk (*) measure execution time (lower is better), while others
measure performance (higher is better).

% Benchmarks which show no performance loss
Linux compilation, OpenSSL, Redis, Git and PyBench do not show a noticable
degradation in performance. These programs do not feature a lot of inter-process
communication. Even the parallelized benchmarks such as Linux kernel compilation
generate independent, non-communicating processes.

% Three benchmarks which slow down
However, the two web servers (Apache and NginX) show a significant drop in
performance (Apache -- 16.87\% and NginX -- 16.38\%) with \sysname{} protecting
all calls. Ignoring write calls improves the situation slightly (Apache --
15.64\% and NginX -- 13.41\%). \sysname{} affects parallel and applications with
numerous system-calls the most because of the marking overhead.

The IPC TCP benchmark consists two system-calls that transfer the data between
two threads. Compared to other benchmarks, IPC benchmark has fewer threads than
web-servers, but also executes a significant number of system-calls. This places
it in-between two groups with respect to the performance penalty.

\begin{figure}[]
  \centering
  \includegraphics[width=\linewidth]{graphs/apache-nginx-5.png}
  \caption{Detailed comparison of Apache and NginX performance}
  \label{fig:phoronix-apache-nginx}
\end{figure}

% More detailed results
Apache and NginX benchmarks have been executed under two more \sysname{}
profiles to judge more accurately the effect of system-calls on performance
(\autoref{fig:phoronix-apache-nginx}):

\begin{LaTeXdescription}
  \item[Frequent system-calls ignored] ignores 20 most frequent calls executed in the benchmarks, as well as \texttt{write} variants.
  \item[All system-calls ignored] does not protect any system-calls.
\end{LaTeXdescription}

Ignoring frequent system-calls leads to a smaller overhead (Apache -- 5.34\% and
NginX -- 2.77\%). The performance is almost equal to not protecting any
system-calls at all (Apache -- 2.46\% and NginX -- 2.25\%). Some overhead
remains even when \sysname is not protecting any calls because
\texttt{copy\_to\_user} protection is still active.

\begin{table*}[]
  \label{perftable}
  \centering
  \begin{tabular}{|l|l|l|l|l|}
  \hline
                                     & Apache (\sysname{} Off) & Apache (\sysname{} - No writes) & IPC (\sysname{} Off) & IPC (\sysname{} - No writes)\\ \hline
  Marking pages read-only            & 0\%    & 5.22\%          & 0\% & 0\%         \\ \hline
  Unmarking pages                    & 0\%    & 4.67\%          & 0\% & 0.94\%      \\ \hline
  Flushing Individual TLB Ranges     & 1.50\% & 6.96\%          & 0\% & 0\%         \\ \hline
  Shared Write Buffers Protection    & 0\%    & 0.05\%          & 0\% & 1.72\%      \\ \hline
  \texttt{copy\_to\_user} Protection & 0\%    & 1.93\%          & 0\% & 1.28\%      \\ \hline
  Measured Overhead                  & 0\%    & 18.56\%         & 0\% & 4.72\%      \\ \hline
  \end{tabular}
  \caption{Perf Analysis of the Benchmarks. The percentages are normalized to \sysname{} Off execution times}
\end{table*}

% I have picked two benchmarks with different behaviors and a high TikTok overhead
% They were tested on the TikTok configuration that should make the differences evident
To contrast the overhead between two different workloads Apache and IPC were
traced with \texttt{perf}. The traces were taken for the ground truth
(\sysname{} Off) and \sysname{} with writes ignored. In this setup IPC benchmark
does not incur any marking overhead, while Apache still marks pages.

% How to read the table. TLB data is already included in marking and unmarking
\hyperref[perftable]{Table I} shows how much time the programs spend in the functions
added by \sysname{}. Percentages of individual segments have been measured by
\texttt{perf}, while the total overhead is calculated from the results of the
benchmarks. TLB is flushed both during the marking and unmarking of
pages, but is included in the table as an important performance parameter.

% Explain the differences
The comparison of the Apache and IPC runs shows two very different marking
profiles. Apache spends a considerable amount of time marking and unmarking
pages, while IPC does not mark pages at all. This is a consequence of the
different system-calls used by these applications. IPC uses only \texttt{read}
and \texttt{write} calls which do not mark arguments, while Apache also invokes
marking system-calls (\texttt{accept}, \texttt{getsockname}).

% TLB flushes slow down the programs
Apache waits most of the time for the TLB signaling functions to execute.
\texttt{flush\_tlb\_mm\_range} amounts for 2.51\% (marking) and 2.16\%
(unmarking) of the total time spent executing the benchmark. Frequent TLB
flushes are expensive because the CPU needs to make sure that all the cores have
processed the signal before continuing. Flushed pages will be accessed right
afterward, leading to a TLB miss. This further inflates the overhead.

% IPC is slowed down due to the passive protection
IPC benchmark executes only \texttt{write} and \texttt{read} calls. It does not
incur any overhead on TLB flushes because none of these calls mark pages.
However, \texttt{copy\_to\_user} checks are still active, causing a noticeable
locking overhead.


\section{Related Work}
\label{sec:relatedwork}

% Static and dynamic solutions for DFs
The literature related to double-fetches can be broadly divided into two groups.
In the first group are the static solutions (\autoref{subsec:dfstatic}) that use
techniques such as source or binary analysis to detect double-fetch bugs. The
second group (\autoref{subsec:dfdynamic}) uses run-time information to detect
and (rarely) prevent double-fetches.

The most important work related to \sysname{} is the paper by
Watson~\cite{watson2007exploiting} criticizing the security of system-call
wrappers (\autoref{subsec:watson}).

% Go over Watson's paper. Tell everyone he found lots of problems and that we
% fixed all of them
\subsection{Watson's Critique of System Call Wrappers}
\label{subsec:watson}
Watson's paper~\cite{watson2007exploiting} scrutinized the security of many
system-call wrappers. Not only did he find that all of them were insecure,
Watson also described the different types of TOCTTOU bugs that compromised them
and discussed potential fixes. In a short paragraph, he mentions that Pawel
Dawidek, the creator of CerbNG~\cite{zak_frasunek_dawidek}, has experimented
with marking arguments read-only. CerbNG was an early system-call filtering
system for BSD that used copy-on-read-and-write to a new memory page.

Afterward, Watson briefly discusses problems such memory marking systems
need to solve: 
\begin{itemize}
    \item unnecessary page-faults
    \item bypassing memory marking using IO system-calls
    \item mapping shared memory with different permissions
    \item handling system-calls that both read and write to the same memory
\end{itemize}

According to Watson, no memory-marking system (including CerbNG) addressed all
of these problems. \sysname{} does exactly that. Unnecessary page-faults are
rare and they are used to make the offending threads wait for unmarking. After
the page has been unmarked, the write proceeds without any consequences. Write
system-call does not proceed until there are no marked pages of the file.Pages
are marked when they are mapped if needed. \sysname{} postpones all writes to
marked pages coming from the kernel while allowing the system-calls to execute
correctly.

% Static analysis --- Good at finding bugs, you do not need to run the code.
% It does not find DFs in binaries and it does not fix bugs
\subsection{Static Analysis Work}
\label{subsec:dfstatic}
Static analysis techniques analyze the source code to find double-fetch bugs.
Wang et al.~\cite{wang2017double} used pattern matching to find potential
double-fetches. They implemented a tool that patches certain double-fetches
automatically. However, their method in the general case produces false
positives that need to be inspected manually. Xu et al.~\cite{xu2018precise}
improved on this work by proposing Deadline. Deadline does not use the pattern 
analysis on the source files to detect double-fetches, but a compiler's
intermediate representation and constraint solving to eliminate false positives.

Static analysis techniques such as these have the benefit of being able to find
bugs in the code that cannot be run (e.g., missing hardware to test the
drivers). However, they are meant for bug detection, not mitigation. Even though
the tools can fix some bugs automatically, this is not always possible. The
TOCTTOU bug is in the system-call wrappers by design. Double-fetches not visible
in the source, nor in the intermediate representation are another problem.
Compilers can introduce such invisible double-fetches when allocating registers
to variables. \sysname{} works even in such cases.

% Dynamic analysis --- You are limited to the code you can run. You can find
% DFs introduced by compilers. Schwartz and al. have an amazing idea to mitigate
% DFs using TSX. Unfortunately, TSX limits the protected code quite a bit
\subsection{Dynamic Analysis Work}
\label{subsec:dfdynamic}
Google Project Zero's Bochspwn~\cite{jurczyk2013bochspwn} uses an emulator to
detect double-fetches. It found a large number of bugs in the Windows kernel.
Bochspwn works on binaries. It does not require access to the source code and it
detects bugs introduced by compilers. DFTracker~\cite{wang2019dftracker} is
another dynamic analysis technique work with a lower overhead, that relies on
taint tracking. However, these dynamic techniques are limited to the detection
of double-fetches. Similar to work presented in \autoref{subsec:dfstatic},
developers need to manually fix the bugs. However, with dynamic analysis a
double-fetch must also be executed, limiting this technique to the core kernel
and to the drivers with the available hardware.

A big leap in dynamic analysis techniques has been presented by Schwartz et
al.~\cite{schwarz2018automated}. The first part of the paper introduces DECAF
--- a framework that uses side-channel attacks to create a fuzzing oracle for
double-fetch bugs. While Bochspwn relies on emulation, slowing the execution
significantly, DECAF runs natively. It also eliminates false positives by
automatically exploiting found bugs.

Schwartz et al. then discuss a real-time mitigation technique for double fetches
--- DropIt. DropIt uses Intel's \emph{Transactional Synchronization Extensions}
(TSX)~\cite{intel64and} in a creative way to prevent double-fetch bugs. By
encapsulating the code in a TSX transaction, writes from other threads will
result in the transaction being aborted. However, the code executing inside a
TSX transaction is severely limited. All reads must fit in the L3 cache, and all
writes in L1. Some instructions are also forbidden. \sysname{} has none of those
limitations. It works on non-Intel processors and relies on page tables for
protection --- a technique that has been present for several decades.

% We can port TikTok to other systems and arches, use it to protect filters,
% maybe even optimize it a bit
\section{Discussion}
\label{sec:discussion}
\sysname{} can be ported to any kernel that accesses the user-space through a
well-defined interface, and any computer architecture that features page-tables.
Android devices frequently have binary-only drivers and porting \sysname{} to 
ARM would provide additional safety guarantees.

Current system-call filters~\cite{landlock,krsi} solve the TOCTTOU bug by
implementing as Linux Security Module (LSM)~\cite{morris2002linux} hooks. For
the filters to work, LSM hooks need to be present in drivers. Even then the
undesired behavior may manifest before a hook is encountered. Integration of
\sysname{} with an existing system-call wrapper would solve the TOCTTOU bug.
SecComp~\cite{seccomp} and eBPF~\cite{ebpf} are the obvious candidates that
would benefit from such an extension. \sysname{} performance would also be
improved by marking only the pages that are read by the filter in the system
call wrapper.

The performance of \sysname{} for multithreaded, system-call heavy applications
is low due to the marking overhead. A possibility of batching TLB
flushes for multiple pages should be explored as a possible optimization.

\section{Conclusion}
% Abstract Ctrl+C Ctrl+V
\sysname{} mitigates double-fetch bugs in system-calls by using page-tables. It
works both on the core kernel, and drivers, even when their source code is not
available. It can be ported to any architecture that uses page-tables, and any
kernel that has a well-defined interface to access user-space memory. \sysname{}
is tested in practice on a modern system (Ubuntu Server 18.04 LTS) with complex
programs running (\texttt{systemd}, \texttt{gcc}, \texttt{Apache} \ldots). When
protecting rare system-calls it shows an overhead of 2-4\%, which raises to
~20\% when protecting almost all calls in multithreaded, system-call intensive
programs. CPU-bound programs do not have a significant overhead, even if they
use multiple threads.
%-------------------------------------------------------------------------------
%\section*{Acknowledgments}
%-------------------------------------------------------------------------------

%-------------------------------------------------------------------------------
\section*{Availability}
%-------------------------------------------------------------------------------

The source code of TikTok is available at LINK. It has been released under the
GNU Public Licence.

%-------------------------------------------------------------------------------
\bibliographystyle{plain}
\bibliography{\jobname}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%  LocalWords:  endnotes includegraphics fread ptr nobj noindent
%%  LocalWords:  pdflatex acks
