\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts

% to be able to draw some self-contained figs
\usepackage{tikz}
\usepackage{amsmath}

\usepackage{listings}
\usepackage{parcolumns}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}


\usepackage{hyperref}

\renewcommand\sectionautorefname{Section}  
\renewcommand\subsectionautorefname{Subsection}
\renewcommand\itemautorefname{Attack}
\renewcommand\figureautorefname{Figure}
\renewcommand\tableautorefname{Table}

% Comment macros
\newcommand{\uros}[1]{\textcolor{pink}{\textbf{UT:} #1}}
\newcommand{\pra}[1]{\textcolor{blue}{\textbf{PS:} #1}}
\newcommand{\nb}[1]{\textcolor{green}{\textbf{NB}: #1}}
\newcommand{\mat}[1]{\textcolor{red}{\textbf{Mat:} #1}}
\newcommand{\evalfull}[1]{20}
\newcommand{\evalnocalls}[1]{3}
\newcommand{\sysname}{TikTok}
\newcommand{\roughevaloverheadbad}{18\%}
\newcommand{\roughevaloverheadbetter}{2-4\%}



%-------------------------------------------------------------------------------
\begin{document}
%-------------------------------------------------------------------------------

%do not want date printed
\date{}

% make title bold and 14 pt font (Latex default is non-bold, 16 pt)
\title{\Large \bf TikTok: Kernel TOCTTOU Protection}

%for single author (just remove % characters)
\author{
Anonymous submission \#TODO to Security & Privacy '21
%{\rm Eric Tusso}\\
%EPFL
%\and
%{\rm Yamaha Priest}\\
%EPFL
% copy the following lines to add more authors
% \and
% {\rm Name}\\
%Name Institution
} % end author

\maketitle

%-------------------------------------------------------------------------------
\begin{abstract}
%-------------------------------------------------------------------------------

Double-fetch bugs have been discovered in all major operating systems.
They occur when the data has been fetched across the trust-boundary the second
time without verifying that it has not changed. This leaves the kernel in an
inconsistent state, making it possible to access illegal memory, deny service and
even escalate privilege.

Today, the solution for double-fetches is to detect and fix them. However, they
exhibit illegal behavior only under specific conditions, making the detection
hard. Even then, the actual fixes may not address the problem. Finally, the bug
could be in the code that cannot be changed (e.g. binary blob), rendering this
approach useless. We propose \sysname{} --- the mitigation for double-fetches.
\sysname{} relies on page-tables to prevent changes to the system call arguments,
while the call is executing.

\sysname{} shows no noticable drop of performance when evaluated on CPU-bound
workloads. On workloads with a large number of system calls, \sysname{} shows
\roughevaloverheadbetter{} overhead when protecting rare system calls, and
\roughevaloverheadbad{} when all of the system calls are secured.


\end{abstract}

\begin{IEEEkeywords}
Double-fetch bugs, TOCTTOU, kernel security, page-tables, mitigation
\end{IEEEkeywords}

% Talk about the system call filters and how they can be used for good
% Introduce the main problem - TOCTTOU
% Brag how our system is the best thing since sliced bread
\section{Introduction}


% Syscalls are a lucrative attack surface for adversaries which needs to be protected
To improve security, systems are partitioned into \emph{untrusted} and a
\emph{trusted} zones by a \emph{trust boundary}. All data that crosses the trust
boundary from the untrusted zone must be verified.
Double-fetches~\cite{serna08doublefetch, twizsgrakky07ring0, wilhelm2016xenpwn,
wang2018survey} occur when a higher-privileged code (e.g., the kernel) reads the
same data twice from the lower-privileged space (e.g., user-space). In-between
the two reads, the data could have been changed concurrently. This makes
double-fetches a type of a \emph{race condition} between the two threads of
different privileges. \emph{Time-of-check to time-of-use (TOCTTOU)} occurs when
the first read is used in a check, while the second one is used in computation.
Many double-fetch bugs have been found in different kernels and
hypervisors~\cite{cve201812633, cve202012652, cve20131332, cve201920610,
cve20158550, cve201610439, cve201610435, cve201610433, cve20195519,
cve20168438}. Considering that double-fetches frequently appear in drivers,
legacy systems with binary-only drivers cannot be patched, even if a bug is
found. Furthermore, Watson~\cite{watson2007} blames an unfixable TOCTTOU bug as
a reason for the insecurity of \emph{system call wrappers}. A system that
mitigates double-fetches in system calls is needed to protect the kernel in case
the bugs cannot be fixed.


% Define our goal
A system that mitigates double-fetches needs to:
\begin{enumerate}
  \item Prevent the change of the user memory accessed by the system call
  \item Enable correct system call execution
  \item Enable correct execution of threads trying to change the arguments
\end{enumerate}


% Cover the first point
Double-fetch bugs occur when an adversary invokes a system call with arguments
stored in memory. The kernel will read the arguments the first time and perform
corresponding checks. If the timing is perfect, the adversary can use the
additional thread under their control to change the arguments, right after the
checks have been finished. In case of the double-fetch bug, the kernel
will read the data again and presume that it has not changed.

The main issue is the adversary changing the values in memory, while the system
call was still executing. \sysname{} mitigates double-fetch bugs by preventing the
adversary from writing to the arguments, until the end of the system call. This
is accomplished by extending the API for reading from user-space The pages
containing arguments are marked in the \emph{system page table} as
\emph{read-only}. All of the writes to those pages trigger a \emph{page-fault}
and execute a \emph{page-fault handler}. In the handler, the offending threads
wait for all the system calls to finish, before continuing execution. \sysname
thus prevents the changes to the system call arguments.

% Cover the second point. Mention the calls for which it makes no sense to protect
Preventing writes from user-space is not enough to guarantee immutability of arguments.
The adversary can invoke system calls which write to memory and force the kernel
to perform the write for them. The protection against kernel writes is necessary
as well.

Unfortunately, some system calls both read from and write into the same memory.
Such calls need to be able to write to the pages only they have marked, and no
other pages. To accomodate such calls, we extend the API for writing to user
space to save and defer the writes into the marked pages until the end of the
call. At that time, they can be either successfully performed, or safely wait
for other system calls to exit and unmark the pages.

By introducing these changes to the API for reading from and writing into userspace,
system calls have a view of memory similar to transactions. \sysname{} freezes the
value of all addresses at the moment they were read the first time by the call. 
The writes to marked pages also become visible only at the end of the call. 

A small subset of system-calls (e.g. \texttt{pollfd}, \texttt{futex}) depend on
the writes from user-space or double-fetches for the correct behavior. Similarly,
system calls that read memory and potentially take a long time to execute will
keep those pages marked during their execution. \sysname{} must be disabled for
such calls and they need to be manually inspected for double-fetches.

By changing the view of the memory that system calls have and ignoring certain
calls, \sysname{} guarantees the correct execution of the system with the
protections enabled.

% Cover the third point
Writes from the user-space will trigger a \emph{page-fault handler} where they
wait for the unmarking. All the offending threads pause execution.
After all the system calls exit, the threads waiting for them to free arguments
continues the execution by repeating the write. All of them will execute 
--- after a short delay.

% Introduce TikTok
We present \sysname{} --- a memory marking extension to the Linux kernel. \sysname{}
provides system-calls with a view of the memory frozen at the time it
has been read the first time. \sysname{} also groups all the writes that could
modify protected memory and executes them at the end of the call. By mitigating
double-fetches, \sysname{} provides protection even against the double-fetch bugs
in the drivers which are not maintained anymore. Furthermore, \sysname{}
renders previously unavoidable double-fetches (such as a TOCTTOU in
system-call wrappers) completely benign. \sysname{} works on modern
Linux distributions (Ubuntu Server 18.04 LTS) and doesn't require any
modifications to the user programs. It can be implemented in other kernels
and architectures which use page-tables and a well defined API to communicate
with the user space (\texttt{read\_in} and \texttt{write\_out} abstractions).

% Sneak-peek into the results
Benchmarking \sysname{} showed that multithreaded programs with lots of marking
system-calls, such as Apache and NginX, suffer an \roughevaloverheadbad{} drop in
performance with \sysname{} protecting almost all the system-calls. By reducing
the number of protected calls, the overhead drops to \roughevaloverheadbetter{}.
CPU-bound programs showed almost no performance drop when using \sysname{}, even
when they used multiple threads (OMP) and message passing (MPI).



% Three new things in this paper
The main contributions of this paper are:


\begin{itemize}
\item A technique how to temporarily prevent the change of memory by safely
      postponing both userspace and kernel writes
\item \sysname{} --- a mitigation for the double-fetch and TOCTTOU attacks on system
      call arguments in the Linux kernel
\end{itemize}

% Cover the theory needed to understand how and why TikTok works
% 1) IPC - We need this to argue why the deadlocks are almost impossible
% 2) VM and Page Tables - Why it exists and how it works
% 3) x86 Page Tables - Continue the discussion from the previous section
% 4) Page faults - Explain how and why they happen.
% 5) Copy to/from user - Explain why the API has been introduced
% 6) Double-fetches - Provide a high-level overview
\section{Background}
\label{sec:background}

\sysname{} relies on multiple Linux subsystems to provide its protection. It uses
\emph{page-tables} to mark \emph{shared memory} storing the system call
arguments as \emph{read-only}. Different system calls have different
relationships with shared memory, and interact with \sysname{} differently in
practice. This section provides the background information necessary to reason
why \sysname{} protects the arguments from change while enabling the threads to
execute correctly.

% I want to cover why this background is needed. IPC is the most problematic
% because it is used to justify the abscence of deadlocks
\autoref{subsec:ipc} introduces two different ways of communication between
processes - \emph{shared memory} and \emph{message-passing}. \sysname{} affects
both of these methods because the arguments of the message-passing system calls
are stored in (potentially shared) memory. If \sysname{} marks message-passing
system-call arguments, this introduces additional synchronization points (waits)
when writing to them. The new waits can interact with already present
synchronization primitives to cause deadlocks. In \autoref{sec:deadlocks} we
explain why they do not appear in practice.

\autoref{subsec:vm} covers the organization of \emph{virtual memory},
\emph{page-tables} and the interface the Linux kernel uses to access the
user-space memory. This section is essential to understanding the implementation
of \sysname.

\autoref{subsec:doublefetch} details the \emph{double-fetch} bug that \sysname{}
is mitigating. It explains its cause and the different types of double-fetch bugs.


\subsection{Interprocess Communication}
\label{subsec:ipc}

The two main types of communication between processes are \emph{shared memory} 
and \emph{message passing}~\cite{silberschatz2018operating}.

% Intro to shared-memory
Shared memory relies on two processes having a section of memory that both can 
access. Data transfer is fast, but the synchronization is problematic. 
Processes must monitor shared memory for changes, leading to unnecessary
polling.

% Intro to message-passing
Message passing consists of one process calling \texttt{send}, and another one
calling \texttt{receive} to fetch the message. Synchronous message passing
blocks execution until the calls have finished.
% The state of the modern OSs and concurrent programs
Modern operating systems support both of these approaches. \sysname{} interferes
with message-passing system calls by linking them to shared memory. Marking the
arguments adds additional synchronization points that can interact with the
blocking semantics of some system calls.

\subsection{Linux Memory Subsystem}
\label{subsec:vm}

% Paged VM and the introduction to permissions we will later use in TikTok
Linux implements \emph{paged virtual memory} and uses \emph{virtual addresses}
which map to \emph{physical addresses} in RAM. The mapping function is defined
for each process by a multi-level \emph{page-table}.

\begin{figure}[]
  \centering
  \includegraphics[width = .35 \textwidth]{img/pagetable.pdf}
  \caption{Page Table Structure on x86. Only relevant data has been included.}
  \label{fig:pagetable}
\end{figure}
x86-64 architecture officially supports paged virtual memory model with a 5 
level page table (\autoref{fig:pagetable}):
\begin{LaTeXdescription}
    \item[PGD] Page Global Directory
    \item[P4D] Page Fourth-level Directory
    \item[PUD] Page Upper Directory
    \item[PMD] Page Middle Directory
    \item[PTE] Page Table Entry
\end{LaTeXdescription}

% The flags are needed to discuss marking
Every level corresponds to eight bits in the virtual address, with the remaining twelve
bits identifying the offset in the actual page frame. A page table entry
includes the following information:
\begin{LaTeXdescription}
    \item[Present bit (\textbf{P})] is set if the page is present in memory
    \item[Read/Write bit (\textbf{R/W})] denotes if the page is writable or just
         readable
    \item[User/Superuser bit (\textbf{U/S})] represents if the page can be 
    accessed by the user, or only by the superuser
    \item[Not Executable bit (\textbf{NX})] is set if the code stored on the 
    page cannot be executed
    \item[Page Frame Number] denotes the page frame the entry points to
    \item[\textbf{SW1-SW4}] Four bits free for the OS to use
\end{LaTeXdescription}

Considering that the page-table traversal is frequent, it is implemented in
hardware by the \emph{memory management unit} (MMU). Reading the page-table from
memory is slow, so a small cache --- \emph{translation-lookaside buffer} (TLB)
--- is added to the MMU to store frequently accessed page entries. On modern
processors, a TLB consists of several levels, and can even be backed by another
MMU cache. Kernel developers can \emph{flush} (clear) certain TLB ranges in
software.

% Explain what a page fault is, as well as COW (mentioned later as an optimizaiton)
On an invalid access (e.g., wrong permissions, page not present) the MMU will
trigger a page-fault. The page-fault handler executes in the kernel context of
the faulting thread and performs the appropriate action (e.g. load a page, kill
the thread). With the advent of cloud computing, \emph{user-space page-fault
handling} has been added to the Linux kernel. \sysname{} relies on the page-fault
handler for protection, so the user-space page-fault handling must be disabled.

Memory in Linux can be either \emph{file-backed} or \emph{anonymous}.
File-backed pages have a map to the corresponding file. Anonymous pages do not
have a backing file (e.g., stack and heap).

Another classification is based on privacy: \emph{private} and \emph{shared}. 
Private memory is part of only one virtual memory space. This memory space can 
be accessed by multiple threads in a process, but no threads outside the process
have access. Shared memory can be accessed by different processes.

% This is the most important paragraph and a basis for one of the attacks. The
% previous two paragraphs are just the introduction
Unlike private memory and shared anonymous memory, shared file-backed memory can
be \emph{mapped and unmapped at will}. Its content is backed by a file, so the
data is \emph{preserved} between (un)mappings.

\subsection{Copy-from-User and Copy-to-User}
\label{subsec:copy}

Linux user a well-defined interface to communicate with the user-space:
\texttt{(\_\_)copy\_(from/to)\_user}, \texttt{(\_\_)(get/put)\_user},
\texttt{user\_str(cpy/len)}. When the actual implementation is not important,
this API is refered to \texttt{read\_in} and \texttt{write\_out}.

The abstraction is needed due to different handling of page-faults in user-space
and in the kernel. User-space memory can be \emph{paged-out} to the disk and
trigger a page-fault on access. However, kernel memory is never paged-out and
does not cause page-faults. All the user-space pointers in the kernel are
processed by this limited set of functions that know how to handle page-faults.

\sysname{} extends this interface to perform additional checks and the bookkeeping
of marked pages.

\subsection{Double Fetch Bugs}
\label{subsec:doublefetch}

\begin{figure}[]
  \centering
  \includegraphics[width=.85\linewidth]{img/doublefetch.pdf}
  \caption{Diagram of a double-fetch bug}
  \label{fig:doublefetch}
\end{figure}

\begin{lstlisting}[language=C, caption=Abridged CVE-2018-12633 Double Fetch in Linux,
                  label=code:cvedoublefetch,  breaklines=true
                  postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space},
                  numbers=left,basicstyle=\scriptsize, xleftmargin=5.0ex]
static long vbg_misc_device_ioctl(
        struct file *filp,
        unsigned int req,
        unsigned long arg)
{
  size_t size;
  struct vbg_ioctl_hdr hdr;
  void *buf;

  if (copy_from_user(&hdr, (void *)arg, sizeof(hdr))) 
    return -EFAULT;
  
  if (hdr.version != VBG_IOCTL_HDR_VERSION) 
    return -EINVAL;
   
  if (hdr.size_in < sizeof(hdr) || (hdr.size_out && hdr.size_out < sizeof(hdr)))
    return -EINVAL;
  
  ...
  
  if (copy_from_user(buf, (void *)arg, hdr.size_in)) {
		ret = -EFAULT;
		goto out;
  }

  ...

  ret = vbg_core_ioctl(session, req, buf);

  ...
}
\end{lstlisting}
% The idea behind double-fetch bugs
\emph{Double-fetch} bugs occur when a privileged environment (such as the
kernel) reads untrusted memory two or more times and the read values aren't
identical. (\autoref{fig:doublefetch}) In between those two reads, memory could
have been changed by an unprivileged adversary. Considering that the bug relies
on carefully timed accesses for two different threads, it is a variant of a race
condition. The situation where the first fetch validates the value of the
fetched variable, but the computation is only performed on the second fetch, is
called a \emph{time-of-check to time-of-use} (TOCTTOU) bug. TOCTTOU bugs have
been widely studied in file systems, where the API makes it possible to swap the
file after validating the access rights~\cite{payer2012protecting,
pu2006methodical, wei2010modeling, tsafrir2008portably}.

\autoref{code:cvedoublefetch} displays the double-fetch bug in the Virtual Box
drivers for the Linux kernel~\cite{cve201812633}. The first fetch occurs on line
10. The program performs gets a header, checks the arguments (lines 13 -- 17)
and fetches the whole argument into the variable \texttt{buf} (line 21). The new
value is then used (line 27).

Note that the header is fetched twice --- on lines 10 and 21. This gives the
opportunity for the attacker to change the values in it. Considering
that the header isn't verified the second time, the attacker can
leave the kernel in an inconsistent state. The fix for this bug
(\autoref{cvedoublefetchfix}) doesn't fetch the header the second time. It
copies the header into \texttt{buf}, while the second fetch skips reading the header
again.

\begin{lstlisting}[language=C, caption=CVE-2018-12633 Double Fetch Fix,
  label=code:cvedoublefetchfix,  breaklines=true
  postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space},
  numbers=left,basicstyle=\scriptsize, firstnumber=18, xleftmargin=5.0ex]
...

  *((struct vbg_ioctl_hdr *)buf) = hdr;
  if (copy_from_user(buf + sizeof(hdr), (void *)arg + sizeof(hdr), hdr.size_in - sizeof(hdr))) {
    ret = -EFAULT;
    goto out;
  }

...

\end{lstlisting}

% Double-fetches are actually so big that people have actualy spent time
% to study them
Wang et al. explain in \cite{wang2018survey} that double-fetches appear not only
in kernels, but wherever there is a trust boundary to cross (e.g., kernel ---
hypervisor~\cite{wilhelm2016xenpwn} and hardware --- kernel
boundaries~\cite{lu2018untrusted}). Double-fetches have been responsible for many
vulnerabilities in different kernels~\cite{jurczyk2013bochspwn, wang2018survey}.


\section{Threat Model}
\label{sec:threatmodel}
% Explain generally how TikTok works. We mention all the problems that
% TikTok needs to mitigate: writes from user-space, writes from the kernel, safely
% stopping the writes, preventing bypass using file-backed pages, system calls
% that are ignored. The most important part is showing the conditions for 
% introducing deadlocks
The adversary has access to a user account on the target machine. They can compile
and execute arbitrary code, including system calls. Some of the system calls
have double-fetch vulnerabilities, and the adversary wants to exploit them for
privilege escalation.

\section{TOCTTOU Attacks}

\sysname{} needs to protect the arguments from different types of attacks and ways of
bypassing the protections. The following attacks are possible:

\begin{enumerate}
  \item \label{first} Writes from user-space
  \item \label{second} Writes from the kernel
  \item \label{third} Remapping file-backed pages as writable
  \item \label{fourth} Writing to file-backed pages using system calls
  \item \label{fifth} The changing values of device-backed pages
\end{enumerate}

Watson~\cite{watson2007exploiting} in his analysis of CerbNG mentioned attacks
\autoref{first}, \autoref{third} and \autoref{fourth}.

\subsection{User-Space Writes}

\emph{Writes from user-space} consist of the malicious user trying to directly
write to the argument stored in memory, while the system-call is being executed
in another thread. The protection should stop the write from being visible in
the call, but the write should still occur eventually.

\subsection{Kernel Writes}

\emph{Writes from the kernel} are indirectly triggered. The user performs a
\texttt{read} system-call with the target address as the destination. The data
is then written to this location by the \texttt{read} system-call from the
kernel. The protection should prevent the write from being visible in the
marking system call, but \texttt{read} should still execute eventually.

\subsection{Remapping File-Backed Pages}

\emph{Remapping file-backed pages} is accomplished by mapping marked pages in
another process. The malicious user stores the arguments on a file-backed page
and maps the file again as writable, while the system call is executing. The
user is then free to write to the new mapping, even though \emph{other mappings}
are read-only.

\begin{enumerate}
  \item Map a file \texttt{F} in the process \texttt{A} to a page \texttt{P}
  \item Execute a system-call with the arguments placed on \texttt{P}
  \item The first fetch in the system-call occurs
  \item Map the file \texttt{F} as writable in the process \texttt{B}
  \item Change the values of the arguments on \texttt{P}
  \item The second fetch in the system-call occurs
\end{enumerate}

The protection should make sure that all mappings of a marked page are \emph{always}
marked as read-only.

\subsection{Writing to File-Backed Pages Using System Calls}

Files in Linux can be accessed in two ways:
\begin{itemize}
    \item by mapping the file to memory
    \item by using the system calls to modify the file (e.g., \texttt{write})
\end{itemize}

If the file-system allows the destination pages of the \texttt{write} call to be
mapped to user-space, it is possible to write to them using the \texttt{write}
call. This will completely bypass the user-space permissions and change the data
in the pages.

\subsection{Device-Backed Pages}

The data in the pages that represent devices can change independently of writes.
Storing arguments on such pages can result in reading different values from them,
even if no writes occur in-between the reads.

\section{Design}
\label{sec:design}

In this section we introduce the design of \sysname{} and iteratively improve
upon it. The main idea is introduced in \autoref{subsec:mainmechanism}. It is
subsequently developed in \autoref{subsec:simplistic} and further improved in
\autoref{subsec:complex}. Modifications that prevent the bypass using
file-backed pages are described in \autoref{subsec:fileprot}. Finally, the
system calls that cannot be protected using memory-marking are discussed in
\autoref{subsec:ignoredcalls}.

\subsection{The Main Protection Mechanism}
\label{subsec:mainmechanism}

The main idea behind \sysname{} is to leverage the virtual memory protections to
prevent changes to user-space arguments during the execution of system calls.
The three most important parts of the system are:

\begin{itemize}
\item The page-table
\item The page-fault handler
\item The kernel interface for reading from user-space (\texttt{read\_in})
\end{itemize}

The \texttt{read\_in} function reads an argument from the user-space memory and
\emph{marks} those pages as unavailable during the execution of the call.
\texttt{read\_in} must mark the pages in \emph{all} memory spaces mapping the
page. Otherwise, an adversary could alter the argument from a different process.
At the end of the call, the marked pages are \emph{unmarked} if there are no
other calls marking them.

If the adversary tries to write to the marked page, they will trigger a
page-fault exception. The page-fault handler will detect that the page is marked
by \sysname{} and force the thread to \emph{wait} until it is unmarked. The
offending write is then repeated. 


\subsection{Simplistic Designs}
\label{subsec:simplistic}
The easiest way to implement the protection from \autoref{subsec:mainmechanism}
is to mark user-space pages as accessible only from the kernel. On modern
architectures this is accomplished by setting the \emph{superuser} flag in the
page-table. User-space writes to marked pages trigger a page-fault, where they
wait for the system call to end.

Even though a system like this provides the protection from user-space
writes to anonymous pages, it can easily be bypassed by calling a \texttt{read}
system call. \texttt{read} executes in the kernel context and has access to 
the pages marked with the \emph{superuser} flag. The attacker can provide the
address of the marked argument as a destination of a \texttt{read} call and 
change the data.

The solution is to mark pages as \emph{read-only} instead of \emph{superuser}.
In that case no system call will be able to change marked memory. Unfortunately,
some system calls (e.g. \texttt{rt\_sigaction}) write to the arguments they
read. Such \emph{self-writing} calls will deadlock. After trying to write to the
marked page, they will wait for themselves to unmark it. A more complex solution
is required to implement a memory-marking system.


\subsection{Protecting Anonymous Pages}
\label{subsec:complex}

Deadlocks in self-writing calls in \autoref{simplistic} are a consequence of
writing to a marked page. To accomodate such behavior, \sysname{} needs to also
extend the kernel interface for writing to the user-space (\texttt{write\_out})
and to keep track which memory ranges are marked for \emph{each virtual memory
(VM) space}.

When marking a page, in addition to marking it as read-only in all VM spaces
mapping it, \sysname{} records it as a marked memory range for that VM space.
When \texttt{write\_out} is called, it checks whether it is writing to a marked
page. Writes to non-marked pages execute normally. Writes to marked pages are
postponed. They are saved and executed chronologically at the end of the system
call, after unmarking the pages. If the pages are still marked by another call,
the thread will trigger a page-fault handler when writing to them, and safely
wait for their unmarking.

This design requires locks to synchronize accesses to shared data structures for
each VM space:
\begin{itemize}
  \item Page-table
  \item Marked memory ranges
\end{itemize}

When marking a page, \sysname{} iterates over all the page-table entries in
different VM spaces mapping the page. A page-table lock is taken to access the
page-table. After marking a page-table entry, another lock is taken to add it to
the marked memory ranges for that VM space.

However, when writing to user-space memory in \texttt{write\_out}, a different
order must be observed. The lock for marked memory ranges is taken first to
ensure the thread is not writing to a marked page. Swapped-out pages are not
marked. Writing to them triggers a page-fault handler and aquires a page-table
lock.

Taking two locks in the opposite ordering leads to deadlocks. To prevent
deadlocks in the \sysname{} implementation, we use a deadlock resolution
mechanism. When a thread notices a deadlock it releases its locks, preventing a
it.

\subsection{Protecting File-Backed Pages}
\label{subsec:fileprot}

The previous design protects against changes to marked \emph{anonymous} pages. It is
still possible to bypass these protections if \emph{file-backed} pages are used.
Watson~\cite{watson2007exploiting} described two ways to bypass such a system.
They correspond to attacks \autoref{third} and \autoref{fourth}. The system from
\autoref{complex} can easily be extended to defend against them.

The attack \autoref{third} is possible because file-backed pages can be mapped
at will in different VM spaces. This enables the adversary to map them as
writable, even though they are marked as read-only in another process. The 
solution is to check if they are marked during mapping and adjust the permissions
in the page-table entry. In case of \emph{on-demand paging} the check is performed
when the page is loaded.

Another attack described (\autoref{fourth} by Watson~\cite{watson2007exploiting}
is to use a \texttt{write} system call. This is possible if pages mapped in
user-space are the same as the buffers used as the destination for the
\texttt{write}. \sysname{} prevents these attacks by forcing \texttt{write} to
wait for all mapped pages in the destination file to be unmarked.

The final attack (\autoref{fifth}) requires the protection against changes in
\emph{device-backed} pages. These changes are not caused by writes and cannot be
mitigated by \sysname{}. However, the administrator controls which files and
devices the adversary can map. It is enough to use \emph{Discretionary Access
Control (DAC)} to prevent the adversary from mapping the devices and
pseudo-file-systems to memory. This isn't a major limitation because users
usually aren't allowed to access devices directly.

\subsection{Ignored System Calls}
\label{subsec:ignoredcalls}

Some system-calls rely on writes from user-space to user-space memory for their
correct behavior. During the execution of these calls the memory is changed and
re-read by the kernel. Hence, time-frozen memory view is detrimental to these calls.
Changing the value of the arguments for these calls isn't an attack --- it is a
part of their functionality.

The best representatives are \texttt{pollfd} and \texttt{futex}. \texttt{pollfd}
checks if any of the file-descriptors in the array passed as an argument are
ready to perform I/O. The user can write \texttt{-1} to memory to indicate that
the loop in the call needs to skip the descriptor. \texttt{futex} is a
user-space mutex. Most of \texttt{futex} synchronization depends on atomic
user-space writes, with the system-call being performed only to awake or make
threads wait. If \texttt{futex} marks a user-space address as read-only, other
user-space threads will be incapable of unlocking the futex by writing to that
address. Adding these calls and their variants to the exception list leads to a
successful boot and functioning of the kernel in the prototype.

The previous calls cause infinite loops or deadlocks when protected. Even though
\texttt{sys\_nanosleep} does execute correctly under \sysname{}, it marks the page
with its argument for the whole duration of the sleep. In practice this can be
quite long, and \texttt{sys\_nanosleep} should be ignored as well.

Finally --- if a system call can be verified not to have double-fetches, it can
be ignored to improve performance. This is especially important in case of
system-calls with large arguments such as \texttt{write}. Note that ignoring
means that the arguments of those calls are not protected. Ignored calls
still stop before writing to marked pages.


\section{Implementation}
\label{sec:implementation}

\sysname{} prototype has been implemented on Linux x86-64. However, \sysname{} can be
ported to any operating system that use a defined interface for reads and
writes to the user-space (\texttt{read\_in} and \texttt{write\_out}), and any
architecture that has page-tables encoding access control information. Depending
on the available resources (e.g. the number of free bits in the PTE) information
can be stored in different places (e.g., PTE or global structures).

\subsection{Basic Book-keeping}
\autoref{fig:bookkeeping} illustrates some of the most important data structures
used in the prototype --- the PTE with the permissions, the marked page metadata
(number of threads marking the page frame, number of threads waiting for the
unmarking, the reverse mapping information). 

\autoref{subsec:frameinfo} describes the data about the physical page frame with
some of the limitations due to the need to keep \texttt{struct page} as small as
possible. Considering that one \texttt{struct page} exists for every page frame
on the system, increasing its size would drastically increase the memory
overhead.  The data stored in the page table (permissions, free bits and page
frame number) is explained in more detail in \autoref{subsec:pageinfo}.

\subsection{Storing the Page Frame Information}
\label{subsec:frameinfo}
Linux divides physical memory into page frames. Each page frame is represented
by a \texttt{struct page}. This structure is replicated millions of times and
every additional field has a tremendous impact on the memory consumption.

To keep the memory consumption low, \sysname{} uses a single bit in \texttt{struct
page} to mark page frames. x86-64 has enough bits in the flag
field, so we have decided to use one of the flag bits for this purpose.
Architectures that have fewer flag bits (such as x86) can instead use some of
the bits used by other features (e.g., Kernel Shared Memory or NUMA domains). On
\autoref{fig:bookkeeping} this field is denoted by \emph{Page Marked Flag}.
\texttt{struct page} also stores a pointer to the \emph{reverse mapping}
information. The reverse mapping is used to find all PTEs \sysname{} needs to
(un)mark.

The marking metadata is stored in a hashmap based on the \emph{page frame
number}. This enables us to store only the information on the pages which are
currently marked and keep the memory consumption low. The access to these entries
is protected by separate mutexes to improve the scalability of the system. The
metadata constists of the page frame number, the count of threads marking the page
(\emph{owners}), the number of threads waiting for the page to get unmarked
(\emph{guests}), and a \emph{completion} they are waiting on. 

\subsection{PTE Information}
\label{subsec:pageinfo}

When a page is marked, \sysname{} changes some of the flags in the PTEs mapping it
(\autoref{fig:bookkeeping}):

\begin{LaTeXdescription}
  \item[R/W] gets set to \emph{read-only} to prevent writes to the page
  \item[SW2] gets the old value of \textbf{R/W}
  \item[SW3] gets set to 1 
\end{LaTeXdescription}

\textbf{SW2} is used by the Software Dirty Pages
feature of Linux. This feature cannot run alongside \sysname{} in our prototype.
Other architectures may have less, or more bits, available for the OS to use. In
the case of lack of space in the page table, \texttt{SW2} and \texttt{SW3} could
be stored in a separate data structure.

\emph{Copy-on-write} pages have a peculiar optimization. They are marked only in
the process requesting the marking. Writes from other processes will trigger a
copy-on-write mechanism, preventing them from changing the data.

\sysname{} does a partial flush of the TLB and updates the MMU cache to make these
changes visible immediately. The performance impact of this is analyzed further
in \autoref{sec:evaluation}.

\begin{figure}[]
  \centering
  \includegraphics[width=\linewidth]{img/book-keeping.pdf}
  \caption{The most important marking information on x86}
  \label{fig:bookkeeping}
\end{figure}

\subsection{Marking and Unmarking}

\begin{figure}[]
  \centering
  \includegraphics[width = 0.8\linewidth]{img/copy_from_user.png}
  \caption{\texttt{copy\_from\_user} page marking}
  \label{fig:copyfromuser}
\end{figure}

\sysname{} extends Linux's interface for reading and writing to user-space. The
abstractions \texttt{read\_in} and \texttt{write\_out} introduced in
\autoref{sec:design} are implemented in Linux as \texttt{copy\_from\_user} and
\texttt{copy\_to\_user}. \sysname{} extends \texttt{copy\_to\_user} to mark the pages
before reading the data (\autoref{fig:copyfromuser}).

Marking the page involves taking the appropriate locks, denoting the physical
page frame as marked, and incrementing the number of page owners. \sysname{} then
uses the reverse mapping information to mark the page in all the VM spaces
mapping it.

Unmarking follows a similar procedure. The appropriate locks are taken, and the
number of owners is decremented. Only if there are no owners marking the page
anymore, it is unmarked in all VM spaces. If there are threads waiting on the
page, they are signalled. The last guest to wake-up will deallocate the marking
data for the page.

\subsection{Loading File-Backed Pages}

As described in \autoref{sec:design}, file-backed pages need to be marked as
they are loaded to memory. On-demand paging takes place in the page-fault
handler, but invokes the functions of the file-system storing the file. \sysname{}
extends the functionality of \texttt{set\_alloc\_pte} to mark the page. The
needed structures are prealocated, and passed into the \emph{atomic context} where 
\texttt{set\_alloc\_pte} is called.

When a marked page is loaded, its data is also added to the interval-tree.
\sysname{} takes the lock before entering the atomic context, even though the
loaded page may not be marked. The version number of the interval-tree is
incremented after adding the page, informing all other threads that it has
changed.

\subsection{Tracking Marked Ranges}

\begin{figure}[]
  \centering
  \includegraphics[width = 0.8\linewidth]{img/pagefault.png}
  \caption{\sysname's handling of the writes in the page-fault handler}
  \label{fig:pagefault}
\end{figure}

\subsection{Protecting System Call Arguments from Writes by the Kernel}
\label{subsec:kernelland}
\begin{figure}[]
  \centering
  \includegraphics[width = 0.8\linewidth]{img/copy_to_user.png}
  \caption{\texttt{copy\_to\_user} write handling}
  \label{fig:copytouser}
\end{figure}

\sysname{} stores the marked memory ranges for every VM space
(\texttt{mm\_struct}) in an interval tree. Before writing to the user-space,
\texttt{copy\_to\_user} (\autoref{fig:copytouser}) the lock for the marked
memory ranges tree and checks for the intersections with the destination buffer.
Writes to marked pages are stored to freshly allocated memory, along with the
destination address, and written at the end of the call.

Writes to unmarked pages proceed as normal, unless the page is not present, when
a page-fault exception happends (\autoref{fig:copytouser}). The page-fault
handler takes the page-table lock, loads the page and restarts the write. If the
page-fault handler detects a potential deadlock, it will release the
interval-tree lock. Page-table read-lock is not exclusive, so it does not need
to be released (\autoref{fig:pagefault}).

\texttt{copy\_to\_user} will attempt to write to the page after exiting the
page-fault handler. In the case it is indeed marked, it will block and wait for
its unmarking. This is the only case where \sysname{} forces threads to wait in
the middle of a system call. After the write, the thread reaquires the lock,
checks if the interval tree has changed and restarts the write if so.

The restart of the write is necessary because any change to the interval-tree
invalidates the iterator. \sysname{} is optimized for the case of rare markings,
making \texttt{copy\_to\_user} calls which do not encounter marked pages fast
--- only one, large write occurs. The alternative is to check and write to every
page individually. Such implementation does not need to restart the write, but
incurs the overhead of writing to pages individually.

\section{TikTok Deadlocks}
\label{sec:deadlocks}

\sysname{} relies on locks and on blocking for the prevention of the
double-fetch attacks. It introduces the additional synchronization points to the
execution of programs. This section discusses the posibility of deadlocks.

The deadlocks caused by locks that moderate the access to the common \sysname{}
data structures are discussed in the \autoref{subsec:impldeadlocks}. The
deadlocks caused by waiting in the page-fault handler is analyzed in
\autoref{subsec:tiktokdeadlocks}.

\subsection{Implementation Deadlocks}
\label{subsec:impldeadlocks}

Almost all of the locks in the implementation of \sysname{} follow a strict
locking order based on the memory-management submodule's ordering. No deadlock
can occur if the locks are always taken in the same order, in all threads.

The only two locks taken in the opposite order are the \emph{page-table lock}
and the \emph{interval-tree lock}. In \texttt{copy\_to\_user} the interval-tree
lock must be taken first to check which memory ranges are marked. However, when
marking a page the page-table lock needs to be aquired first to locate the
page-table entry mapping the page. \sysname{} implements the deadlock resolution
mechanism where if the page-fault handler notices that the interval-tree lock is
already taken, it gets released.


\subsection{Design Deadlocks}
\label{subsec:tiktokdeadlocks}

Unlike deadlocks that are a consequence of a poor implementation
\autoref{subsec:impldeadlocks}, design deadlocks involve at least one process
waiting in the page-fault handler. These deadlocks would be a consequence of the
specification, and not of the programmer error. Such deadlocks can be easily
resolved by ignoring the system calls involved. In this section we discuss the 
conditions necessary for those calls to occur and why they are practically
non-existant, even if the majority of system-calls are not ignored.

\begin{figure}
  \centering
  \begin{subfigure}[b]{0.45\linewidth}
  \begin{minipage}{\linewidth}
  \begin{lstlisting}
  1: S(A,T1);  
  \end{lstlisting}
  \end{minipage}
  \caption{Thread 1}
  \end{subfigure}
  \hfill
  \begin{subfigure}[b]{0.45\linewidth}
  \begin{minipage}{\linewidth}
  \begin{lstlisting}
  2: write(A);
  3: unblock_S(T2);
  \end{lstlisting}  
  \end{minipage}
  \caption{Thread 2}
  \end{subfigure}
  \caption{Executing instructions in the specified order causes a deadlock with \sysname}
  \label{fig:deadlock}
\end{figure}


\autoref{fig:deadlock} shows an example of a deadlocking communication pattern.
Thread 1 enters the system call \texttt{S} and marks a shared page \texttt{A}
(\textbf{1}). The system call \texttt{S} blocks until the corresponding call
\texttt{unblock\_S} is called in Thread 2 (\textbf{3}). While the page
\texttt{A} is still marked, Thread 2 attempts to write to it, causing it to wait
for \texttt{S} to finish (\textbf{2}). All of the deadlocking patterns need to
exibit a similar combination of paired blocking calls (\texttt{S},
\texttt{unblock\_S}) with arguments in the shared memory (page \texttt{A}).

Similar deadlocking patterns are possible with more threads. The necessary
condition for all of them is a circular, waits-for dependancy graph when \sysname
waits are combined with an already existing dependency. An already
existing synchronized call is necessary for it to happen.

\sysname{} cannot cause a circular dependency only as a consequence of its
system call reads, writes and markings. Every dependency involves one marked
page and a write to it. A self-deadlocking execution trace would have to involve
a write from a system-call to a page marked by another system-call. The other
system-call would also need to write to the page marked by the first call to
complete the cycle. This situation is impossible in \sysname. System calls
postpone writes to marked pages until the end of the call.

The only exception is the back-off due to the deadlock prevention system. The
thread executing \texttt{copy\_to\_user} writes to a page that is not present,
and releases the interval-tree lock. Right after loading the page, another
thread executes \texttt{copy\_from\_user} and marks it. The first thread is
forced to reexecute the write by the the page-fault handler. Here, the first
thread is executing \texttt{copy\_to\_user}. For the deadlock to occur it needs
to execute \texttt{copy\_from\_user} in the same manner as the second thread.
Fortunately, the \texttt{copy\_to\_user} thread must wait for the unmarking,
preventing it from executing \texttt{copy\_from\_user} and the second write-wait
pair from happening.

Even though the deadlocking patterns can easily be resolved by updating the
ignore list, the conditions for the deadlock to appear are almost impossible to
encounter in practice. During our evaluation we haven't encountered such a
deadlock. The deadlocking pattern \autoref{fig:deadlock} requires three
ingredients:

\begin{itemize}
  \item A synchronized marking call \texttt{S}
  \item Storing the arguments of \texttt{S} in shared memory \texttt{A}
  \item A thread to write to \texttt{A} while \texttt{S} is executing
  \item An already existing waits-for dependancy between the thread executing \texttt{S} and a write
\end{itemize}

The only candidates for \texttt{S} that the authors have encountered are
blocking message-passing calls. They are synchronous and thus provide the
necessary waits-for dependency, and they read buffers from user-space memory, marking
pages. However, the deadlock would imply that data on the page \texttt{A} is shared both by
message-passing and shared-memory. We haven't encountered such a pattern while
testing \sysname{} and there are a few reasons why it doesn't occur in practice:

\begin{itemize}
  \item Most programs use only one IPC method (either message-passing or shared-memory)
  \item System call arguments are usually stored on the stack, and accessed only by the executing thread
  \item The programs would need to use both IPC methods at the same time, on the same data
  \item Both system calls and shared-memory are relatively rare in programs, and used in the well-defined patterns
\end{itemize}

\sysname{} adds another synchronization point to the kernel --- it prevents
write calls to files having marked, mapped pages. While it is possible to
deadlock a thread by mapping a file, and then passing the mapped pages as the
arguments to the write call to the same file, we have not encountered such a
case.

\section{Evaluation}
\label{sec:evaluation}

\sysname{} has been evaluated on different benchmarks to measure the drop in performance.
The three main profiles have been compared:
\begin{LaTeXdescription}
  \item[\sysname{} On] protects as many system calls as possible
  \item[\sysname{} Partial] does not protect the arguments of \texttt{write} and its variants
  \item[\sysname{} Off] is the Linux kernel compiled without \sysname{}  
\end{LaTeXdescription}

\subsection{NAS Parallel Benchmark}
\label{subsec:npb}

\emph{NAS Parallel Benchmarks (NPB)} is a benchmark introduced by NASA. It
consists of several parallel programs using different communication patterns.
\sysname{} introduces additional synchronization points between threads, so it
should affect multi-threaded programs more than single-threaded ones. NPB is
available for multiple technology stacks for parallel programming. \sysname{}
was evaluated on \emph{OpenMP} and \emph{MPI} versions of the benchmark
with workloads of class A.

\begin{figure}[]
  \centering
  \includegraphics[width=\linewidth]{graphs/omp.png}
  \caption{\sysname{} evaluated on NPB with OMP}
  \label{fig:npbomp}
\end{figure}

\begin{figure}[]
  \centering
  \includegraphics[width=\linewidth]{graphs/mpi.png}
  \caption{\sysname{} evaluated on NPB with MPI}
  \label{fig:npbmpi}
\end{figure}

OpenMP is a compiler extension that with minimal effort parallelizes the software
by using multiple threads. All the threads still use the same VM space, keeping
the overhead minimal. \sysname{} was evaluated with 8 threads.

MPI implements parallel execution by launching multiple processes which communicate
by message-passing. It is more heavyweight than OpenMP as every process has a
separate VM space. Due to the limitations of some benchmarks, \sysname{} was 
evaluated with 16 processes.

The benchmarks have been run with \sysname{} protecting almost all calls, with
\texttt{write} disabled and without \sysname{} at all (\autoref{fig:npbomp} and
\autoref{fig:npbmpi}). Both benchmarks show no significant difference between
different setups. MPI however has wider standard-error margins, probably
introduced by the heavier startup and communication. Shorter benchmarks magnify
relative differences (explaining the artifacts for \texttt{is} and \texttt{ep}).
\sysname{} doesn't incur a noticable performance
penality for CPU-bound workloads, even when they involve multiple
threads/processes.

\subsection{Phoronix Test Suite}
\label{subsec:phoronix}

\begin{figure*}[]
  \centering
  \includegraphics[width=\linewidth]{graphs/phoronix.png}
  \caption{\sysname{} evaluation on Phoronix Test Suite}
  \label{fig:phoronix}
\end{figure*}

\emph{Phoronix Test Suites (PTS)} evaluates systems on real-world software. We
ran \sysname{} on it to judge the actual performance impact during the
everyday use.

\autoref{fig:phoronix} shows the results of the Phoronix benchmark. All
results have been normalized to with \sysname{} off as a baseline. Benchmarks
marked with an asterisk (*) measure execution time (lower is better), while others
measure performance (higher is better).

Linux compilation, OpenSSL, Redis, Git and PyBench do not show a noticable
degradation of performance. These programs don't feature a lot of inter-process
communication. Even the parallelized benchmarks such as Linux kernel compilation
generate independent processes.

However, the two web servers (Apache and NginX) show a significant drop in
performance (Apache -- 16.87\% and NGINX -- 16.38\%) with \sysname{} protecting
all calls. \sysname by design affects parallel applications the most (by
introducing forced synchronization on accesses and featuring more PTEs to mark)
and software with numerous system calls (by marking all the arguments stored
in-memory). Ignoring write calls improves the situation slightly (Apache --
15.64\% and NGINX -- 13.41\%).

The IPC TCP benchmark consists only of executing 2 system calls to transfer
the data between two threads. Compared to other benchmarks IPC benchmark has fewer
threads than web-servers, but also executes a significant number of system calls.
This places it in-between two groups with respect to the drop in performance.

\begin{figure}[]
  \centering
  \includegraphics[width=\linewidth]{graphs/apache-nginx-5.png}
  \caption{Detailed comparison of Apache and NginX performance}
  \label{fig:phoronix-apache-nginx}
\end{figure}

Apache and NginX benchmarks have been executed under two more \sysname{}
profiles to see how reducing the number of protected system calls affects
performance (\autoref{fig:phoronix-apache-nginx}):

\begin{LaTeXdescription}
  \item[Frequent system calls ignored] ignores the most frequent calls executed in the benchmarks, as well as \texttt{write}.
  \item[All system calls ignored] does not protect any system calls.
\end{LaTeXdescription}

Ignoring frequent system calls leads to a smaller overhead (Apache -- 5.34\% and
NginX -- 2.77\%). The performance is almost equal to not protecting any system
calls at all (Apache -- 2.46\% and NginX -- 2.25\%). Even when \sysname
is not providing any protection, the overhead of \texttt{copy\_to\_user} checks
is present.

\uros{I will need to obtain new numbers from perf. The last run did not have the
permissions to decode the kernel symbols. I expect the same results.}

\begin{table*}[]
  \label{table:perf}
  \centering
  \begin{tabular}{|l|l|l|l|l|}
  \hline
                                 & Apache & Apache (\sysname{} - No writes) & IPC & IPC (\sysname{} - No writes)\\ \hline
  Marking pages read-only        & 0\%    & 4.33\%          & 0\% & 0\%         \\ \hline
  Unmarking pages                & 0\%    & 3.83\%          & 0\% & 0.98\%      \\ \hline
  Flushing Individual TLB Ranges & 1.50\% & 5.72\%          & 0\% & 0\%         \\ \hline
  Write Bypass Protection        & 0\%    & 0\%             & 0\% & 1.47\%      \\ \hline
  Read Bypass Protection         & 0\%    & 0\%             & 0\% & 1.15\%      \\ \hline
  Total Overhead                 & 0\%    & 13.59\%         & 0\% & 4.29\%      \\ \hline
  \end{tabular}
  \caption{Perf Analysis of the Benchmarks}
\end{table*}

Analyzing Apache and IPC benchmark executions with \texttt{perf} it was possible
to determine which functions were executing slower with \sysname{}.
\autoref{table:perf} shows how much time the programs spend in the functions
added by \sysname. Percentages of individual segments have been measured by
\texttt{perf}, while the total overhead is calculated from the results of the
benchmark. Furthermore, TLB is flushed both during the marking and unmarking of
pages.

The comparison of the Apache and IPC runs shows two very different marking
profiles. Apache spends a considerable amount of time marking and unmarking
pages, while IPC does not mark pages at all. This is a consequence of the
different system-calls used by these applications. IPC uses only \texttt{read}
and \texttt{write} calls which do not mark arguments, while Apache also invokes
system-calls which mark arguments (\texttt{accept}, \texttt{getsockname}).
Consequentially, Apache spends a lot of time marking and unmarking pages.

In these two segments Apache actually waits most of the time for the TLB
signaling functions to execute. \texttt{flush\_tlb\_mm\_range} amounts for
2.51\% (marking) and 2.10\% (unmarking) of the total time spent executing the
benchmark. Frequent TLB flushes are expensive because the CPU needs to make sure
that all the cores have processed the signal before continuing. Unfortunately,
this is only a part of the overhead incurred by flushing the TLB. Flushed pages
will be accessed right afterward leading to a TLB miss, further inflating the
overhead.

IPC benchmark executes only \texttt{write} and \texttt{read} calls. It doesn't
incur any overhead on TLB flushes because none of these calls mark pages.
However, \texttt{copy\_to\_user} checks are still active, leading to a
significant locking overhead. Without TLB flushes it is interesting to notice
that the overhead of individual components roughly adds up to the total overhead
in the IPC benchmark.


% In this section we need to convince the reader in two things:
% 1) Alternative filtering approaches to system call filters are incomplete and
% cumbersome
% 2) The best way to solve the TOCTTOU bug in filters is TikTok. All other
% methods can only fix other double-fetches, or they force you to use TSX
\section{Related Work}
\label{sec:relatedwork}

The literature related to double-fetches can be broadly divided into two groups.
In the first group are the static solutions (\autoref{subsec:dfstatic}) that use
techniques such as source or binary analysis to detect double-fetch bugs. The
second group (\autoref{subsec:dfdynamic}) uses run-time information to detect
and (rarely) prevent double-fetches.

The most important work related to \sysname{} is the paper by
Watson~\cite{watson2007exploiting} criticizing the security of system call
wrappers (\autoref{subsec:watson}). The implications of \sysname{} for system
call wrappers are discussed in \autoref{sec:furtherwork}.

\subsection{Watson's Critique of System Call Wrappers}
\label{subsec:watson}
Watson's paper~\cite{watson2007exploiting} scrutinized the security of many
system call wrappers. Not only did he find that all of them were insecure,
Watson also described the different types of TOCTTOU bugs that compromised them
and discussed potential fixes. In a short paragraph, he mentions that Pawel
Dawidek, the creator of CerbNG~\cite{zak_frasunek_dawidek}, has experimented
with marking arguments read-only. CerbNG was an early system call filtering
system for BSD that used copy-on-read-and-write to a new memory page.

Afterward, Watson briefly discusses problems such memory marking systems
need to solve: 
\begin{itemize}
    \item unnecessary page-faults
    \item bypassing memory marking using IO system calls
    \item mapping shared memory with different permissions
    \item handling system calls that both read and write to the same memory
\end{itemize}

According to Watson, no memory-marking system (including CerbNG) addressed all
of these problems. \sysname{} does exactly that. Unnecessary page-faults are
rare and they are used to make the offending threads wait for unmarking. After
the page has been unmarked, the write proceeds without any consequences. Write
system-call does not proceed until there are no marked pages of the file.Pages
are marked when they are mapped if needed. \sysname{} postpones all writes to
marked pages coming from the kernel while allowing the system calls to execute
correctly.

\subsection{Static Analysis Work}
\label{subsec:dfstatic}
Static analysis techniques analyze the source code to find double-fetch bugs.
Wang et al.~\cite{wang2017double} used pattern matching to find potential
double-fetches. They implemented a tool that patches certain double-fetches
automatically. However, their method in the general case produces false
positives that need to be inspected manually. Xu et al.~\cite{xu2018precise}
improved on this work by proposing Deadline. Deadline does not use the pattern 
analysis on the source files to detect double-fetches, but a compiler's
intermediate representation and constraint solving to eliminate false positives.

Static analysis techniques such as these have the benefit of being able to find
bugs in the code that cannot be run (e.g., missing hardware to test the
drivers). However, they are meant for bug detection, not mitigation. Even though
the tools can fix some bugs automatically, this is not always possible. The
TOCTTOU bug is in the system call wrappers by design. Double-fetches not visible
in the source, nor in the intermediate representation are another problem.
Compilers can introduce such invisible double-fetches when allocating registers
to variables. \sysname{} works even in such cases.


\subsection{Dynamic Analysis Work}
\label{subsec:dfdynamic}
Google Project Zero's Bochspwn~\cite{jurczyk2013bochspwn} uses an emulator to
detect double-fetches. It found a large number of bugs in the Windows kernel.
Bochspwn works on binaries. It does not require access to the source code and it
detects bugs introduced by compilers. DFTracker~\cite{wang2019dftracker} is
another dynamic analysis technique work with a lower overhead, that relies on
taint tracking. However, these dynamic techniques are limited to the detection
of double-fetches. Similar to work presented in \autoref{subsec:dfstatic},
developers need to manually fix the bugs. However, with dynamic analysis a
double-fetch must also be executed, limiting this technique to the core kernel
and to the drivers with the available hardware.

A big leap in dynamic analysis techniques has been presented by Schwartz et
al.~\cite{schwarz2018automated}. The first part of the paper introduces DECAF
--- a framework that uses side-channel attacks to create a fuzzing oracle for
double-fetch bugs. While Bochspwn relies on emulation, slowing the execution
significantly, DECAF runs natively. It also eliminates false positives by
automatically exploiting found bugs.

Schwartz et al. then discuss a real-time mitigation technique for double fetches
--- DropIt. DropIt uses Intel's \emph{Transactional Synchronization Extensions}
(TSX)~\cite{intel64and} in a creative way to prevent double-fetch bugs. By
encapsulating the code in a TSX transaction, writes from other threads will
result in the transaction being aborted. However, the code executing inside a
TSX transaction is severely limited. All reads must fit in the L3 cache, and all
writes in L1. Some instructions are also forbidden. \sysname{} has none of those
limitations. It works on non-Intel processors and relies on page tables for
protection --- a technique that has been present for several decades.

\section{Further Work}
\label{sec:furtherwork}
Integration with an existing system-call wrapper would lead to the improved
flexibility and performance of \sysname. SecComp~\cite{seccomp} and
eBPF~\cite{ebpf} are the obvious candidates that would benefit from such an
extension. A possible optimization would be to mark only the pages accessed by
the filter, and not the system-call body. It would also be beneficial to
investigate possible batching of TLB flushes, considering how much they
contribute to the execution overhead.

\section{Conclusion}

\sysname{} mitigates double-fetch bugs in system-calls by using page-tables. It
works both on the core kernel, and drivers, even when their source code is not
available. It can be ported to any architecture that uses page-tables, and any
kernel that has a well-defined interface to access user-space memory. \sysname
is tested in practice on a modern system (Linux Server 18.04 LTS) with complex
programs running (\texttt{systemd}, \texttt{gcc}, \texttt{Apache} \ldots). When
protecting rare system calls it shows an overhead of 2-4\%, which raises to
~20\% when protecting almost all calls in multithreaded, system-call intensive
programs. CPU-bound programs do not have a significant overhead, even if they
use multiple threads.
%-------------------------------------------------------------------------------
%\section*{Acknowledgments}
%-------------------------------------------------------------------------------

%-------------------------------------------------------------------------------
\section*{Availability}
%-------------------------------------------------------------------------------

The source code of TikTok is available at LINK. It has been released under the
GNU Public Licence.

%-------------------------------------------------------------------------------
\bibliographystyle{plain}
\bibliography{\jobname}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%  LocalWords:  endnotes includegraphics fread ptr nobj noindent
%%  LocalWords:  pdflatex acks
