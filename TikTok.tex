\documentclass[letterpaper,twocolumn,10pt, anonymous]{article}
\usepackage{usenix2019_v3}

\usepackage{amsmath}
\usepackage{filecontents}
\usepackage{tikz}
\usepackage{xspace}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{textcomp}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{todonotes}
\usepackage{multirow}
\usepackage{booktabs}
\usepackage{paralist}
\usepackage{enumitem}
\usepackage{tabulary}
\usepackage{prettyref}
\usepackage{verbatim}
\usepackage{balance}
\usepackage{tabularx}

%-------------------------------------------------------------------------------
\begin{document}
%-------------------------------------------------------------------------------


\lstdefinestyle{cstyle}{
  basicstyle=\footnotesize\ttfamily,
  keywordstyle=\color{black!85}\bfseries,
  keywordstyle=[2]\color{black!85}\bfseries\emph,
  showstringspaces=false,
  language={C},
  breaklines=false,
  mathescape=true,
  escapechar={@}
}
\lstdefinestyle{inline}{
  style=cstyle,
  mathescape=false,
  breaklines=true,
  keywordstyle=,           
  keywordstyle=[2],
  extendedchars=true,
  basicstyle=\ttfamily\small
}
\newcommand{\Code}[1]{\lstinline[style=inline,breaklines=false]@#1@}
\let\realparagraph\paragraph
\let\paragraph\relax
\newcommand{\paragraph}[1]{\textbf{#1.}}
\newcolumntype{Q}{>{\centering\arraybackslash}X}

\newcommand\tocttou[0]{ToCtToU\xspace}
\newcommand\tiktok[0]{TikTok\xspace}

\newrefformat{cha}{\hyperref[#1]{Chapter~\ref*{#1}}}
\newrefformat{sec}{\hyperref[#1]{Section~\ref*{#1}}}
\newrefformat{sub}{\hyperref[#1]{Section~\ref*{#1}}}
\newrefformat{tab}{\hyperref[#1]{Table~\ref*{#1}}}
\newrefformat{fig}{\hyperref[#1]{Figure~\ref*{#1}}}
\newrefformat{line}{\hyperref[#1]{line~\ref*{#1}}}
\newrefformat{lst}{\hyperref[#1]{Listing~\ref*{#1}}}
\newrefformat{pat}{\hyperref[#1]{Patch~\ref*{#1}}}
\newrefformat{alg}{\hyperref[#1]{Algorithm~\ref*{#1}}}

\renewcommand\itemautorefname{Attack}

\newcommand\mat[1]{\noindent{\color{blue} {\bf \fbox{Mat}} {\it#1}}}
\newcommand\atri[1]{\noindent{\color{red} {\bf \fbox{AB}} {\it#1}}}

%don't want date printed
\date{}

% make title bold and 14 pt font (Latex default is non-bold, 16 pt)
\title{\Large \bf Kernel TOCTTOU Protection}

%for single author (just remove % characters)
\author{
{\rm Anonymous}\\
Your Institution
% copy the following lines to add more authors
% \and
% {\rm Name}\\
%Name Institution
} % end author

\maketitle

%-------------------------------------------------------------------------------
\begin{abstract}
%-------------------------------------------------------------------------------
Your abstract text goes here. Just a few facts. Whet our appetites.
Not more than 200 words, if possible, and preferably closer to 150.
\end{abstract}


\section{Background}

\subsection{Linux Memory Subsystem}

\subsection{Page Tables and Memory Protection}

\subsection{SMAP}

\begin{figure}[]
  \centering
  \includegraphics[width=.85\linewidth]{img/doublefetch.pdf}
  \caption{Example of a double-fetch bug}
  \label{fig:doublefetch}
\end{figure}


%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Attack vectors}
\label{sec:threats}
%%%%%%%%%%%%%%%%%%%%%%%%%%%

In this section, we describe the threat model for exploiting double-fetch
bugs in the kernel and classify the possible attacks based on how the 
data is modified between vulnerable double-fetches.

\subsection{Threat Model}
\label{sec:threatmodel}

% Nothing fancy -- the adversary is just trying to hack the system
% No black magic allowed
The adversary has access to a user account on the target machine. They can
execute arbitrary userspace code, including system calls. Some of the system 
calls have double-fetch vulnerabilities, and the adversary wants to exploit them,
e.g., for privilege escalation.
The attacker may execute on multiple CPU cores and may execute an arbitrary 
sequence of system calls. 

\tiktok mitigates any unintended corruption or information leakage \emph{in the kernel}
or \emph{in other user processes} that arises through double-fetch bugs. 
Hardware attacks such as Rowhammer~\cite{mutlu2019rowhammer}
or side-channels~\cite{kocher2019spectre}, and file-system TOCTTOU
attacks~\cite{payer2012protecting, pu2006methodical, wei2010modeling,
tsafrir2008portably} are out of scope.

\subsection{Attacks Classification}
\label{sec:attacks}

% List five attacks and explain them quickly
\tiktok guards data passed into the kernel against concurrent modification.
In the following classification, we denote the data fetched twice
by code containing a \tocttou bug as vulnerable data.
\begin{enumerate}
  \item \label{attk:direct} \emph{Direct double fetch}: The adversary runs
  concurrently with a system call in a separate thread in the same address space
  and uses userspace store instructions to modify the vulnerable data.
  % user write -> kernel read

  \item \label{attk:systemcall} \emph{Privileged double fetch}: The adversary
  executes a \Code{read} syscall to run concurrently as the target syscall in 
  the same address space. 
  The adversary provides the address of the vulnerable data as the buffer 
  into which the \Code{read} syscall will write.
  In an example of a confused-deputy attack, the kernel thread executing the
  \Code{read} on the adversary's behalf modifies the vulnerable data.
  % read(): kernel (privileged) write -> kernel read

  \item \label{attk:remapping} \emph{Reflected double fetch}: The target
  syscall should be reading the vulnerable data from a file-backed page.
  The adversary running in another address space maps the same file-backed page
  as writable and modifies the vulnerable data using the new mappings.
  This approach attempts to bypass any protections set up by the kernel
  when first reading the vulnerable data by adding a new mapping to it later.
  % mmap(): user write -> kernel read

  \item \label{attk:writebuffers} \emph{Inception double fetch}: The 
  target syscall should be reading the vulnerable data from a file-backed 
  page. The adversary opens the file and issues a \Code{write} syscall.
  The kernel modifies the vulnerable data while executing the filesystem's
  write code for the file.
  % mmap(): write(): kernel (privileged) write -> kernel read

  \item \label{attk:devicefiles} \emph{Device double fetch}: The target 
  syscall is reading a page available for direct-memory access (DMA) by 
  an I/O device. The device can initiate a DMA write, modifying the 
  vulnerable data. This avenue does not use store instructions in any 
  CPU core.
  % device write -> kernel read

\end{enumerate}
\mat{Can we add a short sequence or figure for each of these attacks? This would
IMO help. I've added a note in comments to describe the attack/victim
scenarios.}

Watson~\cite{watson2007exploiting} in his analysis of CerbNG introduces
\autoref{attk:direct}, \autoref{attk:remapping} and \autoref{attk:writebuffers}.
We extend the discussion of known attacks and introduce
\autoref{attk:systemcall} and \autoref{attk:devicefiles}.

A comprehensive protection against \tocttou bugs must protect against 
all concurrent writes of these representative attack vectors.
\mat{Are we sure these are complete? Can we make a stronger statement that a
defense must enforce a generic property?}
The protection mechanism necessarily manages access control for pages
mapped across multiple address spaces and also via file-system drivers.
As shown above, an adversary can use its own mappings to try to modify the
vulnerable data, or coerce the kernel to do so using particular syscalls.
The next sections describe \tiktok, our protection mechanism which 
protects against the first four vectors, and can be extended to protect 
against the final vector too.


%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{\tiktok Design} 
\label{sec:design}
%%%%%%%%%%%%%%%%%%%%%%%%%%%

\tiktok maintains a single core \emph{invariant}:
\textbf{\emph{Through a syscall's lifetime, every read to a userspace object 
will return the same value}}.
By construction, the invariant guarantees that double-fetches in syscall
code will read the same data, \emph{eliminating \tocttou bugs}.
\tiktok maintains the invariant by tracking \emph{snapshots} of objects
when first accessed, lazily making \emph{copies} when the object is concurrently 
written and accessing the correct copy on subsequent reads.
Copies are only maintained during syscalls' lifetimes, and are released as 
soon as no syscall needs it.
Consequently, each userspace object has a single copy when no syscalls are
running.
The invariant also means that only accesses to userspace objects by the kernel
need to be protected. 
Accesses to userspace objects from userspace and kernel objects by kernel 
code remains unaffected.

In addition, \tiktok must assure \emph{correctness}: there must exist an
execution on a non-\tiktok system where userspace \emph{never} modifies data 
between double-fetches by the kernel which is identical to the execution
of syscalls protected by \tiktok.
\mat{Rephrase correctness invariant, you are basically saying tiktok may not
introduce any false executions. Separate the two invariants into a security
invariant and a correctness invariant.}
\mat{I rephrased the below assuming two variants.}

\tiktok's implementation builds on the protection mechanisms provided by 
existing virtual memory implementations.
On modern platforms, virtual memory protection is set up by the OS at
page-granularity by setting bits in pagetable entries (PTEs).
These permission bits are checked by the hardware on memory access, 
efficiently enforcing that the permissions are respected, or raising 
a fault when they are not.
Therefore, \tiktok implements its invariants at page-granularity, not object 
granularity: when a syscall reads from userspace, every page touched by that 
read is covered, not merely the bytes read.
As a side-effect of this implementation, \tiktok does not distinguish
accesses to different parts of a page, and may incur performance overhead due
to false sharing within a page. 
Page-granularity protections are more conservative compared to byte-granularity
protection and, therefore, \tiktok maintains its invariants nonetheless but may
incur performance overhead for false sharing on highly contended pages.

For an object spanning multiple pages, \tiktok's design sequentially 
protects each page before reading from it.
The leading pages containing the object are protected before the
later pages, allowing an attacker to potentially modify the later 
pages before the syscall first reads them.
However, the attacker is prevented from modifying any of these earlier pages
after the syscall's first read, ensuring that double-fetches respect
the invariant.
If the syscall code contains a \tocttou bug, the modification will
be visible to the first fetch itself (which is used for checking for 
validity of the data) and will lead to the data being rejected 
straightaway.
\tiktok's invariants therefore prevent exploitation of double-fetch
vulnerabilities even when the fetched objects span multiple pages.

A major requirement for \tiktok is to allow concurrent access to pages
by user/kernel code running in parallel with a syscall which reads from 
the same pages.
This requirement prevents deadlocks and improves performance vis-a-vis
a na\"ive design which blocks all other tasks writing to pages already 
read by a syscall until the syscall completes.
The na\"ive design can deadlock because it introduces dependencies between
tasks for forward progress, and we illustrate this in the following example
of a system with two tasks, A and B.
Task A issues a blocking system call which reads a user page and blocks. 
Task B writes to the same user page before issuing a syscall which 
resumes task A. 
In this case, if Task A's read to the page preceds Task B's write, 
Task B will be blocked waiting for A to complete its syscall.
Task A will also remain blocked waiting for Task B's syscall, 
introducing a circular dependency, leading to deadlock.
The na\"ive design also introduces unnecessary delays in other cases, 
such as the one described below, again with two tasks C and D.
Task C reads from a page and sleeps for a long, determinate while.
Task C does not read from the page a second time.
Task D writes to the same page after task C has read from it, and 
blocks until Task C completes and is unnecessarily delayed.
A more performant approach is to duplicate the concurrently accessed page: the copy is 
kept should task C fetch data from the page again, and task D
can write to the original and proceed without delays.

\tiktok must maintain multiple versions of a page read by a syscall 
to maintain its invariants in the face of concurrent writes.
\tiktok introduces \emph{snapshots} and \emph{copies} to keep track 
of page versions. 
Snapshots are logical views of the page's contents at a particular time,
while the actual contents are stored in one of many copies. 
Each snapshot maps to a copy, allowing the contents of the page at the 
time of creating the snapshot to be read. 
If multiple snapshots are taken without intervening writes to the page, 
these snapshots will map to a single copy, reducing \tiktok's space overheads 
and performance overheads for creating copies.
\tiktok maintains a snapshot of every page when first read by a syscall.
On a double fetch by the same syscall, the copy mapped to by the snapshot 
is accessed, ensuring that the data read is the same as the first time.
The latest copy of the page is used for all writes, by the syscall as 
well as from concurrently running tasks, updating the page as seen 
from userspace.
\emph{Essentially, \tiktok is a multi-versioning system for pages where 
syscalls read from immutable versions to prevent \tocttou bugs and
syscalls and userspace both write to a single mutable version 
holding the latest state of the page.}
\tiktok's design draws parallels to multi-version concurrency control 
methods for databases based on snapshot isolation~\cite{0001MK15}.
Transactions read from a snapshot of the database state from when 
they started, and writes update the up-to-date state of the database.

\subsection{Page state machine}

\begin{figure*}[]
  \includegraphics[width=\linewidth]{img/tiktok_states.pdf}
  \caption{State diagram for a page in \tiktok. Reads/writes from userspace/syscall 
          code are marked (u)/(s) respectively. Shading is used to represent the 
          mapping from snapshots to copies.}
  \label{fig:tiktok_states}
\end{figure*}

\begin{figure}[]
  \includegraphics[width=\linewidth]{img/doublefetch_tiktok.pdf}
  \caption{Diagram illustrating \tiktok preventing exploitation of a double fetch.}
  \label{fig:doublefetch_tiktok}
\end{figure}

To track multiple versions of the contents of a page when being concurrently 
accessed by numerous tasks, from userspace or during a syscall,
\tiktok implicitly maintains a per-user-page state machine.
For each page, its corresponding state machine 
\begin{inparaenum}
  \item tracks snapshots for currently executing syscalls which have read it, 
  \item tracks copies of the page, and 
  \item maintains the mapping between snapshots and copies necessary for providing 
  the correct contents to subsequent reads by these syscalls.
\end{inparaenum}

\autoref{fig:tiktok_states} shows the state machine for a single page.
At every state, the page has two associated sets:
\begin{inparaenum}[\itshape i\upshape)]
  \item the copies set $C = \{C_L, C_0, \dots\}$ holds multiple copies of the page over time, and
  \item the snapshots set $S = \{L, S_0, S_1, \dots\}$ tracks logical versions of the page, each corresponding to one executing syscall and mapping to a copy. 
\end{inparaenum}
Reads from kernel code in a syscall use the \emph{snapshot's corresponding copy}.
Writes from user/kernel code and reads from userspace access the \emph{latest 
copy}, which is mapped in process' address spaces.
\mat{What if a syscall reads (taking a snapshot), writes, reads again? The write
may not show up in the 2nd read? As you describe below, this is not supported. I
wonder if we should forward reference?}
All other copies are read-only (no matter what the original page protection is), and are used for providing snapshots to syscalls.
Read-only pages only use states 0 and 1, and writes lead to segmentation faults
as they do on non-\tiktok systems.
The latest copy $C_L$ of read-only pages remains read-only in both states.
In the following paragraphs, we describe how the state machine for a single, 
writable user page transitions between its states, what triggers each transition, 
and what changes are made to the copies and snapshot sets on a transition.
In \autoref{fig:doublefetch_tiktok}, we illustrate how the state machine protects the 
syscall from \autoref{fig:doublefetch}.

\paragraph{State 0}
A page starts as \texttt{(unprotected, unduplicated)}.
In this state, there is a single copy $C_L$ and a single ``snapshot'' $L$. 
The snapshot $L$ refers to the latest version of the page which changes 
with time, and is the only mutable snapshot.
All processes where this page is mapped have unrestricted userspace read and write 
access, and unrestricted kernel write access.
The remaining operation, a read from kernel code, triggers a transition to 
the next state.
In \autoref{fig:doublefetch_tiktok}, we see the snapshot $L$ initially containing 
the value $42$.

\paragraph{State 1}
The page in State 0 transitions to the \texttt{(protected, unduplicated)} state as soon as a syscall 
reads from it.
\tiktok first marks the page's latest copy $C_L$ read-only in all processes, 
trapping writes to the page but allowing concurrent userspace reads to continue.
A new snapshot, $S_0$ linked to this syscall is allocated for this page.
For the rest of its lifetime, this syscall will only read from this snapshot.
Both snaphots $S_0$ and $L$ refer to the same copy $C_L$ (shown by the 
blue cross-thatch in \autoref{fig:tiktok_states}).
Prior to any writes to this page, any other syscalls which also read the page  
get their own snapshots (e.g., $S_1$) all pointing to the single copy $C_L$.
The page's read-only status causes the hardware to fault on any write,
notifying \tiktok to transition the page to the next state.
In \autoref{fig:doublefetch_tiktok}, the page transitions to state 1 when 
the syscall first reads it, and adds a snapshot $S_0$.

\paragraph{State 2}
A page in State 1 transitions to the \texttt{(unprotected, duplicated)} state 
on any write from user or kernel code.
\tiktok duplicates the old contents of the page from copy $C_L$, creating a 
read-only copy $C_0$ (shown by green shading in \autoref{fig:tiktok_states}).
Snapshots except $L$ (i.e. $S_0$ and $S_1$) previously mapping to $C_L$ are 
mapped to the copy $C_0$.
The write then modifies the latest copy $C_L$, which is now made writable.
Note how, at this state, any read using the snapshots $S_0$ or $S_1$ reads 
from the unmodified copy $C_0$ while writes directly affect $C_L$.
Certain syscalls such as \Code{rt_sigaction} both read and write from 
the same user page. 
A write by \Code{rt_sigaction} to the page it has previously read will update
the page's latest copy $C_L$, but not the duplicate copy $C_0$.
This ensures that the copy $C_L$ always holds the latest contents of the page, 
up-to-date with all the writes to the page, from both user and kernel code. 
Further, \tiktok does not need to merge writes from userspace and syscall code
on a syscall's completion, since both directly modify the same copy $C_L$.
All other copies $C_i$ are immutable.
When the attacker writes to the page in \autoref{fig:doublefetch_tiktok}, the
page moves to state 2, linking the snapshot $S_0$ to a copy holding the 
original value $42$.
The writes from both the adversary and the syscall itself both affect 
the copy $C_L$, but the read from the syscall accesses the snapshot $S_0$
and reads the same value as the first time.


\paragraph{State 3}
A separate syscall subsequently reading the page in State 2 transitions 
it to \texttt{(protected, duplicated)} state. 
The new snapshot, $S_2$, points to the latest copy $C_L$.
State 3 is similar to state 1, except that there are different copies of 
the page used for reading by different syscalls. 
The syscall for which $S_0$ was allocated will read from the copy $C_0$,
while the syscall for which $S_2$ was allocated will read from copy $C_L$.
On a write, the page will transition to state 2 and will be duplicated again,
creating another copy $C_1$: snapshot $S_2$ will map to $C_1$ while 
snapshots $S_1$ and $S_0$ will continue to map to $C_0$. 

\paragraph{Releasing snapshots}
\tiktok uses snapshots to enable a syscall to read the same data from a page 
during its lifetime and releases snapshots when syscalls complete. 
Releasing a snapshot is possibly accompanied by a state transition
and the release of the mapped copy.
If $S_i$ mapped to the latest copy $C_L$, \tiktok cannot free the copy
since userspace is using it.
In this case, the page must be in state 1 or 3, and $C_L$ is read-only.
After removing $S_i$, if $L$ is the sole remaining snapshot mapped to $C_L$, 
\tiktok makes the page writable, moving to states 0 or 2 from states 
1 or 3 respectively. 
If $S_i$ is mapped to any other duplicate $C_i$, \tiktok frees the copy along
with the snapshot if $S_i$ is the last remaining snapshot mapped to $C_i$.
If the page was in state 2, $C_L$ was writable and unmapped by any snapshot,
so \tiktok changes the page to state 0.
This transitions is shown in \autoref{fig:doublefetch_tiktok}, where the 
snapshot $S_0$ and the copy $C_0$ are both discarded.
If the page was in state 3, $C_L$ was read-only and mapped by some other
snapshot, so \tiktok moves the page to state 1.

Under \tiktok, all writes are affected on to a single copy of the page $C_L$,
maintaining correctness for syscalls writing concurrently to the page while
eliminating the need for merging snapshots when syscalls complete.
On non-\tiktok systems, writes to a page from syscalls running concurrently
are interleaved onto the page based on what order these writes were 
executed. 
The same syscalls protected by \tiktok write to the latest snapshot $L$ (i.e. 
the copy $C_L$), and the final state corresponds to an interleaving of these
writes, just as in the non-\tiktok case.
The snapshots $S_i$ is immutable, can be dropped without requiring page 
merging, as described in the previous paragraph.


\subsection{Discussion}

\begin{table}
\begin{center}
\begin{tabularx}{\columnwidth} { | l | X |}
\hline
System Call & Exemption reason \\
\hline
\hline
\Code{futex} & Relies on concurrent write \\ \cline{1-2}
\Code{poll} & Relies on concurrent write \\ \cline{1-2}
\Code{ppoll} & Relies on concurrent write \\ \cline{1-2}
\Code{select} & Relies on concurrent write \\ \cline{1-2}
\Code{pselect6} & Relies on concurrent write \\ \cline{1-2}
\Code{rt\_sigtimedwait} & Relies on concurrent write \\ \cline{1-2}
\Code{execve} & Remaps address space \\ \cline{1-2}
\end{tabularx}
\end{center}
\caption{System calls uninstrumented by \tiktok}
\label{tab:except_syscall}
\end{table}
\paragraph{Exceptions}
Certain syscalls such as \Code{futex} rely on user data changing between 
double fetches to implement their functionality and cannot be protected by
\tiktok.
Such syscalls are listed in \autoref{tab:except_syscall}.
The \Code{futex} syscall implements a fast synchronization mechanism
for userspace and relies on atomic writes from concurrent userspace
threads to update a condition the syscall is waiting for. 
Subjecting a \Code{futex} syscall to \tiktok's invariants will prevent
it from ever waking up the waiting task.
Such syscalls cannot be protected by \tiktok, and we implement an 
exception list to prevent transitions in the state machines of pages read 
by these syscalls.
The code for these syscalls must be manually inspected for double-fetch 
vulnerabilities.
Crucially, exempting these syscalls from \tiktok's protection does not 
affect the security of other syscalls. 
Any writes from these syscalls are subject to the same rules described
in the state machine, and cannot break \tiktok's invariants.


\paragraph{Syscalls with read-write-read patterns}
A hypothetical syscall which reads from an object, writes to it, and
then reads back the updated object cannot be protected using \tiktok.
\tiktok's invariant will ensure that the second read is identical to the first,
and does not reflect the intermediate write. 
Such syscalls will also need to be exempted from \tiktok's instrumentation.
The authors did not find any syscall which exhibits this behavior in the Linux
kernel. 

\paragraph{Syscalls with false sharing}
Another hypothetical syscall could face problems with \tiktok's 
instrumentation due to false sharing. 
Suppose a page contains two objects, $O_0$ and $O_1$, and a syscall  
sequentially reads $O_0$ then $O_1$.
Due to \tiktok's invariant being enforced at page-granularity and 
false-sharing of the page between these objects, \tiktok guarantees that
the value of object $O_1$ read is the same as what was contained when it 
first read object $O_0$. 
A syscall which requires the value of $O_1$ to change between these two 
points in time would, therefore, not work with \tiktok protections. 
We believe that such a syscall, requiring concurrent modifications to its 
arguments, will likely exist to support some synchronization mechanism 
similar to a \Code{futex} and can be safely exempt from \tiktok's invariant.
The authors did not find any syscall which exhibits this behavior in the 
Linux kernel. 


\paragraph{Preventing deadlocks by design}
\tiktok's design is free of deadlocks, and exempts syscalls which 
require violation of its invariant from triggering particular 
state-machine transitions.
Userspace reads always succeed, using the latest copy $C_L$ of the
accessed page.
Writes from userspace and kernel code succeed directly if the 
page is in states 0 or 2, and trigger a fault otherwise.
Handling these faults involves creating a new copy of the page and
setting the page writable. 
Reading from kernel code involves creating a new snapshot and 
setting the page read-only.
None of the aforementioned operations relies on other operations 
on the same page to complete and all are finite-time.
None of the operations on a page rely on operations on other pages.
A single, per-page lock can serialize operations on that page
and assure forward progress.

\paragraph{Detecting double fetches}
\tiktok's state machine for pages also allows it to be used as a 
sanitizer since it can detect, and therefore report when a syscall 
double fetches from the same page.
When a syscall first reads from a user page, it creates a snapshot 
of that page.
On future reads, the snapshot is used in order to maintain the 
invariant.
This means that for reading from a page, implementations must check 
if a snapshot exists for the syscall: if yes, the snapshot is used
for the read, otherwise a new snapshot is created and then used 
for the read. 
The prior existence of a snapshot means that the syscall had previously
read from this page and had then created this snapshot, implying a double 
fetch.
This approach, however, is prone to false positives due to false sharing.
The two reads might read from the same page, but might access entirely 
disjoint bytes. 
\tiktok's design does not currently allow us to prevent such false positives.

%%%%%%%%%%%%%%%%%%%
\section{\tiktok implementation}
\label{sec:impl}
%%%%%%%%%%%%%%%%%%%

The \tiktok prototype implements the state machine described in 
\autoref{sec:design} on Linux version 5.11, targeting the x86-64 
architecture. 
A page protected by \tiktok transitions between states on 
either a kernel read to user memory, or when user or kernel code
writes to read-only memory (see \autoref{fig:tiktok_states}).
\tiktok can be implemented on any operating system kernel that uses 
a defined interface for reading from userspace (\Code{read_in}) and
on any architecture which implements hardware-controlled access 
control to memory through page tables. 
The first requirement enables \tiktok to implement transitions on 
kernel reads from user memory.
The Linux kernel uses the \Code{raw_copy_from_user} interface which 
we instrument for our prototype.
The second requirement causes the hardware to raise a faults, 
directing execution on the processor to a pre-defined exception 
handler in the OS.
Our prototype instruments the Linux' fault handler in the function 
\Code{handle_pte_fault} to implement the write-triggered transmissions 
from states 2 and 4.


\subsection{Tracking page state}

\begin{figure}[]
  \includegraphics[width=\linewidth]{img/book-keeping.pdf}
  \caption{Bookkeeping information for a page}
  \label{fig:tiktok_bookeeping}
\end{figure}

\tiktok needs to track the state for every userspace page, including
its snapshot and copy sets.
\autoref{fig:tiktok_bookeeping} shows the data structures used to
track this state in our prototype.
Linux maintains a \Code{struct page} object for every frame of 
physical memory. 
We augment this structure with a list holding the snapshots
for this page, excluding the latest snapshot $L$.
Each snapshot has a pointer to its copy. 
In the figure, the snapshots $S_1$ and $S_0$ share the copy $C_0$.
The authors are aware of the strong aversion of the 
Linux kernel developer community towards increasing the size of 
\Code{struct page}. 
An alternate implementation can use a hashmap to
map from a page's frame number to its snaphots list or
reuse existing data members (e.g., \Code{struct list_head lru} which 
can be used as a generic list by page owners).

Each pagetable entry for this page in different address spaces 
map the copy $C_L$, enabling userspace to directly access this
copy with reads (and writes for writable pages).
We use one software-controlled bit (SW3) in the pagetable entries 
to track the protection status of the page, and another (SW2)\footnotemark
to track the original protections for the page. 
SW3 is set whenever the page is in one of the two protected
states (1 and 3).
On a write-triggered protection fault, SW3 can be read to 
efficiently determine if the fault was due to \tiktok's protection 
mechanisms, triggering a state change, or due to buggy software
accessing a page with illegal permissions, triggering a signal to 
the task.
Other architectures might have a fewer number of software-usable 
bits in the page-table, and implementations of \tiktok would 
require storing the protection status of pages in a separate data structure.
The duplication status of the page is implicitly encoded in the 
snapshots: the page is duplicated when any of its snapshots
holds a pointer to a copy other than $C_L$.

\footnotetext{The SW2 bit is also used by the Software Dirty Pages feature of 
Linux, and cannot be run alongside \tiktok in our prototype.}

Changing the protection state of pages requires updates to 
PTEs for the page in all address spaces where the page is mapped.
The page's \Code{struct page} structure includes a reverse-map
listing all of these address pages, and the corresponding virtual
address in each.

\subsection{Kernel reads from user memory}

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=C, 
  caption={Pseudo-code for kernel copy from user memory},
  label=code:rawcopyfromuser,  breaklines=true, captionpos=b,
  postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space},
  numbers=left,basicstyle=\scriptsize, xleftmargin=5.0ex]
raw_copy_from_user(dest, __user source, size) {
  void *copy_ptr;

  foreach page_va in range(source, source + size) {
    // Walk page table to find page frame
    struct page *page = walk_page_table(page_va);

    if page has snapshot for this task { 
      // Find the correct copy to read from
      if page in state 1
        // Read from C_L
        copy_ptr = page_address(page); 
      else 
        // page is in states 2 or 3
        // Read from another copy
        copy_ptr = find_snapshot(page->snaphots_list, current)->copy;
    } else {                             
      // Create a new snapshot pointing to C_L
      list_add(new snapshot, page->snaphots_list);

      // Add page to those protected for the 
      // current task's task_struct
      list_add(page, current->protected_pages_list);

      // Protect page in all address spaces
      rmap_walk(...);

      // Read from C_L
      copy_ptr = page_address(page);     
    } 
    // Perform the actual copy within the page
    memcpy(dest, source, size);
  }
}
\end{lstlisting}
\end{minipage}

Syscalls reading from user memory the first time triggers the 
allocation of a new snapshot. 
If the page is not protected (states 1 and 3), this also 
triggers a state change where the kernel protects the page
in all address space that it is mapped in. 
\autoref{code:rawcopyfromuser} shows the pseudocode for 
\Code{raw_copy_from_user}, which implements this functionality
in our prototype.

\atri{TODO: write why write is not vulnerable to double fetch}
\section{Evaluation}

In this section, we quantify \tiktok's overhead on workloads 
with different characteristics, both compute-bound applications
which rarely use syscalls and I/O-bound applications which 
heavily rely on the kernel's I/O interface.
\tiktok's overhead depends on the number of address spaces 
where protected pages are mapped. 
Relevant benchmarks therefore include multiprocessing, parallel 
benchmarks.

We evaluate \tiktok on two benchmark suites: the NAS Parallel 
Benchmark (NPB)~\cite{npb} and select workloads from the 
Phoronix Test Suite (PTS)~\cite{pts}. 
NPB includes CPU-bound multiprocessing workloads with a 
low, but non-negligible syscall rate. 
NPB therefore demonstrates the ability of \tiktok to 
scale to systems where pages are protected across numerous 
address spaces.
PTS includes a variety of benchmarks, both CPU-bound and 
I/O bound representative of both desktop and server workloads.
PTS includes syscall-heavy applications with varying degrees 
of parallelism.
We do not include CPU benchmarks from the SPEC benchmark suite
as they are heavily CPU bound and designed to isolate userspace 
performance without syscalls, and therefore do not test kernel 
performance.

The testbench for the evaulation consists of a desktop machine 
with an 8-core Intel i7-9700 processor and 16GB DRAM running 
Ubuntu 20.04 LTS.
To eliminate the effect of dynamic frequency and voltage 
scaling (DVFS), we set the processor to run at constant 
frequency of 3.0GHz which is this model's base frequency.
In the \emph{baseline} configuration, we run the testbench 
with the mainline kernel v5.11 available from Ubuntu's package 
repository.
The \emph{\tiktok} configuration runs our prototype \tiktok kernel 
based on kernel v5.11.
For particular benchmarks, we also run the \emph{\tiktok-extra}
configuration which also runs our prototype \tiktok kernel
but instruments all syscalls including \Code{write}.

\subsection{NAS Parallel Benchmarks}

\begin{figure}[]
  \includegraphics[width=\linewidth]{img/npb_performance.pdf}
  \caption{\tiktok performance on NPB benchmarks relative to baseline with 
          the same parallelization technique}
  \label{fig:npb_performance}
\end{figure}

NAS Parallel Benchmarks (NPB)~\cite{npb} is a benchmark introduced by
NASA. 
NPB consists of several parallel programs using different communication
patterns and is available for two technology stacks for parallel programming:
OpenMP and MPI.
% Two variants that test either threads or processes
OpenMP~\cite{dagum1998openmp} is a compiler extension that splits a 
program's execution to multiple threads. 
All threads still use the same address space, keeping the overhead minimal. 
MPI~\cite{snir1998mpi} implements parallel execution by launching multiple
processes which communicate by message-passing. 
The two technology stacks have different frequency of syscalls due to 
different communication methods.
Communication through kernel syscalls for either stack will incur overhead
due to \tiktok's protection.
Additional global TLB shootdowns added by \tiktok will also affect the 
performance of such parallel benchmarks.

We evaluated NPB benchmarks of class A on our testbench, running 
4 threads/processes in parallel.
These benchmarks' runtime varies between 10 seconds and 8 minutes, 
and are all long enough for the kernel to reach equilibrium.
Certain benchmarks require a parallelism number which is a perfect square.
On our 8-core CPU, having 4 CPU-bound threads/processes instead of 16 allows 
all of them to run without time-sharing.
\autoref{fig:npb_performance} shows \tiktok's performance for both MPI and OpenMP 
normalized to the performance of the baseline system with the same parallelization
technique for the NPB benchmarks.
On average, \tiktok achieved $96.3\%$ of the baseline system's performance with 
both 
On both systems, \tiktok's performance for the \Code{ep} (Embarassingly Parallel)
benchmark is closest to that of the baseline, since it has low 
communication overheads.
\tiktok shows low overhead ($3.7\%$) for CPU-bound workloads, even when they 
involve parallelism.

\subsection{Phoronix Test Suite}

\begin{figure}[]
  \includegraphics[width=\linewidth]{img/pts_performance.pdf}
  \caption{\tiktok performance on PTS benchmarks relative to baseline system}
  \label{fig:pts_performance}
\end{figure}

The Phoronix Test Suite (PTS)~\cite{pts} includes a large set of 
open-source benchmarks, of which we have chosen a range of benchmarks 
suitable for evaluating both desktop and server performance.
These benchmarks complement those from NPB and range from single-threaded, 
CPU-bound applications (OpenSSL) to multi-threaded, multi-process 
programs, syscall-heavy server programs (Apache).

We plot \tiktok's performance relative to the baseline kernel on
these benchmarks in \autoref{fig:pts_performance}, roughly ordered 
workloads in increasing order of syscall dependence from left to right.
For benchmarks for which PTS reports runtime, we compute the inverse 
of the runtime as performance.
Benchmarks with low syscall frequency such as OpenSSL, 
Pybench and Git have correspondingly low dependence on kernel performance.
Accordingly, these benchmarks see a negligible overhead when running 
on our prototype kernel.
The benchmark titled ``Linux'' represents compilation of the Linux kernel.
While compilation is mostly CPU bound, compiling the Linux kernel requires 
compilation of a large number of source files, resulting in the creation 
of a large number of compiler processes each of which read different files. 
\tiktok experiences a small, but non-negligible overhead on this workload.
Redis requires syscalls for receiving and replying to requests, but 
processes its transaction entirely in-memory. 
Our evaluation prototype version achieves almost identical performance
as the baseline kernel.
However, Redis' performance on earlier, less optimized prototypes showed
significant degradation in performance (upto $69\%$).
The webservers, Apache and Nginx require network and file-system I/O, 
and rely heavily on syscall performance. 
We see that Nginx, which is a higher-performance webserver, sees a larger
overhead.
Fs-mark, which accesses a filesystem with 5000 files of 1MB concurrently
from 4 threads, and IPC, which implements 128 byte transfers between 
two processes over a TCP connection, are almost entirely bound by kernel 
performance. 
These benchmarks see a performance overhead of upto $10\%$ on \tiktok.

Our prototype \tiktok kernel benefits significantly from 
exempting particular, proven-safe syscalls from instrumentation.
While we exclude \Code{write}-like syscalls from \tiktok because they 
are not vulnerable to double-fetch bugs, we also evaluated the
performance cost of a na\"ive implementation (\tiktok-extra)
which also instruments these syscalls.
To highlight the worst-case performance of the na\"ive approach, we 
evaluate the performance of the IPC benchmark on \tiktok-extra due 
to its high frequency of \Code{write} syscalls.
From \autoref{fig:pts_performance}, we see that the benchmark's 
performance is further degraded by $81\%$ compared to \tiktok, 
showing that developer effort towards properly exempting 
frequently called syscalls from \tiktok protections is crucial
towards for implementations to maintain competitive performance
compared to the baseline.

\section{Trash}
\todo{Limitations: raw\_copy\_from\_user\_inatomic}

\todo{Discuss how Midgard would help}

\todo{In implementation, discuss how IOMMU's can be used to prevent devide writes,
but is currently unsupported.}

\bibliographystyle{plain}
\bibliography{TikTok}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%  LocalWords:  endnotes includegraphics fread ptr nobj noindent
%%  LocalWords:  pdflatex acks
