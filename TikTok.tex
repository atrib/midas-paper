%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Template for USENIX papers.
%
% History:
%
% - TEMPLATE for Usenix papers, specifically to meet requirements of
%   USENIX '05. originally a template for producing IEEE-format
%   articles using LaTeX. written by Matthew Ward, CS Department,
%   Worcester Polytechnic Institute. adapted by David Beazley for his
%   excellent SWIG paper in Proceedings, Tcl 96. turned into a
%   smartass generic template by De Clarke, with thanks to both the
%   above pioneers. Use at your own risk. Complaints to /dev/null.
%   Make it two column with no page numbering, default is 10 point.
%
% - Munged by Fred Douglis <douglis@research.att.com> 10/97 to
%   separate the .sty file from the LaTeX source template, so that
%   people can more easily include the .sty file into an existing
%   document. Also changed to more closely follow the style guidelines
%   as represented by the Word sample file.
%
% - Note that since 2010, USENIX does not require endnotes. If you
%   want foot of page notes, do not include the endnotes package in the
%   usepackage command, below.
% - This version uses the latex2e styles, not the very ancient 2.09
%   stuff.
%
% - Updated July 2018: Text block size changed from 6.5" to 7"
%
% - Updated Dec 2018 for ATC'19:
%
%   * Revised text to pass HotCRP's auto-formatting check, with
%     hotcrp.settings.submission_form.body_font_size=10pt, and
%     hotcrp.settings.submission_form.line_height=12pt
%
%   * Switched from \endnote-s to \footnote-s to match Usenix's policy.
%
%   * \section* => \begin{abstract} ... \end{abstract}
%
%   * Make template self-contained in terms of bibtex entires, to allow
%     this file to be compiled. (And changing refs style to 'plain'.)
%
%   * Make template self-contained in terms of figures, to
%     allow this file to be compiled. 
%
%   * Added packages for hyperref, embedding fonts, and improving
%     appearance.
%   
%   * Removed outdated text.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[letterpaper,twocolumn,10pt]{article}
\usepackage{usenix2019_v3}

% to be able to draw some self-contained figs
\usepackage{tikz}
\usepackage{amsmath}

\usepackage{listings}
\usepackage{parcolumns}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{cleveref}
\usepackage{hyperref}

% Comment macros
\newcommand{\pra}[1]{\textcolor{blue}{\textbf{PS:} #1}}
\newcommand{\nb}[1]{\textcolor{green}{\textbf{NB}: #1}}
\newcommand{\mat}[1]{\textcolor{red}{\textbf{Mat:} #1}}
\newcommand{\evalfull}[1]{20}
\newcommand{\evalnocalls}[1]{3}
\newcommand{\sysname}{TikTok}


%-------------------------------------------------------------------------------
\begin{document}
%-------------------------------------------------------------------------------

%do not want date printed
\date{}

% make title bold and 14 pt font (Latex default is non-bold, 16 pt)
\title{\Large \bf TikTok: Kernel TOCTTOU Protection}

%for single author (just remove % characters)
\author{
Anonymous submission \#TODO to Usenix SEC21
%{\rm Eric Tusso}\\
%EPFL
%\and
%{\rm Yamaha Priest}\\
%EPFL
% copy the following lines to add more authors
% \and
% {\rm Name}\\
%Name Institution
} % end author

\maketitle

%-------------------------------------------------------------------------------
\begin{abstract}
%-------------------------------------------------------------------------------

Double-fetch bugs have been discovered in all the major operating systems.
They occur when the data has been fetched across the trust-boundary the second
time without verifying that it is unchanged. This leaves the kernel in an
inconsistent state, making it possible to access illegal memory.

Today, the solution for double-fetches is to detect and fix them. However, they
exhibit illegal behavior only under specific conditions, making the detection
hard. Even then, the actual fixes may not address the problem. Finally, the bug
could be in the code that cannot be changed (e.g. binary blob), rendering this
approach useless. We propose \sysname - the mitigation for double-fetches.
\sysname relies on page-tables to prevent changes to the system call arguments,
while the call is executing.

\sysname shows no noticable drop of performance when evaluated on CPU-bound
workloads. On workloads with a large number of system calls, \sysname shows less
than 5\% when protecting rare system calls, and 20\% when all of the system
calls are secured.


\end{abstract}
% Talk about the system call filters and how they can be used for good
% Introduce the main problem - TOCTTOU
% Brag how our system is the best thing since sliced bread
\section{Introduction}


% Syscalls are a lucrative attack surface for adversaries which needs to be protected
To improve security systems are partitioned into an \emph{untrusted} and a
\emph{trusted} zones by a \emph{trust boundary}. All data that crosses the trust
boundary from the untrusted zone must be verified.
Double-fetches\cite{serna08doublefetch, twizsgrakky07ring0, wilhelm2016xenpwn,
wang2018survey} occur when a higher-privileged code (e.g., the kernel) reads the
same data twice from the lower-privileged space (e.g., user-space). In-between
the two reads, the data can be changed concurrently. This makes double-fetches a
type of a \emph{race condition} between the two threads of different privileges.
\emph{Time-of-check to time-of-use (TOCTTOU)} occurs when the first read is used
in a check, while the second one is used for processing. Many double-fetch bugs
have been found in different kernels and hypervisors~\cite{cve201812633,
cve202012652, cve20131332, cve201920610, cve20158550, cve201610439,
cve201610435, cve201610433, cve20195519, cve20168438}. Considering that
double-fetches frequently appear in drivers, legacy systems with binary drivers
currently have no solution for them. Furthermore, Watson~\cite{watson2007} blames
an unfixable TOCTTOU bug as a reason why \emph{system call wrappers} aren't
secure. A system that mitigates double-fetches in system calls is needed to
protect the kernel in case the bugs cannot be fixed.


% Define our goal
A system that mitigates double-fetches needs to:
\begin{enumerate}
  \item Prevent the change of the user memory accessed by the system call
  \item Enable correct system call execution
  \item Enable correct execution of threads trying to change the arguments
\end{enumerate}


\begin{figure}[]
  \centering
  \includegraphics[width=.85\linewidth]{img/tocttou.pdf}
  \caption{Bypassing a system call filter using a TOCTTOU attack}
  \label{fig:tocttou}
\end{figure}

% Cover the first point
Double-fetch bugs occur when an adversary invokes a system call with arguments
stored in memory. The kernel will read the arguments the first time and perform
corresponding checks. If the timing is perfect, the adversary can use the
additional thread under their control to change the arguments, right after the
necessary checks have been finished. In case of the double-fetch bug, the kernel
will read in the values again and presume that they haven't changed.

The main issue is that the adversary was able to change values in the memory
while the system call was still executing. \sysname fixes double-fetch bugs by
preventing the adversary from writing to the arguments, until the end of the
system call. This is accomplished by extending the API for reading from user
space to mark the pages containing arguments in the \emph{system page table} as
\emph{read-only}. All of the writes to those pages will trigger a \emph{page-fault}
and execute a \emph{page-fault handler}. In the handler, they will wait for all
the system calls to finish, and continue execution. \sysname thus prevents the
changes to the system call arguments.

% Cover the second point. Mention the calls for which it makes no sense to protect
Enabling writes to the marked pages from the kernel would enable the adversary
to abuse system calls to write and change the arguments. Prevention of writes
from the kernel is also necessary to stop the arguments from being changed.

Unfortunately, some system calls both read from and write into the same memory.
Such calls would first mark a page as read-only, and them fault and wait for
themselves (\emph{deadlock}) when they try to write. To accomodate such calls,
we extend the API for writing to user space to save and defer the writes into
the marked pages until the end of the call. At that time, they can be either
successfully performed, or safely wait for other system calls to also end and
unmark the pages.

By introducing these changes to the API for reading from and writing into userspace,
system calls turn into transactions. They have a view of the memory frozen in time
when each memory location has been read for the first time, while all the writes
are executed together (commited) at the end of the call.

A small subset of system-calls (e.g. \texttt{pollfd}, \texttt{futex}) depend on
the writes from user-space or double-fetches for the correct behavior. Also,
system calls that read memory and potentially take a long time to execute will
keep those pages marked during their execution. \sysname must be disabled for
such calls and they need to be manually inspected for double-fetches.

By turning system calls into transactions and ignoring certain calls, \sysname
guarantees the correct execution of the system with the protections enabled.

% Cover the third point
Writes from the user-space will trigger a \emph{page-fault handler} where they
will wait for the unmarking. All the offending threads will therefore be stopped.
After all the system calls exit, the threads waiting for them to free arguments
will continue the execution by repeating the write. All of them will execute
correctly -- after a short delay.

% Introduce TikTok
We present \sysname --- a memory marking extension to the Linux kernel. \sysname
provides system-calls with a checkpointed view of the memory at the time they
have been read the first time. \sysname also groups all the writes in a system
call into a transaction which is executed at its end. By mitigating
double-fetches, \sysname provides protection even against the double-fetch bugs
even in legacy drivers, which are not maintained any more. Furthermore, \sysname
will render previously unavoidable double-fetches (such as a TOCTTOU in
system-call wrappers) completely benign and safe to use. \sysname works on modern
Linux distributions (Ubuntu Server 18.04 LTS) and doesn't require any
modifications to user programs. It can be implemented in other kernels
and architectures which use page-tables and a well defined API to communicate
with the user space.

% Sneak-peek into the results
Benchmarking \sysname showed that multithreaded programs with lots of marking
system-calls, such as Apache and NginX, show an 18\% drop in performance with
TikTok protecting almost all the system-calls. By reducing the number of
protected calls, the overhead drops to 2-4\%. CPU-bound programs showed almost
no performance drop when using \sysname, even when they comprised multiple
threads and message passing (OMP, MPI).
\mat{Create marcos for overhead.}


% Three new things in this paper
The main contributions of this paper are:


\begin{itemize}
\item A technique how to temporarily prevent the change of memory by safely
      postponing both userspace and kernel threads
\item \sysname --- mitigation for the double-fetch and TOCTTOU attacks on system
      call arguments in the Linux kernel
\end{itemize}

% Cover the theory needed to understand how and why TikTok works
% 1) IPC - We need this to argue why the deadlocks are almost impossible
% 2) VM and Page Tables - Why it exists and how it works
% 3) x86 Page Tables - Continue the discussion from the previous section
% 4) Page faults - Explain how and why they happen.
% 5) Copy to/from user - Explain why the API has been introduced
% 6) Double-fetches - Provide a high-level overview
\section{Background}
\label{sec:background}

\sysname relies on multiple Linux subsystems to provide its protection. It uses
\emph{page-tables} to mark \emph{shared memory} storing the system call
arguments as \emph{read-only}. Different system calls have different
relationships with shared memory, and interact with \sysname differently in
practice. This section provides the background information necessary to reason
why \sysname protects the arguments from change, while enabling the threads to
execute correctly.

% I want to cover why this background is needed. IPC is the most problematic
% because it is used to justify the abscence of deadlocks
\autoref{subsec:ipc} introduces two different ways of communication between
processes - \emph{shared memory} and \emph{message-passing}. \sysname affects both
of these methods because the arguments of the message-passing system calls are
stored in (potentially shared) memory. If \sysname marks message-passing
system-call arguments, this introduces additional synchronization points (waits)
when writing to them. These new waits can interact with already present
synchronization primitives to cause deadlocks. In \autoref{sec:deadlocks} it is
explained why they do not appear in practice.

\autoref{subsec:vm} covers the organization of \emph{virtual memory},
\emph{page-tables} and the interface the Linux kernel uses to access the user
space memory. This section is essential to understanding the implementation of
\sysname.

\autoref{subsec:doublefetch} details the \emph{double-fetch} bug that \sysname
is mitigating. It explains the source and different types of double-fetch bugs.


\subsection{Interprocess Communication}
\label{subsec:ipc}

The two main types of communication between processes are \emph{shared memory} 
and \emph{message passing}~\cite{silberschatz2018operating}.

% Intro to shared-memory
Shared memory relies on two processes having a section of memory that both can 
access. Data transfer is fast, but the synchronization is problematic. 
Processes must monitor shared memory for changes, leading to unnecessary
polling.

% Intro to message-passing
Message passing consists of one process calling send, and another one calling
receive to fetch the message. Synchronous message passing blocks execution until
the execution of the calls has finished. However, on systems with shared memory
unnecessary copying of messages can occur instead of passing the same buffer to
the receiver.

% The state of the modern OSs and concurrent programs
Modern operating systems support both of these approaches. \sysname interferes
with message passing system calls by linking them to shared memory. Synchronous
message passing calls will keep their arguments marked, until they end. This
behavior introduces additional synchronization points and can be problematic if
the threads also share memory.

\subsection{Linux Memory Subsystem} \label{subsec:vm}


% Paged VM and the introduction to permissions we will later use in TikTok
Linux uses \emph{Paged virtual memory}. Programs use \emph{virtual addresses}
which map to \emph{physical addresses} in RAM. The mapping function is defined
for each process by a multi-level \emph{page-table}.

\begin{figure}[]
  \centering
  \includegraphics[width = .35 \textwidth]{img/pagetable.pdf}
  \caption{Page Table Structure on x86. Only relevant data has been included.}
  \label{fig:pagetable}
\end{figure}
x86-64 architecture officially supports paged virtual memory model with a 5 
level page table (\autoref{fig:pagetable}):
\begin{description}
    \item[PGD] Page Global Directory
    \item[P4D] Page Fourth-level Directory
    \item[PUD] Page Upper Directory
    \item[PMD] Page Middle Directory
    \item[PTE] Page Table Entry
\end{description}

% The flags are needed to discuss marking
Every level corresponds to eight bits in the virtual address, with the remaining twelve
bits identifying the offset in the actual page frame. A page table entry
includes the following information:
\begin{description}
    \item[Present bit (\textbf{P})] is set if the page is present in memory
    \item[Read/Write bit (\textbf{R/W})] denotes if the page is writable or just
         readable
    \item[User/Superuser bit (\textbf{U/S})] represents if the page can be 
    accessed by the user, or only by the superuser
    \item[Not Executable bit (\textbf{NX})] is set if the code stored on the 
    page cannot be executed
    \item[Page Frame Number] denotes the page frame the entry points to
    \item[\textbf{SW1-SW4}] Four bits free for the OS to use
\end{description}

Considering that the page-table traversal is frequent, it is implemented in
hardware by the \emph{memory management unit} (MMU). Reading the page-table from
memory is slow, so a small cache --- \emph{translation-lookaside buffer} (TLB)
--- is added to the MMU to store frequently accessed page entries. On modern
processors, a TLB consists of several levels, and can even be backed by another
MMU cache. Kernel developers can \emph{flush} (clear) certain TLB ranges in
software.

% Explain what a page fault is, as well as COW (mentioned later as an optimizaiton)
On an invalid access (e.g., wrong permissions, page not present) the MMU will
trigger a page-fault. The page-fault handler executes in the kernel context of
the faulting thread and performs the appropriate action (e.g. load a page, kill
a thread). With the advent of cloud computing, \emph{user-space page-fault
handling} has been added to the Linux kernel. \sysname relies on the page-fault
handler for protection, so this feature must be disabled.

Memory in Linux can be either \emph{file-backed} or \emph{anonymous}.
File-backed pages have a map to the corresponding file. Anonymous pages do not
have a backing file (e.g., stack and heap).

Another classification is based on privacy: \emph{private} and \emph{shared}. 
Private memory is part of only one virtual memory space. This memory space can 
be accessed by multiple threads in a process, but no threads outside the process
have access. Shared memory can be accessed by multiple processes.

% This is the most important paragraph and a basis for one of the attacks. The
% previous two paragraphs are just the introduction
Unlike private memory and shared anonymous memory, shared file-backed memory can
be \emph{mapped and unmapped at will}. Its content is backed by a file, so the
data is \emph{preserved} between (un)mappings.

\subsection{Copy-from-User and Copy-to-User}
\label{subsec:copy}

Linux user a well-defined interface to communicate with the user-space:
\texttt{(\_\_)copy\_(from/to)\_user}, \texttt{(\_\_)(get/put)\_user},
\texttt{user\_str(cpy/len)}. BSD also provides a similar interface using
\texttt{copy\_in} and \texttt{copy\_out} functions.

The abstraction is needed due to different handling of page-faults in user-space
and in the kernel. User-space memory can be \emph{paged-out} to the disk, and
trigger a page-fault on access. However, kernel memory is never paged-out and
should not cause a page-fault. All the user-space pointers in the kernel are
processed by this limited set of functions that know how to handle a fault.

\sysname extends this interface to perform additional checks and bookkeeping of
marked pages.

\subsection{Double Fetch Bugs}
\label{subsec:doublefetch}

\mat{This is actually essential and one of the main parts of the BG!}

\begin{figure}[]
  \centering
  \includegraphics[width=.85\linewidth]{img/doublefetch.pdf}
  \caption{Diagram of a double-fetch bug}
  \label{fig:doublefetch}
\end{figure}

\begin{lstlisting}[language=C, caption=Abridged CVE-2018-12633 Double Fetch in Linux,
                  label=code:cvedoublefetch,  breaklines=true
                  postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space},
                  numbers=left,basicstyle=\scriptsize]
static long vbg_misc_device_ioctl(
        struct file *filp,
        unsigned int req,
        unsigned long arg)
{
  size_t size;
  struct vbg_ioctl_hdr hdr;
  void *buf;

  if (copy_from_user(&hdr, (void *)arg, sizeof(hdr))) 
    return -EFAULT;
  
  if (hdr.version != VBG_IOCTL_HDR_VERSION) 
    return -EINVAL;
   
  if (hdr.size_in < sizeof(hdr) || (hdr.size_out && hdr.size_out < sizeof(hdr)))
    return -EINVAL;
  
  ...
  
  if (copy_from_user(buf, (void *)arg, hdr.size_in)) {
		ret = -EFAULT;
		goto out;
  }

  ...

  ret = vbg_core_ioctl(session, req, buf);

  ...
}
\end{lstlisting}
% The idea behind double-fetch bugs
\emph{Double-fetch} bugs occur when a privileged environment (such as the
kernel) reads untrusted memory two or more times and the read values aren't
identical. (\autoref{fig:doublefetch}) In between those two reads, memory could
have been changed by an unprivileged adversary. Considering that this bug relies
on carefully timed accesses for two different threads, it is a variant of a race
condition. The situation where the first fetch validates the value of the
fetched variable, but the computation is only performed on the second fetch, is
called a \emph{time-of-check to time-of-use} (TOCTTOU) bug. TOCTTOU bugs have
been widely studied in file systems, where the API makes it possible to swap the
file after validating the access rights~\cite{payer2012protecting,
pu2006methodical, wei2010modeling, tsafrir2008portably}.

\autoref{code:cvedoublefetch} displays the double-fetch bug in the Virtual Box
drivers for the Linux kernel~\cite{cve201812633}. The first fetch occurs on line
10. The program performs gets a header and checks the arguments (lines 13 -- 17)
and fetches the whole argument into the variable \texttt{buf} (line 21). The new
value is then processed (line 27).

Note that the header is fetched twice --- on lines 10 and 21. This gives the
opportunity for the attacker to change the values in the header. Considering
that the header isn't verified the second time it is read, the attacker can
leave the kernel in an inconsistent state. The fix for this bug
(\autoref{cvedoublefetchfix}) doesn't fetch the header the second time. It
copies the header into \texttt{buf}, while the second fetch copies everything
except the header.

\begin{lstlisting}[language=C, caption=CVE-2018-12633 Double Fetch Fix,
  label=code:cvedoublefetchfix,  breaklines=true
  postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space},
  numbers=left,basicstyle=\scriptsize, firstnumber=18]
...

  *((struct vbg_ioctl_hdr *)buf) = hdr;
  if (copy_from_user(buf + sizeof(hdr), (void *)arg + sizeof(hdr), hdr.size_in - sizeof(hdr))) {
    ret = -EFAULT;
    goto out;
  }

...

\end{lstlisting}

% Double-fetches are actually so big that people have actualy spent time
% to study them
Wang et al. explain in \cite{wang2018survey} that double-fetches appear not only
in kernels, but wherever there is a trust boundary to cross (e.g., kernel ---
hypervisor~\cite{wilhelm2016xenpwn} and hardware --- kernel
boundaries~\cite{lu2018untrusted}). Double-fetches have been responsible for many
vulnerabilities in different kernels~\cite{jurczyk2013bochspwn, wang2018survey}.


\section{Threat Model}
\label{sec:threatmodel}
% Explain generally how TikTok works. We mention all the problems that
% TikTok needs to mitigate: writes from user-space, writes from the kernel, safely
% stopping the writes, preventing bypass using file-backed pages, system calls
% that are ignored. The most important part is showing the conditions for 
% introducing deadlocks
The adversary has access to a user account on a target machine. They can compile
and execute arbitrary code, including the system calls. Some of the system calls
have double-fetch vulnerabilities, and the adversary wants to exploit them to
obtain root access.

\section{Design}
\label{sec:design}

\subsection{Overview}
\label{subsec:designoverview}
% \nb{The paragraphs in this section don't flow really well.}

% Give the bare-bones intro to the attacks
TikTok protects the pages storing the system-call arguments by marking them
read-only. \autoref{sec:threatmodel} describes the capabilities of the attacker.

% \nb{I would introduce a bit more which attack is about, how they can take place,
% and clearly define what is correct behaviour.}

% List the attacks and explain every one in detail
\sysname needs to protect the arguments from different types of attacks and ways of
bypassing the protections. It must satisfy the following requirements:

\begin{enumerate}
  \item \label{first} Stop writes from user-space
  \item \label{second} Stop writes from the kernel
  \item \label{third} Prevent bypassing \sysname by mapping file-backed pages as writable
  \item \label{fourth} Prevent bypassing \sysname by using a write call
  \item \label{fifth} Prevent bypassing \sysname by mapping device-backed files
  \item \label{sixth} Let system calls execute correctly
\end{enumerate}

\subsection{Simplistic Design 1}
\label{simplistic1}
The simplest way to implement memory marking protection against writes from the
user-space is to mark pages as accessible only from the kernel. All modern 
architectures have support for the \emph{superuser} flag in the page-table
entries.

User-space writes to marked pages trigger a page-fault, where they wait for the
system call to end. Afterward, they continue to execute normally.

Some system calls (e.g., \texttt{rt\_sigaction}) need to write back to user
space memory to update the arguments. System calls execute with superuser
privileges, so this method lets them write successfully.


Unfortunately, even though this system seems to satisfy requirements \autoref{first} and 
\autoref{sixth}, it fails at the requirement \autoref{second}. The adversary can
easily bypass the protection by executing a \texttt{read} system call while the
pages are marked by another call. \texttt{read} takes a pointer to the destination
buffer as an argument, and executes with the superuser privileges. If the attacker
passes a marked page as an argument to \texttt{read} they will bypass the protection
against writes.

\subsection{Simplistic Design 2}
\label{simplistic2}
An alternative to using the superuser flag in the page-table entries to implement
protection is to use the read/write flag. By marking a page read-only we prevent
the bypass from \autoref{simplistic1}.

Unfortunately, marked pages are also unwritable for the system call marking them.
This makes \emph{self-writing} system calls \emph{deadlock} on themselves. The call
will mark a page when reading an argument from it, and then trigger a page-fault
when trying to write to it. In the page-fault handler it will wait for the page to 
get unlocked, which will never happen.

\subsection{Complex Design 1}
\label{complex1}
To enable self-writing, without compromising the protection against kernel
writes, \sysname needs to instrument both read and writes. Every \emph{virtual
memory space} structure is extended with the information on the currently marked
pages. When a system call marks a page, it is added to the interval-tree
containing marked intervals. At the end of the call, the pages are unmarked and
removed from the tree.

Before a write is performed, the system call checks if it is already marked.
Writes to marked pages are saved, and executed chronologically at the end of
the call, after unmarking the pages. If another thread marks the pages again,
the writes will wait in the page-fault handler to proceed.

Unfortunately, this design suffers from a serious flaw --- it deadlocks. The
access to the page-table and the interval-tree is protected by two separate
locks. When marking a page, the page-table lock must be taken first to locate
the page-table entries that need to be updated. Then, for every page-table
entry, the corresponding interval-tree lock is taken to add the marked address
ranges. When writing to user space, the interval-tree lock is taken first. If we
encounter a swapped-out page, the write will trigger a page-fault. In the
page-fault handler it will take a page-table lock. If two threads take multiple
locks in the different order, they can deadlock.

\subsection{Complex Design 2}
\label{complex2}
To prevent a deadlock one of the threads needs to back-off and try to repeat the
operation later. In \sysname the first thread to notice a deadlock backs off, and
releases its locks. After successfully reaquiring them, if the interval-tree has 
changed, the interrupted operation is restarted under both locks.

This system satisfies points 

\emph{Writes from user-space} consist of a malicious user trying to directly
write to the argument stored in memory, while the system-call is being executed
in another thread. The system-call should be unaffected, but the write should
still be performed.

\emph{Writes from the kernel} are indirectly triggered. The user performs a \texttt{read}
system-call with the target address as the destination. The data is then written
to this location by the \texttt{read} system-call with the kernel privileges.

\emph{Bypassing TikTok by mapping file-backed pages as writable} is accomplished
by mapping marked pages in another process. The user stores the arguments on a
file-backed page and maps the file as writable while the system call is executing.
They are then free to write to the marked arguments.
\mat{This is a threat, thwarted by your design. There's a fine difference
between telling a reader that you're aware of the risk and mitigate it and by
coming across as having a vulnerability in your design. Be careful.}

\emph{Bypassing TikTok by using a write call} is accomplished by calling a
\texttt{write} system-call on a file with arguments. Even though the arguments
cannot be changed by directly writing to them, it may be possible to bypass it
by executing a \texttt{write} call.

\emph{Bypassing TikTok by mapping device-backed files} depends on devices
changing the values of their registers independently of writes. Arguments stored
in such a memory region change their values based on the state of the underlying
hardware. File-systems which report the state of the OS (\texttt{\textbackslash
proc}) also belong in this category.
\mat{This would be better with a strawman design where you can introduce the
concepts about reads/writes and then say that the strawman does not work and you
need something more sophisticated. Call it simplistic design or something.}

% Give credit where due, but also highlight how difficult this problem is
All of these potential vulnerabilities have been noticed by
Watson\footnote{User-space and kernel writes were not differentiated between}
when he analyzed CerbNG\cite{watson2007exploiting} and other system call
wrappers. TikTok must ensure that the protections don't interfere with the
correct execution of the kernel and user programs. In other words - both writes
and the execution flow can only be temporarily affected.

% Simple solutions don't work
The paradox of memory marking schemes can be seen in the case of system calls
that both read and write to the user memory (e.g., \texttt{rt\_sigaction}).
Simply marking the pages as read-only prevents attacks from the user-space, but
also stops the system call from performing the required write. However, if one
enables the writes for the kernel, the adversary can bypass the protection
using a simple \texttt{sys\_read} call to the marked page.

The protection against the attacks \ref{first} and \ref{second} are described in
\cref{subsec:memorywrites}. The defenses against \ref{third}, \ref{fourth}, and
\ref{fifth} are discussed in \cref{subsec:filewrites}.
%\nb{Kernel writes have their own section now.}
% N.B.Kernel and User-space writes have their own separates section.
% U.T. They are in a single section.


\subsection{System Call Argument Protection}

% \nb{What's the point of the colored arrows in the Figures?}
% U.T. I WILL NEED TO ADD A LEGEND. GREEN - BRANCH YES; RED - BRANCH NO

\label{subsec:memorywrites}
\begin{figure}[]
  \centering
  \includegraphics[width = .45 \textwidth]{img/copy_from_user.pdf}
  \caption{\texttt{copy\_from\_user} marks both the file and the pages before
  reading in the data}
  \label{fig:copyfromuser}
\end{figure}


\mat{Why distinguish between primary and secondary goals? All attacks are equal.
Don't distinguish.}
\mat{Start the discussion of the design from a higher level, lead by examples.}
Defending against the writes from user-space (\cref{first}) is the primary
feature of TikTok. System calls read user memory using \texttt{copy\_from\_user}
and its variants. Calls to \texttt{copy\_from\_user} mark the pages as
\emph{read-only} in all virtual memory spaces mapping it (\cref{fig:copyfromuser}). Multiple system
calls can mark a page at the same time. The benefit of marking the page this way
is that it can still be read by other user threads, reducing the performance
penalty of TikTok. When all the system calls that use the page finish executing,
the page is \emph{unmarked} --- the previous permissions are restored.

However, marking the pages is the first part. TikTok needs to guarantee that the
programs still execute correctly. User-space writes to the marked pages trigger
a page-fault (\cref{fig:pagefault}). In the page-fault handler TikTok intercepts
these writes and stops them until the page has been unmarked. After the
unmarking, the thread will exit the handler and redo the write. This technique
introduces additional synchronization points for concurrent programs. Combined
with the coarse granularity of pages (4KBs) deadlocks come up as a potential
problem. During the evaluation of our system we haven't encountered any
deadlocks due to the new synchronization points. The reasoning behind their
scarcity is discussed in \cref{sec:deadlocks}.
% \nb{This seems quite pessimistic. You might want to put a bit more optimism
% here.}
\mat{No abbreviations such as haven't or aren't. We use full form.}
\mat{This concern brings up deadlocks and other issues and should be discussed
at greater length.}

\begin{figure}[]
  \centering
  \includegraphics[width = .75 \linewidth]{img/pagefault.pdf}
  \caption{TikTok's handling of the writes to a marked page}
  \label{fig:pagefault}
\end{figure}

\subsection{Protecting System Call Arguments from Writes by the Kernel}
\label{subsec:kernelland}
\begin{figure}[]
  \centering
  \includegraphics[width = .30 \textwidth]{img/copy_to_user.pdf}
  \caption{\texttt{copy\_to\_user} defers the writes from kernel until the end
  of the system call}
  \label{fig:copytouser}
\end{figure}

% \nb{not absolutely clear why it's
% self-deadlock. You assume read -> block page -> write can't execute?}

\mat{Coming back from the whole deadlock discussion: you need some more
structure. Introduce the problem of deadlocks (hopefully by referencing back to
the simple design on why you actually introduce the risk of deadlocks) then
argue how you avoid them through a clever locking and marking strategy. Then, if
anything remains, discuss any potential risks.}

The process that stops the user-space writes cannot be applied to the writes
from the kernel (attack \ref{second}). As mentioned in
\cref{subsec:designoverview}, such a system would self-deadlock after a system
call performs a read, mark an argument and a write to the same argument or page
(\texttt{rt\_sigaction}). Any solution involving giving the write permissions to
the kernel results in the adversary bypassing the marking using a system call
(e.g., \texttt{sys\_read}).

\mat{Convoluted paragraph. Try to make the argument simpler.}
Unlike user-space writes to user memory, which can happen from any place in the
code, kernel writes can only take place from \texttt{copy\_to\_user} and its
variants. TikTok uses this to its advantage. When the kernel uses
\texttt{copy\_to\_user} to write to a marked page the write is \emph{deferred}
until the end of the call. The function \texttt{copy\_to\_user} exits normally
with the data saved into a data structure. This prevents self-deadlocks because
the program continues the normal execution. At the end of the call (\emph{after
unmarking}), the writes are performed from the data structure in the order in
which they arrived. If the pages are still marked, the writes will wait just
like the writes from the user-space.

\mat{You need a better argument for deadlock freedom.}
These two techniques create a snapshot of the memory at the moment it
was accessed for the first time. This means that all reads will always return
the original values, even if a call had written to them in-between. In case a
system call performs a re-read of the location it has written to and expects a
new value, TikTok would return the old one. However, the authors haven't
encountered such a case, and TikTok can be easily extended to support it. 
%\nb{By handling this edge case particularly or is there a more general approach?}
% To support this edge case. It is a matter of philosophy. Currently we have a
% have a memory snapshot. One can argue that the edge-case is a double-fetch bug.
% Writing to user-space and reading the same information back is quite strange.
% The fix would just involve checking if the location we want to read from has 
% already been written to. The written data would then be returned instead of 
% the data currently in RAM.

%\nb{The two following paragraph are a bit messy.}
Some system-calls rely on writes from user-space to user-space memory for their
correct behavior. During the execution of these calls the memory is changed and
re-read by the kernel. Hence, memory snapshotting is detrimental to these calls.
Changing the value of the arguments for these calls isn't an attack --- it is a
part of their functionality.

The best representatives are \texttt{pollfd}\cite{pollfd} and
\texttt{futex}\cite{futex}. \texttt{pollfd} checks if any of the
file-descriptors in the array passed as an argument are ready to perform I/O.
The user can write \texttt{-1} to memory to indicate that the loop in the call
needs to skip the descriptor. \texttt{futex} is a user-space mutex. Most of
\texttt{futex} synchronization depends on atomic user-space writes, with the
system-call being performed only to awake or make threads wait. If
\texttt{futex} marks a user-space address as read-only, other user-space threads
will be incapable of unlocking the futex by writing to that address. Adding
these calls and their variants to the exception list lead to a successful boot
and functioning of the kernel in the prototype.

% \nb{So your tool cannot
% protect every system call? This information was not laid out beforehand which is
% a bit surprising.}
% I've split the previous paragraph in two and added a reference to these calls
% to the introduction

%\nb{Hmm, you are ignoring
%even more calls without precising which one. I'm slowly starting to think that
%your system is only working for a few ones that you manually picked...}
%
% IT IS TRUE! I AM A FRAUD :'( Write still works if being protected. It is just
% slower.

The administrator can also choose to ignore certain calls to achieve better
performance. However, this can be applied only to some calls. The arguments
stored in memory need to be \emph{unformatted} --- their content isn't important
for filtering. For such a system-call the TOCTTOU attack would be equivalent to executing
a system-call with the new arguments. An example of such a call is
\texttt{write}. However, in the rare case that a filter in system-call wrapper
needs to prevent a certain string from being written into a file, such
optimizations would need to be disabled. This optimization doesn't enable the
call to bypass TikTok. Even though its arguments aren't marked, it isn't allowed
to write to the marked arguments of other calls.In the future integrating TikTok
with eBPF would enable fine tuning of which system-calls and wrappers are
protected from double-fetches.


\subsection{Protecting Against File-Based Attacks}
\label{subsec:filewrites}
% \nb{This sound really similar in style to the background info from earlier}

A malicious user can bypass memory-marking protections by executing the following
sequence (Attack \ref{third}):
\mat{They way you write it sounds as if \sysname is insecure.}
\mat{Structure: introduce all different TOCTTOU attacks in a section; introduce
the naive design; introduce the sophisticated design}

\begin{enumerate}
  \item Map a file \texttt{F} in the process \texttt{A} to a page \texttt{P}
  \item Execute a system-call with the arguments placed on \texttt{P}
  \item The first fetch in the system-call occurs
  \item Map the file \texttt{F} as writable in the process \texttt{B}
  \item Change the values of the arguments on \texttt{P}
  \item The second fetch in the system-call occurs
\end{enumerate}

% \nb{I'll need a bit more info to understand this
% attack. You have a shared+filebacked memory that is used in a double fetch, then
% what happens?}
% \nb{The following sentence is not clear. What does "check"
% means? Mark them as read only?}
% \nb{You can reiterate what is the effect and why
% it is useful.}


To prevent the attack TikTok checks when mapping a new file-backed page if
it is already marked. Such pages are then mapped as marked in the second process
as well.

% \nb{What does it has to do with the previous paragraph? You just gave us a
% solution to our problem and reintroduce new concepts.}
However, another attack may be possible on systems with shared memory and file buffers.
Files in Linux can be accessed in two ways:
\begin{itemize}
    \item by mapping the file to memory
    \item by using system calls to modify the file (e.g., \texttt{write})
\end{itemize}

% \nb{Ok, so that was to introduce the next attack. Either do it in word, "Attack
% 3 is concerned with files access which can be done in two ways in Linux" or
% start a new section.}
Watson\cite{watson2007exploiting} has noticed that protected file-backed pages
could still be edited by a \texttt{write} call if the system uses the same pages
for memory-mapping and buffering when communicating with the block-devices
(Attack \ref{fourth}). The mapped memory would then reflect the state of the
file changed by the \texttt{write} system-call. TikTok prevents this attacks by
pausing the write to the corresponding file as long as it has any marked mapped
pages. As in the \Cref{subsec:memorywrites} no deadlocks were encountered during
testing and the reasoning is discussed in \Cref{sec:deadlocks}. 
% \nb{Third time speaking about deadlock. You might want to
% mention early on that it's not too big of a problem. I'm getting worried the
% whole paper I'm reading will come up with a 200\% overhead in the end...}

% \nb{Again, transition to the next attack is abrupt. Either new section or at
% least mention where are moving to a new scope.}
Finally, TikTok provides no protection against the Attack \ref{fifth}. TikTok
cannot do anything if the values in the mapped pages can change value
independently of writes (such as devices and other pseduo-files). Considering
that mapping device memory to user-space is considered bad practice, we rely on
\emph{Discretionary Access Control} (\textbf{DAC}) to prevent users from mapping
devices in the first place.
% \nb{So, attack 5 still exists. You might want to mention it in the Design
% overview that you do not protect against all of them.}


\section{TikTok Deadlocks}
\label{sec:deadlocks}

\Cref{sec:design} mentions that TikTok may introduce deadlocks to valid
programs. For an OS extension, even a small chance of a random deadlock violates
the presumption of correctness and is unacceptable. Luckily, TikTok deadlocks
can happen only under specific, rare circumstances which violate the principles
of Interprocess Communication (\cref{subsec:ipc}). Ubuntu Server 18.04 LTS
running TikTok is able to successfully boot and execute programs without
encountering deadlocks.
\mat{This is a weak argument.}

% \nb{Please be specific on what
% rare means or mention you will lay them out right afterward. The first sentence
% of the next paragraph doesn't reassure me you will not try to bury the deadlock.}

TikTok adds additional synchronization points to multi-threaded programs by
stalling the writes. It is possible for these points to introduce previously
non-existent deadlocks to programs. Such deadlocking threads would need to
communicate using both shared memory (for TikTok to stop one of them) and
synchronous system calls (for TikTok to mark memory).

\begin{figure}
  \centering
  \begin{subfigure}[b]{0.45\linewidth}
  \begin{minipage}{\linewidth}
  \begin{lstlisting}
  1: S(A,T1);  
  \end{lstlisting}
  \end{minipage}
  \caption{Thread 1}
  \end{subfigure}
  \hfill
  \begin{subfigure}[b]{0.45\linewidth}
  \begin{minipage}{\linewidth}
  \begin{lstlisting}
  2: write(A);
  3: unblock_S(T2);
  \end{lstlisting}  
  \end{minipage}
  \caption{Thread 2}
  \end{subfigure}
  \caption{Executing instructions in the specified order causes a deadlock with TikTok}
  \label{fig:deadlock}
\end{figure}


\Cref{fig:deadlock} shows an example of a such communication pattern. Thread 1
enters the system call \texttt{S} and marks a shared page \texttt{A} (\textbf{1}). The
system call \texttt{S} blocks until the corresponding call \texttt{unblock\_S} is called
in Thread 2 (\textbf{3}). While the page \texttt{A} is still marked, Thread 2
attempts to write to it, causing it to wait for \texttt{S} to finish
(\textbf{2}). All of the deadlocking patterns need to exibit a similar combination
of paired blocking calls (\texttt{S}, \texttt{unblock\_S}) with arguments in the shared
memory (page \texttt{A}). Concretely, in \Cref{fig:deadlock}:

\begin{enumerate}
    \item The page \texttt{A} is shared between Thread 1 and Thread 2
    \item Access to page \texttt{A} is not protected by a mutex, or a semaphore
    \item System call \texttt{S} is a blocking system call that receives a 
    signal from another thread
    \item System call \texttt{S} reads its arguments from the page \texttt{A}
    \item Thread 2 needs to write to the same page where the arguments for 
    \texttt{S} are stored (page \texttt{A})
    \item Even though Threads 1 and 2 can communicate using shared memory, 
    Thread 1 needs to also invoke \texttt{S}
\end{enumerate}

Paired, blocking system-calls \texttt{S} and \texttt{unblock\_S} are quite rare
and can be found only in the IPC message-passing and synchronization calls. In
either case, the arguments for those calls need to be stored in shared memory,
instead on the thread's stack. The only synchronization call the authors are
aware of that requires this is \texttt{futex}, which is already ignored.

However, message-passing calls (e.g. \texttt{sendmsg}) can store the data being
sent in shared memory. In that case, the processes are sending using
message-passing the data which is \emph{already available in the shared memory}.

% Having identified the system call \texttt{S}\nb{So only one system call fits the
% bill?}, the conditions for the deadlock
% can be simplified to:

% \begin{itemize}
%   \item Threads 1 and 2 share memory (page \texttt{A})
%   \item Threads 1 and 2 decide to share the data in the shared memory (page
%         \texttt{A}) using message-passing
%       \item Threads 1 and 2 nb{Both? or is one sufficient?}write to the shared memory (page \texttt{A}) during the
%         message-passing call                       
% \end{itemize}

% \nb{Might want to precise what the testing
% was, how long, etc...}
% U.T. Booting with systemd and running Phoronix benchmark (e.g. Apache)

% \nb{Something
% stronger than just a judgement on programming techniques would be great. Was does
% it not make sense?->one type of communication should be sufficient}

Programs usually rely on a single IPC apstraction (shared memory or
message-passing). Even software that uses both of them would do so for separate
functionalities. The program that replicates the communication using both
primitives would be an example of terrible programming practice. During the
testing of TikTok (\cref{sec:evaluation}) on Ubuntu Server 18.04 LTS the system
booted and executed benchmarks without encountering deadlocks.

Similar sequences can be constructed using the write system call protection
presented in \cref{subsec:filewrites}. The same argument can be applied in that
case - the program needs to write to the same data to the file using both memory
mapping and a system call at the same time. We have not encountered such a
problem. I WILL PROBABLY NEED TO RUN UBUNTU FOR 24HRS TO CONFIRM THIS. I DON'T HAVE
ANY STRONGER ARGUMENTS OTHER THAN "IT WORKS FOR NOW". ANOTHER PROBLEM IS IF THERE IS
A LIVELOCK. HOW WILL I KNOW? WHAT PROGRAMS SHOULD I RUN?
% \nb{It seems to me you are dismissing things too quickly. You need to
% make me come to the same conclusion. Additionally, you just added a new possible
% sequence, sure there is no other?}


% Here we mention SOME of the interesting implementation decisions. It is
% mostly related to x86 and should be short. ARM support should also be
% be mentioned, but Future work could be a better section for that
\section{Implementation}
\label{sec:implementation}

%\mat{What's the message here? Say what you implement based on which design decisions.}
TikTok prototype has been implemented on Linux x86-64. However, TikTok can be
ported to any operating systems that use a defined interface for reads and
writes to the user-space, and any architecture that has page tables
encoding access control information. Depending on the available resources
(e.g. the number of free bits in the PTE)
information can be stored in different places (e.g., PTE or global structures).

\Cref{fig:bookkeeping} illustrates some of the most important data structures
used in the prototype --- the PTE with the permissions, the marked page metadata
(number of threads marking the page frame, number of threads waiting for the
unmarking, the reverse mapping information).
% \nb{Might be interesting to reiterate which info we need
% to store}
\Cref{subsec:frameinfo} describes the data about the
physical page frame with some of the limitations due to the need to keep
\texttt{struct page} as small as possible. Considering that one \texttt{struct
page} exists for every page frame on the system, increasing its size would
drastically increase the memory overhead.  The data stored in the page table
(permissions, free bits and page frame number) is explained in more detail in
\cref{subsec:pageinfo}.
%\nb{same as above}
%\nb{Why keep it small?}

\subsection{Storing the Page Frame Information}
\label{subsec:frameinfo}
Linux divides physical memory into page frames. Each page frame is represented
by a \texttt{struct page}. Considering that this structure is replicated
millions of times, every additional field has a tremendous impact on memory
consumption.
\mat{What did I say about forced newlines?}
\\
\\
To keep the memory consumption low, TikTok uses a single bit in \texttt{struct
page} to mark page frames. Considering that x86-64 has enough bits in the flag
field, we have decided to use one of the flag bits for this purpose.
Architectures that have fewer flag bits (such as x86) can instead use some of
the bits used by other features (e.g., Kernel Shared Memory or NUMA domains). On
\cref{fig:bookkeeping} this field is denoted by \emph{Page Marked Flag}.
\texttt{struct page} also stores a pointer to the \emph{reverse mapping}
information. The reverse mapping is used to find all PTEs \emph{TikTok} needs to
(un)mark.
\\
\\
The marking metadata is stored in a hashmap based on the \emph{page frame
number}. The access to these entries is protected by separate mutexes to improve
the scalability of the system. The metadata comprise the page frame number, the
count of threads marking the page (\emph{owners}), the number of threads waiting
for the page to get unmarked (\emph{guests}), and a \emph{queue} they are
waiting on. 

\subsection{PTE Information}
\label{subsec:pageinfo}

When we mark a page we change some of the flags in the PTEs mapping it
(\cref{fig:bookkeeping}):

\begin{description}
  \item[R/W] gets set to \emph{read-only} to prevent writes to the page
  \item[SW2] gets the old value of \textbf{R/W}
  \item[SW3] gets set to 1 
\end{description}

\textbf{SW2} is used by the Software Dirty Pages
feature of Linux. This feature cannot run alongside TikTok in our prototype.
Other architectures may have less, or more bits available for the OS to use. In
the case of lack of space in the page table, \texttt{SW2} and \texttt{SW3} could
be stored in a separate data structure.

\emph{Copy-on-write} pages have a peculiar optimization. They are marked only in
the process requesting the marking. Writes from other processes will trigger a
copy-on-write mechanism, preventing them from changing the data.

TikTok does a partial flush of the TLB and updates the MMU cache to make these
changes visible immediately. The performance impact of this is analyzed further
in \cref{sec:evaluation}.

\begin{figure}[]
  \centering
  \includegraphics[width=\linewidth]{img/book-keeping.pdf}
  \caption{The most important marking information on x86}
  \label{fig:bookkeeping}
\end{figure}

\section{Evaluation}
\label{sec:evaluation}

\begin{figure*}[]
  \centering
  \includegraphics[width=\linewidth]{img/eval.pdf}
  \caption{Performance of TikTok Compared to the Stock Kernel}
  \label{fig:tiktokeval}
\end{figure*}

\mat{Describe what you evaluate and why you evaluate it. Break up into
microbenchmarks to show overhead and different usage scenarios. For each section
talk about trade-offs and results.}

TikTok has been evaluated on various kernel benchmarks in Phoronix
Test Suite\cite{phoronix}. The test machine was running Ubuntu Server 18.04 LTS
with the Linux kernel 5.4.0-rc3+ on Intel i7-9700 with 16GB of RAM.

\Cref{fig:tiktokeval} shows the results of the Phoronix benchmark. All
results have been normalized to measure performance (higher is better) with the
performance of the stock kernel being the baseline.

Benchmarks Linux compilation, OpenSSL, Redis, Basis, Git and PyBench show a
small degradation in performance --- less than 2\%. These programs don't feature
a lot of inter-process communication. Even the parallelized benchmarks such as
Linux kernel compilation generate independent processes.

However, the two web servers (Apache and NGINX) show a significant drop in
performance (13.6\% and 11.0\%). They are multithreaded applications with a
significant number of system calls being executed. The IPC TCP benchmark has
only two communicating processes and exhibits a smaller overhead (4.3\%).
\mat{This needs a much longer explanation.}

Analyzing Apache and IPC benchmark executions with \texttt{perf} it was possible
to determine which functions were executing slower with TikTok.
\Cref{table:perf} shows how much time the programs spend in the functions added
by TikTok. Percentages of individual segments have been measured by
\texttt{perf}, while the total overhead is calculated from the results of the
benchmark. Furthermore, TLB is flushed both during the marking and unmarking of
pages.

\begin{table*}[]
  \label{table:perf}
  \centering
  \begin{tabular}{|l|l|l|l|l|}
  \hline
                                 & Apache & Apache (TikTok) & IPC & IPC (TikTok)\\ \hline
  Marking pages read-only        & 0\%    & 4.33\%          & 0\% & 0\%         \\ \hline
  Unmarking pages                & 0\%    & 3.83\%          & 0\% & 0.98\%      \\ \hline
  Flushing Individual TLB Ranges & 1.50\% & 5.72\%          & 0\% & 0\%         \\ \hline
  Write Bypass Protection        & 0\%    & 0\%             & 0\% & 1.47\%      \\ \hline
  Read Bypass Protection         & 0\%    & 0\%             & 0\% & 1.15\%      \\ \hline
  Total Overhead                 & 0\%    & 13.59\%         & 0\% & 4.29\%      \\ \hline
  \end{tabular}
  \caption{Perf Analysis of the Benchmarks}
\end{table*}

The comparison of the Apache and IPC runs shows two very different marking
profiles. Apache spends a considerable amount of time marking and unmarking
pages, while IPC does not mark pages at all. This is a consequence of the
different system-calls used by these applications. IPC uses only \texttt{read}
and \texttt{write} calls which do not mark arguments, while Apache also invokes
system-calls which mark arguments (\texttt{accept}, \texttt{getsockname}).
Consequentially, Apache spends a lot of time marking and unmarking pages.

In these two segments Apache actually waits most of the time for the TLB
signaling functions to execute. \texttt{flush\_tlb\_mm\_range} amounts for
2.51\% (marking) and 2.10\% (unmarking) of the total time spent executing the
benchmark. Frequent TLB flushes are expensive because the CPU needs to make sure
that all the cores have processed the signal before continuing. Unfortunately,
this is only a part of the overhead incurred by flushing the TLB. Flushed pages
will be accessed right afterward leading to a TLB miss, further inflating the
overhead.

IPC benchmark executes only \texttt{write} and \texttt{read} calls. It doesn't
incur any overhead on TLB flushes because none of these calls mark pages.
However, the protections against bypassing TikTok using these calls are still
active, leading to a significant locking overhead. Without TLB flushes it is
interesting to notice that the overhead of individual components roughly adds
up to the total overhead in the IPC benchmark.


% In this section we need to convince the reader in two things:
% 1) Alternative filtering approaches to system call filters are incomplete and
% cumbersome
% 2) The best way to solve the TOCTTOU bug in filters is TikTok. All other
% methods can only fix other double-fetches, or they force you to use TSX
\section{Related Work}
\label{sec:relatedwork}

%\mat{Numbers smaller than 10 should be written out: two!}
The literature related to TikTok can be broadly divided into two groups. In the
first group are system call wrappers whose main vulnerability TikTok is
mitigating. The second ones are the mitigations and solutions for
double-fetches, which are a superclass of TOCTTOU bugs.

We describe the benefits that system call wrappers compared to other solutions.
We show that all other filters that ignore or remove the TOCTTOU problem have
to either reduce the security guarantees they offer, or violate the separation
of the filter and the system call.
% \nb{it could be interesting to mention these
% things beforehand as motivation for tiktok. Otherwise the impostance is not
% obvious to the reader.}

Afterward, we take a look at alternative ways to address the TOCTTOU bug of the
system call wrappers. Most of them are focused on finding and fixing the bug,
which isn't possible in this case. TikTok is also compared against other runtime
mitigations of double-fetches.

\subsection{System Call Wrappers and Filters}

Watson \cite{watson2007exploiting} scrutinized the security of many system call
wrappers. Not only did he found that all of them were insecure, Watson also
described the different types of TOCTTOU bugs and discussed potential fixes. In
a short paragraph, he mentions that Pawel Dawidek, the creator of CerbNG
\cite{zak_frasunek_dawidek}, has experimented with marking arguments read-only.
CerbNG was an early system call filtering system for BSD that used
copy-on-read-and-write to a new memory page.

Afterward, Watson briefly discusses problems such memory marking systems
need to solve: 
\begin{itemize}
    \item unnecessary page-faults
    \item bypassing memory marking using IO system calls
    \item mapping shared memory with different permissions
    \item handling system calls that both read and write to the same memory
\end{itemize}

According to Watson, no memory-marking system (including CerbNG) addressed all
of these problems. TikTok does exactly that. Unnecessary page-faults are rare
and they are used to make the offending threads wait for unmarking. After the
page has been unmarked, the write proceeds without any consequences. Write
system call does not proceed until there are no marked pages of the file. If
needed, pages are marked when they are mapped. TikTok postpones all writes to
marked pages coming from the kernel while allowing the system calls to execute
correctly.
%\nb{Good paragraph!}

Modern system call wrappers can be classified into two groups, based on how they
approach the TOCTTOU attack. The first group eliminates all functionality
vulnerable to the attack. Linux's \emph{SecComp}\cite{seccomp} and
\emph{eBPF}\cite{ebpf} belong to this group. The second group moves the filter
checks deeper into the system calls, eliminating the need to read the arguments
twice. \emph{Landlock Linux} \cite{landlock} and Google's \emph{Kernel Runtime
Security Instrumentation} (KRSI)\cite{krsi} embrace this technique.

\subsubsection{Partial Solutions}
SecComp\cite{seccomp} uses \emph{Berkeley Packet Filter} (BPF) to provide small,
programmable filters that execute before the system call. Based on the values
in registers, Linux can decide whether to allow or to prevent a system call.
However, BPF cannot dereference pointers because an adversary would be able to
bypass those checks using a TOCTTOU attack. \emph{Extended Berkeley Packet
Filter} (eBPF)\cite{ebpf} provides larger filters that can also dereference
user pointers. However, eBPF cannot be used for security purposes --- it cannot
stop system calls from executing. eBPF is completely read-only and can only be
used for tracing.

\subsubsection{LSM-based Solutions}
Landlock\cite{landlock} and KRSI\cite{krsi} use the \emph{Linux Security Module}
\cite{morris2002linux} (LSM) hooks to call filter checks after the arguments
have already been copied into the kernel. LSM hooks have been imagined as a set
of places where arbitrary checks can be performed before accessing a kernel
resource. Execution proceeds only if the execution has been successful.
Different security modules can provide different hooks to provide different
guarantees (e.g., \emph{SELinux}\cite{smalley2001implementing} and
\emph{AppArmor}\cite{gruenbacher2007apparmor}).

Both Landlock and KPSI attach eBPF filters to hooks, allowing users to provide
custom rules for system calls. For this solution to work everywhere for perfect
syscall filtering, LSM hooks would need to be manually added to all Linux
drivers and \texttt{ioctls}. Unfortunately, this is highly impractical and requires
considerable effort from a large group of developers. Considering that LSM
focuses on access control to kernel objects, it is questionable if an LSM module
can be used to mitigate bugs based on the system call arguments. Some of the
bugs could manifest themselves before a hook has been executed. TikTok is a
generic solution that does not require modifying the drivers, nor the use of
LSM hooks. Once it is deployed, all double-fetch bugs are eliminated from all
the drivers. A system call wrapper that uses TikTok can be completely
independent of the implementation of the system calls it is filtering.

\subsection{Double-Fetch Solutions}

Solutions for double-fetch bugs can be divided into \emph{static} and
\emph{dynamic} techniques. Static techniques do not execute the program but
analyze the source code. Dynamic techniques analyze the execution of the
program to find any violations.

\subsubsection{Static Analysis Work}
\label{subsec:dfstatic}
Static analysis techniques analyze the source code to find double-fetch bugs.
Wang et al. \cite{wang2017double} used pattern matching to find potential
double-fetches. They implemented a tool that patches certain double-fetches
automatically. However, their method in the general case produces false
positives that need to be inspected manually. Xu et al.\cite{xu2018precise}
improved on this work by proposing Deadline. Deadline does not use the pattern 
analysis on the source files to detect double-fetches, but a compiler's
intermediate representation and constraint solving to eliminate false positives.

Static analysis techniques such as these have the benefit of being able to find
bugs in the code that we cannot run (e.g., we are missing hardware to test the
drivers). However, they are meant for bug detection, not mitigation. Even though
the tools can fix some bugs automatically, this is not always possible. The
TOCTTOU bug is in system call wrappers by design. Double-fetches not visible in
the source, nor in the intermediate representation are another problem.
Compilers can introduce such invisible double-fetches when allocating registers
to variables. TikTok is a mitigation technique that works even in such cases.


\subsubsection{Dynamic Analysis Work}
Google Project Zero's Bochspwn \cite{jurczyk2013bochspwn} uses an emulator to
detect double-fetches. It found quite a large number of bugs in the Windows
kernel. Bochspwn works on binaries. It does not require access to the source
code and it detects bugs introduced by compilers.
DFTracker\cite{wang2019dftracker} is another dynamic analysis technique work
with a lower overhead, that relies on taint tracking. However, these dynamic
techniques are limited to the detection of double-fetches. Similarly to work
presented in \cref{subsec:dfstatic}, developers need to manually fix the bugs.
However, with dynamic analysis a double-fetch needs to be executed, limiting
this technique to the core kernel and to the drivers with the available
hardware.

A big leap in dynamic analysis techniques has been presented by Schwartz et al.
\cite{schwarz2018automated}. The first part of the paper introduces DECAF - a
framework that uses side-channel attacks to create a fuzzing oracle for
double-fetch bugs. While Bochspwn relies on emulation, slowing the execution
significantly, DECAF runs natively. It also eliminates false positives by
automatically exploiting found bugs.

Schwartz et al. then discuss a real-time mitigation technique for double
fetches - DropIt. DropIt uses Intel's \emph{Transactional Synchronization 
Extensions} (TSX)\cite{intel64and} in a creative way to prevent double-fetch
bugs. By encapsulating the code in a TSX transaction, writes from other threads
to the addresses that have been accessed will result in the
transaction being aborted. However, the code executing inside a TSX transaction
is severely limited. All reads must fit in the L3 cache, and all writes in L1.
Some instructions are also forbidden. TikTok has none of those limitations.
It works on non-Intel processors and relies on page tables for protection - a
technique that has been present for several decades.

\section{Further Work}

Considering the performance impact, it isn't feasable to run TikTok for all
system-calls. Integration with an existing system-call wrapper would lead to the
improved flexibility and performance. SecComp\cite{seccomp} and eBPF\cite{ebpf}
are obvious candidates that would benefit from such an extension. Another
optimization would be to mark only the pages accessed by the filter, and not the
system-call body.

\section{Conclusion}

This work is the first work to mitigate double-fetches in the Linux kernel
without significantly reducing the length and the instructions used in system
calls. In doing so it mitigates a previously unfixable TOCTTOU bug in
system-call wrappers. TikTok also solves the problem the system-call wrappers
have had with system-calls that both read and write into the user-space memory.
These breakthrough make system-call wrappers again a viable solution, not only
for the reduction of the attack surface, but also for the mitigation of
vulnerabilities until a patch is available.
%-------------------------------------------------------------------------------
%\section*{Acknowledgments}
%-------------------------------------------------------------------------------

%-------------------------------------------------------------------------------
\section*{Availability}
%-------------------------------------------------------------------------------

The source code of TikTok is available at LINK. It has been released under the
GNU Public Licence.

%-------------------------------------------------------------------------------
\bibliographystyle{plain}
\bibliography{\jobname}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%  LocalWords:  endnotes includegraphics fread ptr nobj noindent
%%  LocalWords:  pdflatex acks
